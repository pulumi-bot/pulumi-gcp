// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputApi from "../../../types/input";
import * as outputApi from "../../../types/output";
import * as utilities from "../../../utilities";

export interface ClusterAddonsConfig {
    cloudrunConfig: outputApi.container.ClusterAddonsConfigCloudrunConfig;
    horizontalPodAutoscaling: outputApi.container.ClusterAddonsConfigHorizontalPodAutoscaling;
    httpLoadBalancing: outputApi.container.ClusterAddonsConfigHttpLoadBalancing;
    istioConfig: outputApi.container.ClusterAddonsConfigIstioConfig;
    kubernetesDashboard: outputApi.container.ClusterAddonsConfigKubernetesDashboard;
    networkPolicyConfig: outputApi.container.ClusterAddonsConfigNetworkPolicyConfig;
}

export interface ClusterAddonsConfigCloudrunConfig {
    disabled?: boolean;
}

export interface ClusterAddonsConfigHorizontalPodAutoscaling {
    disabled?: boolean;
}

export interface ClusterAddonsConfigHttpLoadBalancing {
    disabled?: boolean;
}

export interface ClusterAddonsConfigIstioConfig {
    auth?: string;
    disabled?: boolean;
}

export interface ClusterAddonsConfigKubernetesDashboard {
    disabled?: boolean;
}

export interface ClusterAddonsConfigNetworkPolicyConfig {
    disabled?: boolean;
}

export interface ClusterAuthenticatorGroupsConfig {
    securityGroup: string;
}

export interface ClusterClusterAutoscaling {
    enabled: boolean;
    resourceLimits?: outputApi.container.ClusterClusterAutoscalingResourceLimit[];
}

export interface ClusterClusterAutoscalingResourceLimit {
    maximum?: number;
    minimum?: number;
    resourceType: string;
}

export interface ClusterDatabaseEncryption {
    keyName: string;
    state: string;
}

export interface ClusterIpAllocationPolicy {
    clusterIpv4CidrBlock: string;
    clusterSecondaryRangeName: string;
    createSubnetwork?: boolean;
    nodeIpv4CidrBlock: string;
    servicesIpv4CidrBlock: string;
    servicesSecondaryRangeName: string;
    subnetworkName?: string;
    useIpAliases?: boolean;
}

export interface ClusterMaintenancePolicy {
    dailyMaintenanceWindow: outputApi.container.ClusterMaintenancePolicyDailyMaintenanceWindow;
}

export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
    duration: string;
    startTime: string;
}

export interface ClusterMasterAuth {
    clientCertificate: string;
    clientCertificateConfig: outputApi.container.ClusterMasterAuthClientCertificateConfig;
    clientKey: string;
    clusterCaCertificate: string;
    password?: string;
    username?: string;
}

export interface ClusterMasterAuthClientCertificateConfig {
    issueClientCertificate: boolean;
}

export interface ClusterMasterAuthorizedNetworksConfig {
    cidrBlocks?: outputApi.container.ClusterMasterAuthorizedNetworksConfigCidrBlock[];
}

export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
    cidrBlock: string;
    displayName?: string;
}

export interface ClusterNetworkPolicy {
    enabled?: boolean;
    provider?: string;
}

export interface ClusterNodeConfig {
    diskSizeGb: number;
    diskType: string;
    guestAccelerators: outputApi.container.ClusterNodeConfigGuestAccelerator[];
    imageType: string;
    labels: {[key: string]: string};
    localSsdCount: number;
    machineType: string;
    metadata: {[key: string]: string};
    minCpuPlatform?: string;
    oauthScopes: string[];
    preemptible?: boolean;
    sandboxConfig?: outputApi.container.ClusterNodeConfigSandboxConfig;
    serviceAccount: string;
    tags?: string[];
    taints: outputApi.container.ClusterNodeConfigTaint[];
    workloadMetadataConfig?: outputApi.container.ClusterNodeConfigWorkloadMetadataConfig;
}

export interface ClusterNodeConfigGuestAccelerator {
    count: number;
    type: string;
}

export interface ClusterNodeConfigSandboxConfig {
    sandboxType: string;
}

export interface ClusterNodeConfigTaint {
    effect: string;
    key: string;
    value: string;
}

export interface ClusterNodeConfigWorkloadMetadataConfig {
    nodeMetadata: string;
}

export interface ClusterNodePool {
    autoscaling?: outputApi.container.ClusterNodePoolAutoscaling;
    /**
     * The number of nodes to create in this
     * cluster's default node pool. Must be set if `nodePool` is not set. If
     * you're using `gcp.container.NodePool` objects with no default node pool,
     * you'll need to set this to a value of at least `1`, alongside setting
     * `removeDefaultNodePool` to `true`.
     */
    initialNodeCount: number;
    /**
     * List of instance group URLs which have been assigned
     * to the cluster.
     */
    instanceGroupUrls: string[];
    management: outputApi.container.ClusterNodePoolManagement;
    maxPodsPerNode: number;
    /**
     * The name of the cluster, unique within the project and
     * location.
     */
    name: string;
    namePrefix: string;
    /**
     * Parameters used in creating the default node pool.
     * Generally, this field should not be used at the same time as a
     * `gcp.container.NodePool` or a `nodePool` block; this configuration
     * manages the default node pool, which isn't recommended to be used with
     * this provider. Structure is documented below.
     */
    nodeConfig: outputApi.container.ClusterNodePoolNodeConfig;
    nodeCount: number;
    version: string;
}

export interface ClusterNodePoolAutoscaling {
    maxNodeCount: number;
    minNodeCount: number;
}

export interface ClusterNodePoolManagement {
    autoRepair?: boolean;
    autoUpgrade?: boolean;
}

export interface ClusterNodePoolNodeConfig {
    diskSizeGb: number;
    diskType: string;
    guestAccelerators: outputApi.container.ClusterNodePoolNodeConfigGuestAccelerator[];
    imageType: string;
    labels: {[key: string]: string};
    localSsdCount: number;
    machineType: string;
    metadata: {[key: string]: string};
    minCpuPlatform?: string;
    oauthScopes: string[];
    preemptible?: boolean;
    sandboxConfig?: outputApi.container.ClusterNodePoolNodeConfigSandboxConfig;
    serviceAccount: string;
    tags?: string[];
    taints: outputApi.container.ClusterNodePoolNodeConfigTaint[];
    workloadMetadataConfig?: outputApi.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig;
}

export interface ClusterNodePoolNodeConfigGuestAccelerator {
    count: number;
    type: string;
}

export interface ClusterNodePoolNodeConfigSandboxConfig {
    sandboxType: string;
}

export interface ClusterNodePoolNodeConfigTaint {
    effect: string;
    key: string;
    value: string;
}

export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
    nodeMetadata: string;
}

export interface ClusterPodSecurityPolicyConfig {
    enabled: boolean;
}

export interface ClusterPrivateClusterConfig {
    enablePrivateEndpoint?: boolean;
    enablePrivateNodes?: boolean;
    masterIpv4CidrBlock?: string;
    privateEndpoint: string;
    publicEndpoint: string;
}

export interface ClusterResourceUsageExportConfig {
    bigqueryDestination: outputApi.container.ClusterResourceUsageExportConfigBigqueryDestination;
    enableNetworkEgressMetering?: boolean;
}

export interface ClusterResourceUsageExportConfigBigqueryDestination {
    datasetId: string;
}

export interface ClusterVerticalPodAutoscaling {
    enabled?: boolean;
}

export interface ClusterWorkloadIdentityConfig {
    identityNamespace: string;
}
