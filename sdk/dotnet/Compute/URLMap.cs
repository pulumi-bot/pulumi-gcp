// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Compute
{
    /// <summary>
    /// UrlMaps are used to route requests to a backend service based on rules
    /// that you define for the host and path of an incoming URL.
    /// 
    /// 
    /// To get more information about UrlMap, see:
    /// 
    /// * [API documentation](https://cloud.google.com/compute/docs/reference/rest/v1/urlMaps)
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-google/blob/master/website/docs/r/compute_url_map.html.markdown.
    /// </summary>
    public partial class URLMap : Pulumi.CustomResource
    {
        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Output("creationTimestamp")]
        public Output<string> CreationTimestamp { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The backend service or backend bucket to use when none of the given paths match.
        /// </summary>
        [Output("defaultService")]
        public Output<string?> DefaultService { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic
        /// locking.
        /// </summary>
        [Output("fingerprint")]
        public Output<string> Fingerprint { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Output("headerAction")]
        public Output<Outputs.URLMapHeaderAction?> HeaderAction { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of HostRules to use against the URL.  Structure is documented below.
        /// </summary>
        [Output("hostRules")]
        public Output<ImmutableArray<Outputs.URLMapHostRules>> HostRules { get; private set; } = null!;

        /// <summary>
        /// The unique identifier for the resource.
        /// </summary>
        [Output("mapId")]
        public Output<int> MapId { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of the URL if the
        /// hostRule matches the URL's host portion.
        /// </summary>
        [Output("pathMatchers")]
        public Output<ImmutableArray<Outputs.URLMapPathMatchers>> PathMatchers { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The URI of the created resource.
        /// </summary>
        [Output("selfLink")]
        public Output<string> SelfLink { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of expected URL mapping tests. Request to update this UrlMap will
        /// succeed only if all of the test cases pass. You can specify a maximum of 100
        /// tests per UrlMap.  Structure is documented below.
        /// </summary>
        [Output("tests")]
        public Output<ImmutableArray<Outputs.URLMapTests>> Tests { get; private set; } = null!;


        /// <summary>
        /// Create a URLMap resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public URLMap(string name, URLMapArgs? args = null, CustomResourceOptions? options = null)
            : base("gcp:compute/uRLMap:URLMap", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private URLMap(string name, Input<string> id, URLMapState? state = null, CustomResourceOptions? options = null)
            : base("gcp:compute/uRLMap:URLMap", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing URLMap resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static URLMap Get(string name, Input<string> id, URLMapState? state = null, CustomResourceOptions? options = null)
        {
            return new URLMap(name, id, state, options);
        }
    }

    public sealed class URLMapArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The backend service or backend bucket to use when none of the given paths match.
        /// </summary>
        [Input("defaultService")]
        public Input<string>? DefaultService { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<Inputs.URLMapHeaderActionArgs>? HeaderAction { get; set; }

        [Input("hostRules")]
        private InputList<Inputs.URLMapHostRulesArgs>? _hostRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of HostRules to use against the URL.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.URLMapHostRulesArgs> HostRules
        {
            get => _hostRules ?? (_hostRules = new InputList<Inputs.URLMapHostRulesArgs>());
            set => _hostRules = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("pathMatchers")]
        private InputList<Inputs.URLMapPathMatchersArgs>? _pathMatchers;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of the URL if the
        /// hostRule matches the URL's host portion.
        /// </summary>
        public InputList<Inputs.URLMapPathMatchersArgs> PathMatchers
        {
            get => _pathMatchers ?? (_pathMatchers = new InputList<Inputs.URLMapPathMatchersArgs>());
            set => _pathMatchers = value;
        }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("tests")]
        private InputList<Inputs.URLMapTestsArgs>? _tests;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of expected URL mapping tests. Request to update this UrlMap will
        /// succeed only if all of the test cases pass. You can specify a maximum of 100
        /// tests per UrlMap.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.URLMapTestsArgs> Tests
        {
            get => _tests ?? (_tests = new InputList<Inputs.URLMapTestsArgs>());
            set => _tests = value;
        }

        public URLMapArgs()
        {
        }
    }

    public sealed class URLMapState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Input("creationTimestamp")]
        public Input<string>? CreationTimestamp { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The backend service or backend bucket to use when none of the given paths match.
        /// </summary>
        [Input("defaultService")]
        public Input<string>? DefaultService { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic
        /// locking.
        /// </summary>
        [Input("fingerprint")]
        public Input<string>? Fingerprint { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<Inputs.URLMapHeaderActionGetArgs>? HeaderAction { get; set; }

        [Input("hostRules")]
        private InputList<Inputs.URLMapHostRulesGetArgs>? _hostRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of HostRules to use against the URL.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.URLMapHostRulesGetArgs> HostRules
        {
            get => _hostRules ?? (_hostRules = new InputList<Inputs.URLMapHostRulesGetArgs>());
            set => _hostRules = value;
        }

        /// <summary>
        /// The unique identifier for the resource.
        /// </summary>
        [Input("mapId")]
        public Input<int>? MapId { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("pathMatchers")]
        private InputList<Inputs.URLMapPathMatchersGetArgs>? _pathMatchers;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of the URL if the
        /// hostRule matches the URL's host portion.
        /// </summary>
        public InputList<Inputs.URLMapPathMatchersGetArgs> PathMatchers
        {
            get => _pathMatchers ?? (_pathMatchers = new InputList<Inputs.URLMapPathMatchersGetArgs>());
            set => _pathMatchers = value;
        }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The URI of the created resource.
        /// </summary>
        [Input("selfLink")]
        public Input<string>? SelfLink { get; set; }

        [Input("tests")]
        private InputList<Inputs.URLMapTestsGetArgs>? _tests;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of expected URL mapping tests. Request to update this UrlMap will
        /// succeed only if all of the test cases pass. You can specify a maximum of 100
        /// tests per UrlMap.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.URLMapTestsGetArgs> Tests
        {
            get => _tests ?? (_tests = new InputList<Inputs.URLMapTestsGetArgs>());
            set => _tests = value;
        }

        public URLMapState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class URLMapHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapHeaderActionArgs()
        {
        }
    }

    public sealed class URLMapHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapHeaderActionGetArgs()
        {
        }
    }

    public sealed class URLMapHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapHostRulesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("hosts", required: true)]
        private InputList<string>? _hosts;

        /// <summary>
        /// -
        /// (Required)
        /// The list of host patterns to match. They must be valid hostnames, except * will
        /// match any string of ([a-z0-9-.]*). In that case, * must be the first character
        /// and must be followed in the pattern by either - or ..
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of the URL if the
        /// hostRule matches the URL's host portion.
        /// </summary>
        [Input("pathMatcher", required: true)]
        public Input<string> PathMatcher { get; set; } = null!;

        public URLMapHostRulesArgs()
        {
        }
    }

    public sealed class URLMapHostRulesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("hosts", required: true)]
        private InputList<string>? _hosts;

        /// <summary>
        /// -
        /// (Required)
        /// The list of host patterns to match. They must be valid hostnames, except * will
        /// match any string of ([a-z0-9-.]*). In that case, * must be the first character
        /// and must be followed in the pattern by either - or ..
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of the URL if the
        /// hostRule matches the URL's host portion.
        /// </summary>
        [Input("pathMatcher", required: true)]
        public Input<string> PathMatcher { get; set; } = null!;

        public URLMapHostRulesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The backend service or backend bucket to use when none of the given paths match.
        /// </summary>
        [Input("defaultService")]
        public Input<string>? DefaultService { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersHeaderActionArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("pathRules")]
        private InputList<URLMapPathMatchersPathRulesArgs>? _pathRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of path rules. Use this list instead of routeRules when routing based
        /// on simple path matching is all that's required. The order by which path rules
        /// are specified does not matter. Matches are always done on the longest-path-first
        /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        /// irrespective of the order in which those paths appear in this list. Within a
        /// given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesArgs> PathRules
        {
            get => _pathRules ?? (_pathRules = new InputList<URLMapPathMatchersPathRulesArgs>());
            set => _pathRules = value;
        }

        [Input("routeRules")]
        private InputList<URLMapPathMatchersRouteRulesArgs>? _routeRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of ordered HTTP route rules. Use this list instead of pathRules when
        /// advanced route matching and routing actions are desired. The order of specifying
        /// routeRules matters: the first rule that matches will cause its specified routing
        /// action to take effect. Within a given pathMatcher, only one of pathRules or
        /// routeRules must be set. routeRules are not supported in UrlMaps intended for
        /// External load balancers.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesArgs> RouteRules
        {
            get => _routeRules ?? (_routeRules = new InputList<URLMapPathMatchersRouteRulesArgs>());
            set => _routeRules = value;
        }

        public URLMapPathMatchersArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The backend service or backend bucket to use when none of the given paths match.
        /// </summary>
        [Input("defaultService")]
        public Input<string>? DefaultService { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersHeaderActionGetArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("pathRules")]
        private InputList<URLMapPathMatchersPathRulesGetArgs>? _pathRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of path rules. Use this list instead of routeRules when routing based
        /// on simple path matching is all that's required. The order by which path rules
        /// are specified does not matter. Matches are always done on the longest-path-first
        /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        /// irrespective of the order in which those paths appear in this list. Within a
        /// given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesGetArgs> PathRules
        {
            get => _pathRules ?? (_pathRules = new InputList<URLMapPathMatchersPathRulesGetArgs>());
            set => _pathRules = value;
        }

        [Input("routeRules")]
        private InputList<URLMapPathMatchersRouteRulesGetArgs>? _routeRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of ordered HTTP route rules. Use this list instead of pathRules when
        /// advanced route matching and routing actions are desired. The order of specifying
        /// routeRules matters: the first rule that matches will cause its specified routing
        /// action to take effect. Within a given pathMatcher, only one of pathRules or
        /// routeRules must be set. routeRules are not supported in UrlMaps intended for
        /// External load balancers.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesGetArgs> RouteRules
        {
            get => _routeRules ?? (_routeRules = new InputList<URLMapPathMatchersRouteRulesGetArgs>());
            set => _routeRules = value;
        }

        public URLMapPathMatchersGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersHeaderActionArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersHeaderActionGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesArgs : Pulumi.ResourceArgs
    {
        [Input("paths", required: true)]
        private InputList<string>? _paths;

        /// <summary>
        /// -
        /// (Required)
        /// The list of path patterns to match. Each must start with / and the only place a
        /// * is allowed is at the end following a /. The string fed to the path matcher
        /// does not include any text after the first ? or #, and those chars are not
        /// allowed here.
        /// </summary>
        public InputList<string> Paths
        {
            get => _paths ?? (_paths = new InputList<string>());
            set => _paths = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching matchRule, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If  routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<URLMapPathMatchersPathRulesRouteActionArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When this rule is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<URLMapPathMatchersPathRulesUrlRedirectArgs>? UrlRedirect { get; set; }

        public URLMapPathMatchersPathRulesArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesGetArgs : Pulumi.ResourceArgs
    {
        [Input("paths", required: true)]
        private InputList<string>? _paths;

        /// <summary>
        /// -
        /// (Required)
        /// The list of path patterns to match. Each must start with / and the only place a
        /// * is allowed is at the end following a /. The string fed to the path matcher
        /// does not include any text after the first ? or #, and those chars are not
        /// allowed here.
        /// </summary>
        public InputList<string> Paths
        {
            get => _paths ?? (_paths = new InputList<string>());
            set => _paths = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching matchRule, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If  routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<URLMapPathMatchersPathRulesRouteActionGetArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When this rule is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<URLMapPathMatchersPathRulesUrlRedirectGetArgs>? UrlRedirect { get; set; }

        public URLMapPathMatchersPathRulesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionCorsPolicyArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicyArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionRetryPolicyArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<URLMapPathMatchersPathRulesRouteActionTimeoutArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<URLMapPathMatchersPathRulesRouteActionUrlRewriteArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs>());
            set => _weightedBackendServices = value;
        }

        public URLMapPathMatchersPathRulesRouteActionArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionCorsPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// If true, specifies the CORS policy is disabled.
        /// which indicates that the CORS policy is in effect. Defaults to false.
        /// </summary>
        [Input("disabled", required: true)]
        public Input<bool> Disabled { get; set; } = null!;

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public URLMapPathMatchersPathRulesRouteActionCorsPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionCorsPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// If true, specifies the CORS policy is disabled.
        /// which indicates that the CORS policy is in effect. Defaults to false.
        /// </summary>
        [Input("disabled", required: true)]
        public Input<bool> Disabled { get; set; } = null!;

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public URLMapPathMatchersPathRulesRouteActionCorsPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus", required: true)]
        public Input<int> HttpStatus { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus", required: true)]
        public Input<int> HttpStatus { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayArgs>? Delay { get; set; }

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay", required: true)]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs> FixedDelay { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay", required: true)]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs> FixedDelay { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortGetArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayGetArgs>? Delay { get; set; }

        public URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionCorsPolicyGetArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyGetArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicyGetArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<URLMapPathMatchersPathRulesRouteActionRetryPolicyGetArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<URLMapPathMatchersPathRulesRouteActionTimeoutGetArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<URLMapPathMatchersPathRulesRouteActionUrlRewriteGetArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs>());
            set => _weightedBackendServices = value;
        }

        public URLMapPathMatchersPathRulesRouteActionGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionRetryPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries")]
        public Input<int>? NumRetries { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.
        /// If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction
        /// is not set, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specfies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if the gRPC status code in
        /// the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public URLMapPathMatchersPathRulesRouteActionRetryPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionRetryPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries")]
        public Input<int>? NumRetries { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.
        /// If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction
        /// is not set, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutGetArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specfies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if the gRPC status code in
        /// the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public URLMapPathMatchersPathRulesRouteActionRetryPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionTimeoutArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionTimeoutGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionUrlRewriteArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public URLMapPathMatchersPathRulesRouteActionUrlRewriteArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionUrlRewriteGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public URLMapPathMatchersPathRulesRouteActionUrlRewriteGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionGetArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesUrlRedirectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:   -
        /// MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.  -
        /// FOUND, which corresponds to 302.  - SEE_OTHER which corresponds to 303.  -
        /// TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.  - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained. Defaults to false.
        /// </summary>
        [Input("stripQuery", required: true)]
        public Input<bool> StripQuery { get; set; } = null!;

        public URLMapPathMatchersPathRulesUrlRedirectArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersPathRulesUrlRedirectGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:   -
        /// MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.  -
        /// FOUND, which corresponds to 302.  - SEE_OTHER which corresponds to 303.  -
        /// TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.  - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained. Defaults to false.
        /// </summary>
        [Input("stripQuery", required: true)]
        public Input<bool> StripQuery { get; set; } = null!;

        public URLMapPathMatchersPathRulesUrlRedirectGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersRouteRulesHeaderActionArgs>? HeaderAction { get; set; }

        [Input("matchRules")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesArgs>? _matchRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The rules for determining a match.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesArgs> MatchRules
        {
            get => _matchRules ?? (_matchRules = new InputList<URLMapPathMatchersRouteRulesMatchRulesArgs>());
            set => _matchRules = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// For routeRules within a given pathMatcher, priority determines the order
        /// in which load balancer will interpret routeRules. RouteRules are evaluated
        /// in order of priority, from the lowest to highest number. The priority of
        /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        /// that matches the request is applied.
        /// You cannot configure two or more routeRules with the same priority.
        /// Priority for each rule must be set to a number between 0 and
        /// 2147483647 inclusive.
        /// Priority numbers can have gaps, which enable you to add or remove rules
        /// in the future without affecting the rest of the rules. For example,
        /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        /// future without any impact on existing rules.
        /// </summary>
        [Input("priority", required: true)]
        public Input<int> Priority { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching matchRule, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If  routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<URLMapPathMatchersRouteRulesRouteActionArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When this rule is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<URLMapPathMatchersRouteRulesUrlRedirectArgs>? UrlRedirect { get; set; }

        public URLMapPathMatchersRouteRulesArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersRouteRulesHeaderActionGetArgs>? HeaderAction { get; set; }

        [Input("matchRules")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesGetArgs>? _matchRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The rules for determining a match.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesGetArgs> MatchRules
        {
            get => _matchRules ?? (_matchRules = new InputList<URLMapPathMatchersRouteRulesMatchRulesGetArgs>());
            set => _matchRules = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// For routeRules within a given pathMatcher, priority determines the order
        /// in which load balancer will interpret routeRules. RouteRules are evaluated
        /// in order of priority, from the lowest to highest number. The priority of
        /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        /// that matches the request is applied.
        /// You cannot configure two or more routeRules with the same priority.
        /// Priority for each rule must be set to a number between 0 and
        /// 2147483647 inclusive.
        /// Priority numbers can have gaps, which enable you to add or remove rules
        /// in the future without affecting the rest of the rules. For example,
        /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        /// future without any impact on existing rules.
        /// </summary>
        [Input("priority", required: true)]
        public Input<int> Priority { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching matchRule, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If  routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<URLMapPathMatchersRouteRulesRouteActionGetArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When this rule is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<URLMapPathMatchersRouteRulesUrlRedirectGetArgs>? UrlRedirect { get; set; }

        public URLMapPathMatchersRouteRulesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersRouteRulesHeaderActionArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersRouteRulesHeaderActionGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// For satifying the matchRule condition, the path of the request must exactly
        /// match the value specified in fullPathMatch after removing any query parameters
        /// and anchor that may be part of the original URL. FullPathMatch must be between 1
        /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        /// be specified.
        /// </summary>
        [Input("fullPathMatch")]
        public Input<string>? FullPathMatch { get; set; }

        [Input("headerMatches")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs>? _headerMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of header match criteria, all of which must match corresponding
        /// headers in the request.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs> HeaderMatches
        {
            get => _headerMatches ?? (_headerMatches = new InputList<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs>());
            set => _headerMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        /// Defaults to false.
        /// </summary>
        [Input("ignoreCase")]
        public Input<bool>? IgnoreCase { get; set; }

        [Input("metadataFilters")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs>? _metadataFilters;

        /// <summary>
        /// -
        /// (Optional)
        /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        /// clients present node metadata. If a match takes place, the relevant routing
        /// configuration is made available to those proxies. For each metadataFilter in
        /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        /// filterLabels must match the corresponding label provided in the metadata. If its
        /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        /// with corresponding labels in the provided metadata. metadataFilters specified
        /// here can be overrides those specified in ForwardingRule that refers to this
        /// UrlMap. metadataFilters only applies to Loadbalancers that have their
        /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs> MetadataFilters
        {
            get => _metadataFilters ?? (_metadataFilters = new InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs>());
            set => _metadataFilters = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        [Input("queryParameterMatches")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs>? _queryParameterMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of query parameter match criteria, all of which must match
        /// corresponding query parameters in the request.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs> QueryParameterMatches
        {
            get => _queryParameterMatches ?? (_queryParameterMatches = new InputList<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs>());
            set => _queryParameterMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public URLMapPathMatchersRouteRulesMatchRulesArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// For satifying the matchRule condition, the path of the request must exactly
        /// match the value specified in fullPathMatch after removing any query parameters
        /// and anchor that may be part of the original URL. FullPathMatch must be between 1
        /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        /// be specified.
        /// </summary>
        [Input("fullPathMatch")]
        public Input<string>? FullPathMatch { get; set; }

        [Input("headerMatches")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs>? _headerMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of header match criteria, all of which must match corresponding
        /// headers in the request.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs> HeaderMatches
        {
            get => _headerMatches ?? (_headerMatches = new InputList<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs>());
            set => _headerMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        /// Defaults to false.
        /// </summary>
        [Input("ignoreCase")]
        public Input<bool>? IgnoreCase { get; set; }

        [Input("metadataFilters")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs>? _metadataFilters;

        /// <summary>
        /// -
        /// (Optional)
        /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        /// clients present node metadata. If a match takes place, the relevant routing
        /// configuration is made available to those proxies. For each metadataFilter in
        /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        /// filterLabels must match the corresponding label provided in the metadata. If its
        /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        /// with corresponding labels in the provided metadata. metadataFilters specified
        /// here can be overrides those specified in ForwardingRule that refers to this
        /// UrlMap. metadataFilters only applies to Loadbalancers that have their
        /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs> MetadataFilters
        {
            get => _metadataFilters ?? (_metadataFilters = new InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs>());
            set => _metadataFilters = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        [Input("queryParameterMatches")]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs>? _queryParameterMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of query parameter match criteria, all of which must match
        /// corresponding query parameters in the request.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs> QueryParameterMatches
        {
            get => _queryParameterMatches ?? (_queryParameterMatches = new InputList<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs>());
            set => _queryParameterMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public URLMapPathMatchersRouteRulesMatchRulesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// If set to false, the headerMatch is considered a match if the match criteria
        /// above are met. If set to true, the headerMatch is considered a match if the
        /// match criteria above are NOT met. Defaults to false.
        /// </summary>
        [Input("invertMatch")]
        public Input<bool>? InvertMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The header value must be an integer and its value must be in the range specified
        /// in rangeMatch. If the header does not contain an integer, number or is empty,
        /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.  Structure is documented below.
        /// </summary>
        [Input("rangeMatch")]
        public Input<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchArgs>? RangeMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must end with the contents of suffixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("suffixMatch")]
        public Input<string>? SuffixMatch { get; set; }

        public URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// If set to false, the headerMatch is considered a match if the match criteria
        /// above are met. If set to true, the headerMatch is considered a match if the
        /// match criteria above are NOT met. Defaults to false.
        /// </summary>
        [Input("invertMatch")]
        public Input<bool>? InvertMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The header value must be an integer and its value must be in the range specified
        /// in rangeMatch. If the header does not contain an integer, number or is empty,
        /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.  Structure is documented below.
        /// </summary>
        [Input("rangeMatch")]
        public Input<URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchGetArgs>? RangeMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must end with the contents of suffixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("suffixMatch")]
        public Input<string>? SuffixMatch { get; set; }

        public URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The end of the range (exclusive).
        /// </summary>
        [Input("rangeEnd", required: true)]
        public Input<int> RangeEnd { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The start of the range (inclusive).
        /// </summary>
        [Input("rangeStart", required: true)]
        public Input<int> RangeStart { get; set; } = null!;

        public URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The end of the range (exclusive).
        /// </summary>
        [Input("rangeEnd", required: true)]
        public Input<int> RangeEnd { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The start of the range (inclusive).
        /// </summary>
        [Input("rangeStart", required: true)]
        public Input<int> RangeStart { get; set; } = null!;

        public URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs : Pulumi.ResourceArgs
    {
        [Input("filterLabels", required: true)]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs>? _filterLabels;

        /// <summary>
        /// -
        /// (Required)
        /// The list of label value pairs that must match labels in the provided metadata
        /// based on filterMatchCriteria  This list must not be empty and can have at the
        /// most 64 entries.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs> FilterLabels
        {
            get => _filterLabels ?? (_filterLabels = new InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs>());
            set => _filterLabels = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies how individual filterLabel matches within the list of filterLabels
        /// contribute towards the overall metadataFilter match. Supported values are:
        /// - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        /// provided metadata.
        /// - MATCH_ALL: All filterLabels must have matching labels in
        /// the provided metadata.
        /// </summary>
        [Input("filterMatchCriteria", required: true)]
        public Input<string> FilterMatchCriteria { get; set; } = null!;

        public URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the label must match the specified value. value can have a maximum
        /// length of 1024 characters.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the label must match the specified value. value can have a maximum
        /// length of 1024 characters.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs : Pulumi.ResourceArgs
    {
        [Input("filterLabels", required: true)]
        private InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs>? _filterLabels;

        /// <summary>
        /// -
        /// (Required)
        /// The list of label value pairs that must match labels in the provided metadata
        /// based on filterMatchCriteria  This list must not be empty and can have at the
        /// most 64 entries.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs> FilterLabels
        {
            get => _filterLabels ?? (_filterLabels = new InputList<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs>());
            set => _filterLabels = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies how individual filterLabel matches within the list of filterLabels
        /// contribute towards the overall metadataFilter match. Supported values are:
        /// - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        /// provided metadata.
        /// - MATCH_ALL: All filterLabels must have matching labels in
        /// the provided metadata.
        /// </summary>
        [Input("filterMatchCriteria", required: true)]
        public Input<string> FilterMatchCriteria { get; set; } = null!;

        public URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionCorsPolicyArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionRetryPolicyArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<URLMapPathMatchersRouteRulesRouteActionTimeoutArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<URLMapPathMatchersRouteRulesRouteActionUrlRewriteArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs>());
            set => _weightedBackendServices = value;
        }

        public URLMapPathMatchersRouteRulesRouteActionArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionCorsPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// If true, specifies the CORS policy is disabled.
        /// which indicates that the CORS policy is in effect. Defaults to false.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionCorsPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionCorsPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// If true, specifies the CORS policy is disabled.
        /// which indicates that the CORS policy is in effect. Defaults to false.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionCorsPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus")]
        public Input<int>? HttpStatus { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus")]
        public Input<int>? HttpStatus { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayArgs>? Delay { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs>? FixedDelay { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs>? FixedDelay { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortGetArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayGetArgs>? Delay { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionCorsPolicyGetArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyGetArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyGetArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<URLMapPathMatchersRouteRulesRouteActionRetryPolicyGetArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<URLMapPathMatchersRouteRulesRouteActionTimeoutGetArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<URLMapPathMatchersRouteRulesRouteActionUrlRewriteGetArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs>());
            set => _weightedBackendServices = value;
        }

        public URLMapPathMatchersRouteRulesRouteActionGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionRetryPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries", required: true)]
        public Input<int> NumRetries { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.
        /// If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction
        /// is not set, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specfies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if the gRPC status code in
        /// the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public URLMapPathMatchersRouteRulesRouteActionRetryPolicyArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionRetryPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries", required: true)]
        public Input<int> NumRetries { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.
        /// If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction
        /// is not set, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutGetArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specfies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if the gRPC status code in
        /// the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public URLMapPathMatchersRouteRulesRouteActionRetryPolicyGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionTimeoutArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionTimeoutGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionUrlRewriteArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionUrlRewriteArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionUrlRewriteGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public URLMapPathMatchersRouteRulesRouteActionUrlRewriteGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionGetArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesUrlRedirectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:   -
        /// MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.  -
        /// FOUND, which corresponds to 302.  - SEE_OTHER which corresponds to 303.  -
        /// TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.  - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained. Defaults to false.
        /// </summary>
        [Input("stripQuery")]
        public Input<bool>? StripQuery { get; set; }

        public URLMapPathMatchersRouteRulesUrlRedirectArgs()
        {
        }
    }

    public sealed class URLMapPathMatchersRouteRulesUrlRedirectGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:   -
        /// MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.  -
        /// FOUND, which corresponds to 302.  - SEE_OTHER which corresponds to 303.  -
        /// TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.  - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained. Defaults to false.
        /// </summary>
        [Input("stripQuery")]
        public Input<bool>? StripQuery { get; set; }

        public URLMapPathMatchersRouteRulesUrlRedirectGetArgs()
        {
        }
    }

    public sealed class URLMapTestsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Host portion of the URL.
        /// </summary>
        [Input("host", required: true)]
        public Input<string> Host { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// Path portion of the URL.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        [Input("service", required: true)]
        public Input<string> Service { get; set; } = null!;

        public URLMapTestsArgs()
        {
        }
    }

    public sealed class URLMapTestsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Host portion of the URL.
        /// </summary>
        [Input("host", required: true)]
        public Input<string> Host { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// Path portion of the URL.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        [Input("service", required: true)]
        public Input<string> Service { get; set; } = null!;

        public URLMapTestsGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class URLMapHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private URLMapHeaderAction(
            ImmutableArray<URLMapHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<URLMapHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class URLMapHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapHostRules
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        public readonly string? Description;
        /// <summary>
        /// -
        /// (Required)
        /// The list of host patterns to match. They must be valid hostnames, except * will
        /// match any string of ([a-z0-9-.]*). In that case, * must be the first character
        /// and must be followed in the pattern by either - or ..
        /// </summary>
        public readonly ImmutableArray<string> Hosts;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of the URL if the
        /// hostRule matches the URL's host portion.
        /// </summary>
        public readonly string PathMatcher;

        [OutputConstructor]
        private URLMapHostRules(
            string? description,
            ImmutableArray<string> hosts,
            string pathMatcher)
        {
            Description = description;
            Hosts = hosts;
            PathMatcher = pathMatcher;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchers
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The backend service or backend bucket to use when none of the given paths match.
        /// </summary>
        public readonly string? DefaultService;
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        public readonly string? Description;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersHeaderAction? HeaderAction;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Optional)
        /// The list of path rules. Use this list instead of routeRules when routing based
        /// on simple path matching is all that's required. The order by which path rules
        /// are specified does not matter. Matches are always done on the longest-path-first
        /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        /// irrespective of the order in which those paths appear in this list. Within a
        /// given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersPathRules> PathRules;
        /// <summary>
        /// -
        /// (Optional)
        /// The list of ordered HTTP route rules. Use this list instead of pathRules when
        /// advanced route matching and routing actions are desired. The order of specifying
        /// routeRules matters: the first rule that matches will cause its specified routing
        /// action to take effect. Within a given pathMatcher, only one of pathRules or
        /// routeRules must be set. routeRules are not supported in UrlMaps intended for
        /// External load balancers.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRules> RouteRules;

        [OutputConstructor]
        private URLMapPathMatchers(
            string? defaultService,
            string? description,
            URLMapPathMatchersHeaderAction? headerAction,
            string name,
            ImmutableArray<URLMapPathMatchersPathRules> pathRules,
            ImmutableArray<URLMapPathMatchersRouteRules> routeRules)
        {
            DefaultService = defaultService;
            Description = description;
            HeaderAction = headerAction;
            Name = name;
            PathRules = pathRules;
            RouteRules = routeRules;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private URLMapPathMatchersHeaderAction(
            ImmutableArray<URLMapPathMatchersHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<URLMapPathMatchersHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRules
    {
        /// <summary>
        /// -
        /// (Required)
        /// The list of path patterns to match. Each must start with / and the only place a
        /// * is allowed is at the end following a /. The string fed to the path matcher
        /// does not include any text after the first ? or #, and those chars are not
        /// allowed here.
        /// </summary>
        public readonly ImmutableArray<string> Paths;
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching matchRule, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If  routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteAction? RouteAction;
        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        public readonly string? Service;
        /// <summary>
        /// -
        /// (Optional)
        /// When this rule is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesUrlRedirect? UrlRedirect;

        [OutputConstructor]
        private URLMapPathMatchersPathRules(
            ImmutableArray<string> paths,
            URLMapPathMatchersPathRulesRouteAction? routeAction,
            string? service,
            URLMapPathMatchersPathRulesUrlRedirect? urlRedirect)
        {
            Paths = paths;
            RouteAction = routeAction;
            Service = service;
            UrlRedirect = urlRedirect;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionCorsPolicy? CorsPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicy? FaultInjectionPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicy? RequestMirrorPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionRetryPolicy? RetryPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionTimeout? Timeout;
        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionUrlRewrite? UrlRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersPathRulesRouteActionWeightedBackendServices> WeightedBackendServices;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteAction(
            URLMapPathMatchersPathRulesRouteActionCorsPolicy? corsPolicy,
            URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicy? faultInjectionPolicy,
            URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicy? requestMirrorPolicy,
            URLMapPathMatchersPathRulesRouteActionRetryPolicy? retryPolicy,
            URLMapPathMatchersPathRulesRouteActionTimeout? timeout,
            URLMapPathMatchersPathRulesRouteActionUrlRewrite? urlRewrite,
            ImmutableArray<URLMapPathMatchersPathRulesRouteActionWeightedBackendServices> weightedBackendServices)
        {
            CorsPolicy = corsPolicy;
            FaultInjectionPolicy = faultInjectionPolicy;
            RequestMirrorPolicy = requestMirrorPolicy;
            RetryPolicy = retryPolicy;
            Timeout = timeout;
            UrlRewrite = urlRewrite;
            WeightedBackendServices = weightedBackendServices;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionCorsPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        public readonly bool? AllowCredentials;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> AllowHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public readonly ImmutableArray<string> AllowMethods;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOriginRegexes;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOrigins;
        /// <summary>
        /// -
        /// (Optional)
        /// If true, specifies the CORS policy is disabled.
        /// which indicates that the CORS policy is in effect. Defaults to false.
        /// </summary>
        public readonly bool Disabled;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> ExposeHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        public readonly int? MaxAge;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionCorsPolicy(
            bool? allowCredentials,
            ImmutableArray<string> allowHeaders,
            ImmutableArray<string> allowMethods,
            ImmutableArray<string> allowOriginRegexes,
            ImmutableArray<string> allowOrigins,
            bool disabled,
            ImmutableArray<string> exposeHeaders,
            int? maxAge)
        {
            AllowCredentials = allowCredentials;
            AllowHeaders = allowHeaders;
            AllowMethods = allowMethods;
            AllowOriginRegexes = allowOriginRegexes;
            AllowOrigins = allowOrigins;
            Disabled = disabled;
            ExposeHeaders = exposeHeaders;
            MaxAge = maxAge;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort? Abort;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay? Delay;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicy(
            URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort? abort,
            URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay? delay)
        {
            Abort = abort;
            Delay = delay;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        public readonly int HttpStatus;
        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double Percentage;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort(
            int httpStatus,
            double percentage)
        {
            HttpStatus = httpStatus;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay FixedDelay;
        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double Percentage;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay(
            URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay fixedDelay,
            double percentage)
        {
            FixedDelay = fixedDelay;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicy
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionRequestMirrorPolicy(string backendService)
        {
            BackendService = backendService;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionRetryPolicy
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        public readonly int? NumRetries;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.
        /// If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction
        /// is not set, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout? PerTryTimeout;
        /// <summary>
        /// -
        /// (Optional)
        /// Specfies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if the gRPC status code in
        /// the response header is set to unavailable
        /// </summary>
        public readonly ImmutableArray<string> RetryConditions;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionRetryPolicy(
            int? numRetries,
            URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout? perTryTimeout,
            ImmutableArray<string> retryConditions)
        {
            NumRetries = numRetries;
            PerTryTimeout = perTryTimeout;
            RetryConditions = retryConditions;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionUrlRewrite
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        public readonly string? HostRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathPrefixRewrite;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionUrlRewrite(
            string? hostRewrite,
            string? pathPrefixRewrite)
        {
            HostRewrite = hostRewrite;
            PathPrefixRewrite = pathPrefixRewrite;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServices
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction? HeaderAction;
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        public readonly int Weight;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionWeightedBackendServices(
            string backendService,
            URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction? headerAction,
            int weight)
        {
            BackendService = backendService;
            HeaderAction = headerAction;
            Weight = weight;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction(
            ImmutableArray<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersPathRulesUrlRedirect
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        public readonly string? HostRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        public readonly bool? HttpsRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        public readonly string? PrefixRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:   -
        /// MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.  -
        /// FOUND, which corresponds to 302.  - SEE_OTHER which corresponds to 303.  -
        /// TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.  - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        public readonly string? RedirectResponseCode;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained. Defaults to false.
        /// </summary>
        public readonly bool StripQuery;

        [OutputConstructor]
        private URLMapPathMatchersPathRulesUrlRedirect(
            string? hostRedirect,
            bool? httpsRedirect,
            string? pathRedirect,
            string? prefixRedirect,
            string? redirectResponseCode,
            bool stripQuery)
        {
            HostRedirect = hostRedirect;
            HttpsRedirect = httpsRedirect;
            PathRedirect = pathRedirect;
            PrefixRedirect = prefixRedirect;
            RedirectResponseCode = redirectResponseCode;
            StripQuery = stripQuery;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRules
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesHeaderAction? HeaderAction;
        /// <summary>
        /// -
        /// (Optional)
        /// The rules for determining a match.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesMatchRules> MatchRules;
        /// <summary>
        /// -
        /// (Required)
        /// For routeRules within a given pathMatcher, priority determines the order
        /// in which load balancer will interpret routeRules. RouteRules are evaluated
        /// in order of priority, from the lowest to highest number. The priority of
        /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        /// that matches the request is applied.
        /// You cannot configure two or more routeRules with the same priority.
        /// Priority for each rule must be set to a number between 0 and
        /// 2147483647 inclusive.
        /// Priority numbers can have gaps, which enable you to add or remove rules
        /// in the future without affecting the rest of the rules. For example,
        /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        /// future without any impact on existing rules.
        /// </summary>
        public readonly int Priority;
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching matchRule, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If  routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteAction? RouteAction;
        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        public readonly string? Service;
        /// <summary>
        /// -
        /// (Optional)
        /// When this rule is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesUrlRedirect? UrlRedirect;

        [OutputConstructor]
        private URLMapPathMatchersRouteRules(
            URLMapPathMatchersRouteRulesHeaderAction? headerAction,
            ImmutableArray<URLMapPathMatchersRouteRulesMatchRules> matchRules,
            int priority,
            URLMapPathMatchersRouteRulesRouteAction? routeAction,
            string? service,
            URLMapPathMatchersRouteRulesUrlRedirect? urlRedirect)
        {
            HeaderAction = headerAction;
            MatchRules = matchRules;
            Priority = priority;
            RouteAction = routeAction;
            Service = service;
            UrlRedirect = urlRedirect;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesHeaderAction(
            ImmutableArray<URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesMatchRules
    {
        /// <summary>
        /// -
        /// (Optional)
        /// For satifying the matchRule condition, the path of the request must exactly
        /// match the value specified in fullPathMatch after removing any query parameters
        /// and anchor that may be part of the original URL. FullPathMatch must be between 1
        /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        /// be specified.
        /// </summary>
        public readonly string? FullPathMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of header match criteria, all of which must match corresponding
        /// headers in the request.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesHeaderMatches> HeaderMatches;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        /// Defaults to false.
        /// </summary>
        public readonly bool? IgnoreCase;
        /// <summary>
        /// -
        /// (Optional)
        /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        /// clients present node metadata. If a match takes place, the relevant routing
        /// configuration is made available to those proxies. For each metadataFilter in
        /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        /// filterLabels must match the corresponding label provided in the metadata. If its
        /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        /// with corresponding labels in the provided metadata. metadataFilters specified
        /// here can be overrides those specified in ForwardingRule that refers to this
        /// UrlMap. metadataFilters only applies to Loadbalancers that have their
        /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesMetadataFilters> MetadataFilters;
        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        public readonly string? PrefixMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of query parameter match criteria, all of which must match
        /// corresponding query parameters in the request.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatches> QueryParameterMatches;
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        public readonly string? RegexMatch;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesMatchRules(
            string? fullPathMatch,
            ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesHeaderMatches> headerMatches,
            bool? ignoreCase,
            ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesMetadataFilters> metadataFilters,
            string? prefixMatch,
            ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatches> queryParameterMatches,
            string? regexMatch)
        {
            FullPathMatch = fullPathMatch;
            HeaderMatches = headerMatches;
            IgnoreCase = ignoreCase;
            MetadataFilters = metadataFilters;
            PrefixMatch = prefixMatch;
            QueryParameterMatches = queryParameterMatches;
            RegexMatch = regexMatch;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesMatchRulesHeaderMatches
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        public readonly string? ExactMatch;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to false, the headerMatch is considered a match if the match criteria
        /// above are met. If set to true, the headerMatch is considered a match if the
        /// match criteria above are NOT met. Defaults to false.
        /// </summary>
        public readonly bool? InvertMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        public readonly string? PrefixMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        public readonly bool? PresentMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The header value must be an integer and its value must be in the range specified
        /// in rangeMatch. If the header does not contain an integer, number or is empty,
        /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch? RangeMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        public readonly string? RegexMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must end with the contents of suffixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        public readonly string? SuffixMatch;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesMatchRulesHeaderMatches(
            string? exactMatch,
            string headerName,
            bool? invertMatch,
            string? prefixMatch,
            bool? presentMatch,
            URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch? rangeMatch,
            string? regexMatch,
            string? suffixMatch)
        {
            ExactMatch = exactMatch;
            HeaderName = headerName;
            InvertMatch = invertMatch;
            PrefixMatch = prefixMatch;
            PresentMatch = presentMatch;
            RangeMatch = rangeMatch;
            RegexMatch = regexMatch;
            SuffixMatch = suffixMatch;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch
    {
        /// <summary>
        /// -
        /// (Required)
        /// The end of the range (exclusive).
        /// </summary>
        public readonly int RangeEnd;
        /// <summary>
        /// -
        /// (Required)
        /// The start of the range (inclusive).
        /// </summary>
        public readonly int RangeStart;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch(
            int rangeEnd,
            int rangeStart)
        {
            RangeEnd = rangeEnd;
            RangeStart = rangeStart;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesMatchRulesMetadataFilters
    {
        /// <summary>
        /// -
        /// (Required)
        /// The list of label value pairs that must match labels in the provided metadata
        /// based on filterMatchCriteria  This list must not be empty and can have at the
        /// most 64 entries.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels> FilterLabels;
        /// <summary>
        /// -
        /// (Required)
        /// Specifies how individual filterLabel matches within the list of filterLabels
        /// contribute towards the overall metadataFilter match. Supported values are:
        /// - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        /// provided metadata.
        /// - MATCH_ALL: All filterLabels must have matching labels in
        /// the provided metadata.
        /// </summary>
        public readonly string FilterMatchCriteria;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesMatchRulesMetadataFilters(
            ImmutableArray<URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels> filterLabels,
            string filterMatchCriteria)
        {
            FilterLabels = filterLabels;
            FilterMatchCriteria = filterMatchCriteria;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the label must match the specified value. value can have a maximum
        /// length of 1024 characters.
        /// </summary>
        public readonly string Value;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels(
            string name,
            string value)
        {
            Name = name;
            Value = value;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatches
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        public readonly string? ExactMatch;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        public readonly bool? PresentMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        public readonly string? RegexMatch;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesMatchRulesQueryParameterMatches(
            string? exactMatch,
            string name,
            bool? presentMatch,
            string? regexMatch)
        {
            ExactMatch = exactMatch;
            Name = name;
            PresentMatch = presentMatch;
            RegexMatch = regexMatch;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionCorsPolicy? CorsPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy? FaultInjectionPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy? RequestMirrorPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionRetryPolicy? RetryPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionTimeout? Timeout;
        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionUrlRewrite? UrlRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServices> WeightedBackendServices;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteAction(
            URLMapPathMatchersRouteRulesRouteActionCorsPolicy? corsPolicy,
            URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy? faultInjectionPolicy,
            URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy? requestMirrorPolicy,
            URLMapPathMatchersRouteRulesRouteActionRetryPolicy? retryPolicy,
            URLMapPathMatchersRouteRulesRouteActionTimeout? timeout,
            URLMapPathMatchersRouteRulesRouteActionUrlRewrite? urlRewrite,
            ImmutableArray<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServices> weightedBackendServices)
        {
            CorsPolicy = corsPolicy;
            FaultInjectionPolicy = faultInjectionPolicy;
            RequestMirrorPolicy = requestMirrorPolicy;
            RetryPolicy = retryPolicy;
            Timeout = timeout;
            UrlRewrite = urlRewrite;
            WeightedBackendServices = weightedBackendServices;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionCorsPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        public readonly bool? AllowCredentials;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> AllowHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public readonly ImmutableArray<string> AllowMethods;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOriginRegexes;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOrigins;
        /// <summary>
        /// -
        /// (Optional)
        /// If true, specifies the CORS policy is disabled.
        /// which indicates that the CORS policy is in effect. Defaults to false.
        /// </summary>
        public readonly bool? Disabled;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> ExposeHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        public readonly int? MaxAge;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionCorsPolicy(
            bool? allowCredentials,
            ImmutableArray<string> allowHeaders,
            ImmutableArray<string> allowMethods,
            ImmutableArray<string> allowOriginRegexes,
            ImmutableArray<string> allowOrigins,
            bool? disabled,
            ImmutableArray<string> exposeHeaders,
            int? maxAge)
        {
            AllowCredentials = allowCredentials;
            AllowHeaders = allowHeaders;
            AllowMethods = allowMethods;
            AllowOriginRegexes = allowOriginRegexes;
            AllowOrigins = allowOrigins;
            Disabled = disabled;
            ExposeHeaders = exposeHeaders;
            MaxAge = maxAge;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort? Abort;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay? Delay;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy(
            URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort? abort,
            URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay? delay)
        {
            Abort = abort;
            Delay = delay;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        public readonly int? HttpStatus;
        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double? Percentage;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort(
            int? httpStatus,
            double? percentage)
        {
            HttpStatus = httpStatus;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay? FixedDelay;
        /// <summary>
        /// -
        /// (Optional)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double? Percentage;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay(
            URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay? fixedDelay,
            double? percentage)
        {
            FixedDelay = fixedDelay;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy(string backendService)
        {
            BackendService = backendService;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionRetryPolicy
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        public readonly int NumRetries;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.
        /// If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction
        /// is not set, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout? PerTryTimeout;
        /// <summary>
        /// -
        /// (Optional)
        /// Specfies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if the gRPC status code in
        /// the response header is set to unavailable
        /// </summary>
        public readonly ImmutableArray<string> RetryConditions;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionRetryPolicy(
            int numRetries,
            URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout? perTryTimeout,
            ImmutableArray<string> retryConditions)
        {
            NumRetries = numRetries;
            PerTryTimeout = perTryTimeout;
            RetryConditions = retryConditions;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionUrlRewrite
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        public readonly string? HostRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathPrefixRewrite;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionUrlRewrite(
            string? hostRewrite,
            string? pathPrefixRewrite)
        {
            HostRewrite = hostRewrite;
            PathPrefixRewrite = pathPrefixRewrite;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServices
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default BackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        public readonly URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction? HeaderAction;
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        public readonly int Weight;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionWeightedBackendServices(
            string backendService,
            URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction? headerAction,
            int weight)
        {
            BackendService = backendService;
            HeaderAction = headerAction;
            Weight = weight;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction(
            ImmutableArray<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class URLMapPathMatchersRouteRulesUrlRedirect
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        public readonly string? HostRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        public readonly bool? HttpsRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        public readonly string? PrefixRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:   -
        /// MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.  -
        /// FOUND, which corresponds to 302.  - SEE_OTHER which corresponds to 303.  -
        /// TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.  - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        public readonly string? RedirectResponseCode;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained. Defaults to false.
        /// </summary>
        public readonly bool? StripQuery;

        [OutputConstructor]
        private URLMapPathMatchersRouteRulesUrlRedirect(
            string? hostRedirect,
            bool? httpsRedirect,
            string? pathRedirect,
            string? prefixRedirect,
            string? redirectResponseCode,
            bool? stripQuery)
        {
            HostRedirect = hostRedirect;
            HttpsRedirect = httpsRedirect;
            PathRedirect = pathRedirect;
            PrefixRedirect = prefixRedirect;
            RedirectResponseCode = redirectResponseCode;
            StripQuery = stripQuery;
        }
    }

    [OutputType]
    public sealed class URLMapTests
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        public readonly string? Description;
        /// <summary>
        /// -
        /// (Required)
        /// Host portion of the URL.
        /// </summary>
        public readonly string Host;
        /// <summary>
        /// -
        /// (Required)
        /// Path portion of the URL.
        /// </summary>
        public readonly string Path;
        /// <summary>
        /// -
        /// (Required)
        /// The backend service or backend bucket link that should be matched by this test.
        /// </summary>
        public readonly string Service;

        [OutputConstructor]
        private URLMapTests(
            string? description,
            string host,
            string path,
            string service)
        {
            Description = description;
            Host = host;
            Path = path;
            Service = service;
        }
    }
    }
}
