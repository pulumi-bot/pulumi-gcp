// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Compute
{
    /// <summary>
    /// UrlMaps are used to route requests to a backend service based on rules
    /// that you define for the host and path of an incoming URL.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-google/blob/master/website/docs/r/compute_region_url_map.html.markdown.
    /// </summary>
    public partial class RegionUrlMap : Pulumi.CustomResource
    {
        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Output("creationTimestamp")]
        public Output<string> CreationTimestamp { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// A reference to a RegionBackendService resource. This will be used if
        /// none of the pathRules defined by this PathMatcher is matched by
        /// the URL's path portion.
        /// </summary>
        [Output("defaultService")]
        public Output<string> DefaultService { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Fingerprint of this resource. This field is used internally during updates of this resource.
        /// </summary>
        [Output("fingerprint")]
        public Output<string> Fingerprint { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of HostRules to use against the URL.  Structure is documented below.
        /// </summary>
        [Output("hostRules")]
        public Output<ImmutableArray<Outputs.RegionUrlMapHostRules>> HostRules { get; private set; } = null!;

        /// <summary>
        /// The unique identifier for the resource.
        /// </summary>
        [Output("mapId")]
        public Output<int> MapId { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of
        /// the URL if the hostRule matches the URL's host portion.
        /// </summary>
        [Output("pathMatchers")]
        public Output<ImmutableArray<Outputs.RegionUrlMapPathMatchers>> PathMatchers { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The Region in which the url map should reside.
        /// If it is not provided, the provider region is used.
        /// </summary>
        [Output("region")]
        public Output<string> Region { get; private set; } = null!;

        /// <summary>
        /// The URI of the created resource.
        /// </summary>
        [Output("selfLink")]
        public Output<string> SelfLink { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of expected URL mappings. Requests to update this UrlMap will
        /// succeed only if all of the test cases pass.  Structure is documented below.
        /// </summary>
        [Output("tests")]
        public Output<ImmutableArray<Outputs.RegionUrlMapTests>> Tests { get; private set; } = null!;


        /// <summary>
        /// Create a RegionUrlMap resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public RegionUrlMap(string name, RegionUrlMapArgs args, CustomResourceOptions? options = null)
            : base("gcp:compute/regionUrlMap:RegionUrlMap", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private RegionUrlMap(string name, Input<string> id, RegionUrlMapState? state = null, CustomResourceOptions? options = null)
            : base("gcp:compute/regionUrlMap:RegionUrlMap", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing RegionUrlMap resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static RegionUrlMap Get(string name, Input<string> id, RegionUrlMapState? state = null, CustomResourceOptions? options = null)
        {
            return new RegionUrlMap(name, id, state, options);
        }
    }

    public sealed class RegionUrlMapArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// A reference to a RegionBackendService resource. This will be used if
        /// none of the pathRules defined by this PathMatcher is matched by
        /// the URL's path portion.
        /// </summary>
        [Input("defaultService", required: true)]
        public Input<string> DefaultService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("hostRules")]
        private InputList<Inputs.RegionUrlMapHostRulesArgs>? _hostRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of HostRules to use against the URL.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.RegionUrlMapHostRulesArgs> HostRules
        {
            get => _hostRules ?? (_hostRules = new InputList<Inputs.RegionUrlMapHostRulesArgs>());
            set => _hostRules = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("pathMatchers")]
        private InputList<Inputs.RegionUrlMapPathMatchersArgs>? _pathMatchers;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of
        /// the URL if the hostRule matches the URL's host portion.
        /// </summary>
        public InputList<Inputs.RegionUrlMapPathMatchersArgs> PathMatchers
        {
            get => _pathMatchers ?? (_pathMatchers = new InputList<Inputs.RegionUrlMapPathMatchersArgs>());
            set => _pathMatchers = value;
        }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The Region in which the url map should reside.
        /// If it is not provided, the provider region is used.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        [Input("tests")]
        private InputList<Inputs.RegionUrlMapTestsArgs>? _tests;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of expected URL mappings. Requests to update this UrlMap will
        /// succeed only if all of the test cases pass.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.RegionUrlMapTestsArgs> Tests
        {
            get => _tests ?? (_tests = new InputList<Inputs.RegionUrlMapTestsArgs>());
            set => _tests = value;
        }

        public RegionUrlMapArgs()
        {
        }
    }

    public sealed class RegionUrlMapState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Input("creationTimestamp")]
        public Input<string>? CreationTimestamp { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// A reference to a RegionBackendService resource. This will be used if
        /// none of the pathRules defined by this PathMatcher is matched by
        /// the URL's path portion.
        /// </summary>
        [Input("defaultService")]
        public Input<string>? DefaultService { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Fingerprint of this resource. This field is used internally during updates of this resource.
        /// </summary>
        [Input("fingerprint")]
        public Input<string>? Fingerprint { get; set; }

        [Input("hostRules")]
        private InputList<Inputs.RegionUrlMapHostRulesGetArgs>? _hostRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of HostRules to use against the URL.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.RegionUrlMapHostRulesGetArgs> HostRules
        {
            get => _hostRules ?? (_hostRules = new InputList<Inputs.RegionUrlMapHostRulesGetArgs>());
            set => _hostRules = value;
        }

        /// <summary>
        /// The unique identifier for the resource.
        /// </summary>
        [Input("mapId")]
        public Input<int>? MapId { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("pathMatchers")]
        private InputList<Inputs.RegionUrlMapPathMatchersGetArgs>? _pathMatchers;

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of
        /// the URL if the hostRule matches the URL's host portion.
        /// </summary>
        public InputList<Inputs.RegionUrlMapPathMatchersGetArgs> PathMatchers
        {
            get => _pathMatchers ?? (_pathMatchers = new InputList<Inputs.RegionUrlMapPathMatchersGetArgs>());
            set => _pathMatchers = value;
        }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The Region in which the url map should reside.
        /// If it is not provided, the provider region is used.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// The URI of the created resource.
        /// </summary>
        [Input("selfLink")]
        public Input<string>? SelfLink { get; set; }

        [Input("tests")]
        private InputList<Inputs.RegionUrlMapTestsGetArgs>? _tests;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of expected URL mappings. Requests to update this UrlMap will
        /// succeed only if all of the test cases pass.  Structure is documented below.
        /// </summary>
        public InputList<Inputs.RegionUrlMapTestsGetArgs> Tests
        {
            get => _tests ?? (_tests = new InputList<Inputs.RegionUrlMapTestsGetArgs>());
            set => _tests = value;
        }

        public RegionUrlMapState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class RegionUrlMapHostRulesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("hosts", required: true)]
        private InputList<string>? _hosts;

        /// <summary>
        /// -
        /// (Required)
        /// The list of host patterns to match. They must be valid
        /// hostnames, except * will match any string of ([a-z0-9-.]*). In
        /// that case, * must be the first character and must be followed in
        /// the pattern by either - or ..
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of
        /// the URL if the hostRule matches the URL's host portion.
        /// </summary>
        [Input("pathMatcher", required: true)]
        public Input<string> PathMatcher { get; set; } = null!;

        public RegionUrlMapHostRulesArgs()
        {
        }
    }

    public sealed class RegionUrlMapHostRulesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("hosts", required: true)]
        private InputList<string>? _hosts;

        /// <summary>
        /// -
        /// (Required)
        /// The list of host patterns to match. They must be valid
        /// hostnames, except * will match any string of ([a-z0-9-.]*). In
        /// that case, * must be the first character and must be followed in
        /// the pattern by either - or ..
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of
        /// the URL if the hostRule matches the URL's host portion.
        /// </summary>
        [Input("pathMatcher", required: true)]
        public Input<string> PathMatcher { get; set; } = null!;

        public RegionUrlMapHostRulesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// A reference to a RegionBackendService resource. This will be used if
        /// none of the pathRules defined by this PathMatcher is matched by
        /// the URL's path portion.
        /// </summary>
        [Input("defaultService", required: true)]
        public Input<string> DefaultService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("pathRules")]
        private InputList<RegionUrlMapPathMatchersPathRulesArgs>? _pathRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of path rules. Use this list instead of routeRules when routing based
        /// on simple path matching is all that's required. The order by which path rules
        /// are specified does not matter. Matches are always done on the longest-path-first
        /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        /// irrespective of the order in which those paths appear in this list. Within a
        /// given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesArgs> PathRules
        {
            get => _pathRules ?? (_pathRules = new InputList<RegionUrlMapPathMatchersPathRulesArgs>());
            set => _pathRules = value;
        }

        [Input("routeRules")]
        private InputList<RegionUrlMapPathMatchersRouteRulesArgs>? _routeRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of ordered HTTP route rules. Use this list instead of pathRules when
        /// advanced route matching and routing actions are desired. The order of specifying
        /// routeRules matters: the first rule that matches will cause its specified routing
        /// action to take effect. Within a given pathMatcher, only one of pathRules or
        /// routeRules must be set. routeRules are not supported in UrlMaps intended for
        /// External load balancers.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesArgs> RouteRules
        {
            get => _routeRules ?? (_routeRules = new InputList<RegionUrlMapPathMatchersRouteRulesArgs>());
            set => _routeRules = value;
        }

        public RegionUrlMapPathMatchersArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// A reference to a RegionBackendService resource. This will be used if
        /// none of the pathRules defined by this PathMatcher is matched by
        /// the URL's path portion.
        /// </summary>
        [Input("defaultService", required: true)]
        public Input<string> DefaultService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("pathRules")]
        private InputList<RegionUrlMapPathMatchersPathRulesGetArgs>? _pathRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of path rules. Use this list instead of routeRules when routing based
        /// on simple path matching is all that's required. The order by which path rules
        /// are specified does not matter. Matches are always done on the longest-path-first
        /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        /// irrespective of the order in which those paths appear in this list. Within a
        /// given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesGetArgs> PathRules
        {
            get => _pathRules ?? (_pathRules = new InputList<RegionUrlMapPathMatchersPathRulesGetArgs>());
            set => _pathRules = value;
        }

        [Input("routeRules")]
        private InputList<RegionUrlMapPathMatchersRouteRulesGetArgs>? _routeRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The list of ordered HTTP route rules. Use this list instead of pathRules when
        /// advanced route matching and routing actions are desired. The order of specifying
        /// routeRules matters: the first rule that matches will cause its specified routing
        /// action to take effect. Within a given pathMatcher, only one of pathRules or
        /// routeRules must be set. routeRules are not supported in UrlMaps intended for
        /// External load balancers.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesGetArgs> RouteRules
        {
            get => _routeRules ?? (_routeRules = new InputList<RegionUrlMapPathMatchersRouteRulesGetArgs>());
            set => _routeRules = value;
        }

        public RegionUrlMapPathMatchersGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesArgs : Pulumi.ResourceArgs
    {
        [Input("paths", required: true)]
        private InputList<string>? _paths;

        /// <summary>
        /// -
        /// (Required)
        /// The list of path patterns to match. Each must start with / and the only place a
        /// * is allowed is at the end following a /. The string fed to the path matcher
        /// does not include any text after the first ? or #, and those chars are not
        /// allowed here.
        /// </summary>
        public InputList<string> Paths
        {
            get => _paths ?? (_paths = new InputList<string>());
            set => _paths = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching path, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When a path pattern is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<RegionUrlMapPathMatchersPathRulesUrlRedirectArgs>? UrlRedirect { get; set; }

        public RegionUrlMapPathMatchersPathRulesArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesGetArgs : Pulumi.ResourceArgs
    {
        [Input("paths", required: true)]
        private InputList<string>? _paths;

        /// <summary>
        /// -
        /// (Required)
        /// The list of path patterns to match. Each must start with / and the only place a
        /// * is allowed is at the end following a /. The string fed to the path matcher
        /// does not include any text after the first ? or #, and those chars are not
        /// allowed here.
        /// </summary>
        public InputList<string> Paths
        {
            get => _paths ?? (_paths = new InputList<string>());
            set => _paths = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching path, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionGetArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When a path pattern is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<RegionUrlMapPathMatchersPathRulesUrlRedirectGetArgs>? UrlRedirect { get; set; }

        public RegionUrlMapPathMatchersPathRulesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicyArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicyArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionTimeoutArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionUrlRewriteArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs>());
            set => _weightedBackendServices = value;
        }

        public RegionUrlMapPathMatchersPathRulesRouteActionArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// If true, specifies the CORS policy is disabled.
        /// </summary>
        [Input("disabled", required: true)]
        public Input<bool> Disabled { get; set; } = null!;

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// If true, specifies the CORS policy is disabled.
        /// </summary>
        [Input("disabled", required: true)]
        public Input<bool> Disabled { get; set; } = null!;

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus", required: true)]
        public Input<int> HttpStatus { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus", required: true)]
        public Input<int> HttpStatus { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayArgs>? Delay { get; set; }

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay", required: true)]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs> FixedDelay { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay", required: true)]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs> FixedDelay { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage", required: true)]
        public Input<double> Percentage { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbortGetArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayGetArgs>? Delay { get; set; }

        public RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicyGetArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyGetArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicyGetArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyGetArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionTimeoutGetArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionUrlRewriteGetArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs>());
            set => _weightedBackendServices = value;
        }

        public RegionUrlMapPathMatchersPathRulesRouteActionGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries")]
        public Input<int>? NumRetries { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if
        /// the gRPC status code in the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries")]
        public Input<int>? NumRetries { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutGetArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if
        /// the gRPC status code in the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeoutGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionTimeoutArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionTimeoutGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionUrlRewriteArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public RegionUrlMapPathMatchersPathRulesRouteActionUrlRewriteArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionUrlRewriteGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public RegionUrlMapPathMatchersPathRulesRouteActionUrlRewriteGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionGetArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesUrlRedirectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:
        /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        /// - FOUND, which corresponds to 302.
        /// - SEE_OTHER which corresponds to 303.
        /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.
        /// - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained.
        /// </summary>
        [Input("stripQuery", required: true)]
        public Input<bool> StripQuery { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesUrlRedirectArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersPathRulesUrlRedirectGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:
        /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        /// - FOUND, which corresponds to 302.
        /// - SEE_OTHER which corresponds to 303.
        /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.
        /// - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained.
        /// </summary>
        [Input("stripQuery", required: true)]
        public Input<bool> StripQuery { get; set; } = null!;

        public RegionUrlMapPathMatchersPathRulesUrlRedirectGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<RegionUrlMapPathMatchersRouteRulesHeaderActionArgs>? HeaderAction { get; set; }

        [Input("matchRules")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesArgs>? _matchRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The rules for determining a match.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesArgs> MatchRules
        {
            get => _matchRules ?? (_matchRules = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesArgs>());
            set => _matchRules = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// For routeRules within a given pathMatcher, priority determines the order
        /// in which load balancer will interpret routeRules. RouteRules are evaluated
        /// in order of priority, from the lowest to highest number. The priority of
        /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        /// that matches the request is applied.
        /// You cannot configure two or more routeRules with the same priority.
        /// Priority for each rule must be set to a number between 0 and
        /// 2147483647 inclusive.
        /// Priority numbers can have gaps, which enable you to add or remove rules
        /// in the future without affecting the rest of the rules. For example,
        /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        /// future without any impact on existing rules.
        /// </summary>
        [Input("priority", required: true)]
        public Input<int> Priority { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching path, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When a path pattern is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<RegionUrlMapPathMatchersRouteRulesUrlRedirectArgs>? UrlRedirect { get; set; }

        public RegionUrlMapPathMatchersRouteRulesArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<RegionUrlMapPathMatchersRouteRulesHeaderActionGetArgs>? HeaderAction { get; set; }

        [Input("matchRules")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesGetArgs>? _matchRules;

        /// <summary>
        /// -
        /// (Optional)
        /// The rules for determining a match.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesGetArgs> MatchRules
        {
            get => _matchRules ?? (_matchRules = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesGetArgs>());
            set => _matchRules = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// For routeRules within a given pathMatcher, priority determines the order
        /// in which load balancer will interpret routeRules. RouteRules are evaluated
        /// in order of priority, from the lowest to highest number. The priority of
        /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        /// that matches the request is applied.
        /// You cannot configure two or more routeRules with the same priority.
        /// Priority for each rule must be set to a number between 0 and
        /// 2147483647 inclusive.
        /// Priority numbers can have gaps, which enable you to add or remove rules
        /// in the future without affecting the rest of the rules. For example,
        /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        /// future without any impact on existing rules.
        /// </summary>
        [Input("priority", required: true)]
        public Input<int> Priority { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching path, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        [Input("routeAction")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionGetArgs>? RouteAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        [Input("service")]
        public Input<string>? Service { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// When a path pattern is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        [Input("urlRedirect")]
        public Input<RegionUrlMapPathMatchersRouteRulesUrlRedirectGetArgs>? UrlRedirect { get; set; }

        public RegionUrlMapPathMatchersRouteRulesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public RegionUrlMapPathMatchersRouteRulesHeaderActionArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public RegionUrlMapPathMatchersRouteRulesHeaderActionGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// For satifying the matchRule condition, the path of the request must exactly
        /// match the value specified in fullPathMatch after removing any query parameters
        /// and anchor that may be part of the original URL. FullPathMatch must be between 1
        /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        /// be specified.
        /// </summary>
        [Input("fullPathMatch")]
        public Input<string>? FullPathMatch { get; set; }

        [Input("headerMatches")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs>? _headerMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of header match criteria, all of which must match corresponding
        /// headers in the request.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs> HeaderMatches
        {
            get => _headerMatches ?? (_headerMatches = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs>());
            set => _headerMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        /// Defaults to false.
        /// </summary>
        [Input("ignoreCase")]
        public Input<bool>? IgnoreCase { get; set; }

        [Input("metadataFilters")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs>? _metadataFilters;

        /// <summary>
        /// -
        /// (Optional)
        /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        /// clients present node metadata. If a match takes place, the relevant routing
        /// configuration is made available to those proxies. For each metadataFilter in
        /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        /// filterLabels must match the corresponding label provided in the metadata. If its
        /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        /// with corresponding labels in the provided metadata. metadataFilters specified
        /// here can be overrides those specified in ForwardingRule that refers to this
        /// UrlMap. metadataFilters only applies to Loadbalancers that have their
        /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs> MetadataFilters
        {
            get => _metadataFilters ?? (_metadataFilters = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs>());
            set => _metadataFilters = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        [Input("queryParameterMatches")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs>? _queryParameterMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of query parameter match criteria, all of which must match
        /// corresponding query parameters in the request.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs> QueryParameterMatches
        {
            get => _queryParameterMatches ?? (_queryParameterMatches = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs>());
            set => _queryParameterMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public RegionUrlMapPathMatchersRouteRulesMatchRulesArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// For satifying the matchRule condition, the path of the request must exactly
        /// match the value specified in fullPathMatch after removing any query parameters
        /// and anchor that may be part of the original URL. FullPathMatch must be between 1
        /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        /// be specified.
        /// </summary>
        [Input("fullPathMatch")]
        public Input<string>? FullPathMatch { get; set; }

        [Input("headerMatches")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs>? _headerMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of header match criteria, all of which must match corresponding
        /// headers in the request.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs> HeaderMatches
        {
            get => _headerMatches ?? (_headerMatches = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs>());
            set => _headerMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        /// Defaults to false.
        /// </summary>
        [Input("ignoreCase")]
        public Input<bool>? IgnoreCase { get; set; }

        [Input("metadataFilters")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs>? _metadataFilters;

        /// <summary>
        /// -
        /// (Optional)
        /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        /// clients present node metadata. If a match takes place, the relevant routing
        /// configuration is made available to those proxies. For each metadataFilter in
        /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        /// filterLabels must match the corresponding label provided in the metadata. If its
        /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        /// with corresponding labels in the provided metadata. metadataFilters specified
        /// here can be overrides those specified in ForwardingRule that refers to this
        /// UrlMap. metadataFilters only applies to Loadbalancers that have their
        /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs> MetadataFilters
        {
            get => _metadataFilters ?? (_metadataFilters = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs>());
            set => _metadataFilters = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        [Input("queryParameterMatches")]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs>? _queryParameterMatches;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of query parameter match criteria, all of which must match
        /// corresponding query parameters in the request.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs> QueryParameterMatches
        {
            get => _queryParameterMatches ?? (_queryParameterMatches = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs>());
            set => _queryParameterMatches = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public RegionUrlMapPathMatchersRouteRulesMatchRulesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// If set to false, the headerMatch is considered a match if the match criteria
        /// above are met. If set to true, the headerMatch is considered a match if the
        /// match criteria above are NOT met. Defaults to false.
        /// </summary>
        [Input("invertMatch")]
        public Input<bool>? InvertMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The header value must be an integer and its value must be in the range specified
        /// in rangeMatch. If the header does not contain an integer, number or is empty,
        /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.  Structure is documented below.
        /// </summary>
        [Input("rangeMatch")]
        public Input<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchArgs>? RangeMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must end with the contents of suffixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("suffixMatch")]
        public Input<string>? SuffixMatch { get; set; }

        public RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// If set to false, the headerMatch is considered a match if the match criteria
        /// above are met. If set to true, the headerMatch is considered a match if the
        /// match criteria above are NOT met. Defaults to false.
        /// </summary>
        [Input("invertMatch")]
        public Input<bool>? InvertMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("prefixMatch")]
        public Input<string>? PrefixMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The header value must be an integer and its value must be in the range specified
        /// in rangeMatch. If the header does not contain an integer, number or is empty,
        /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.  Structure is documented below.
        /// </summary>
        [Input("rangeMatch")]
        public Input<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchGetArgs>? RangeMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must end with the contents of suffixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        [Input("suffixMatch")]
        public Input<string>? SuffixMatch { get; set; }

        public RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The end of the range (exclusive).
        /// </summary>
        [Input("rangeEnd", required: true)]
        public Input<int> RangeEnd { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The start of the range (inclusive).
        /// </summary>
        [Input("rangeStart", required: true)]
        public Input<int> RangeStart { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The end of the range (exclusive).
        /// </summary>
        [Input("rangeEnd", required: true)]
        public Input<int> RangeEnd { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The start of the range (inclusive).
        /// </summary>
        [Input("rangeStart", required: true)]
        public Input<int> RangeStart { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatchGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs : Pulumi.ResourceArgs
    {
        [Input("filterLabels", required: true)]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs>? _filterLabels;

        /// <summary>
        /// -
        /// (Required)
        /// The list of label value pairs that must match labels in the provided metadata
        /// based on filterMatchCriteria  This list must not be empty and can have at the
        /// most 64 entries.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs> FilterLabels
        {
            get => _filterLabels ?? (_filterLabels = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs>());
            set => _filterLabels = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies how individual filterLabel matches within the list of filterLabels
        /// contribute towards the overall metadataFilter match. Supported values are:
        /// - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        /// provided metadata.
        /// - MATCH_ALL: All filterLabels must have matching labels in
        /// the provided metadata.
        /// </summary>
        [Input("filterMatchCriteria", required: true)]
        public Input<string> FilterMatchCriteria { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the label must match the specified value. value can have a maximum
        /// length of 1024 characters.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the label must match the specified value. value can have a maximum
        /// length of 1024 characters.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs : Pulumi.ResourceArgs
    {
        [Input("filterLabels", required: true)]
        private InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs>? _filterLabels;

        /// <summary>
        /// -
        /// (Required)
        /// The list of label value pairs that must match labels in the provided metadata
        /// based on filterMatchCriteria  This list must not be empty and can have at the
        /// most 64 entries.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs> FilterLabels
        {
            get => _filterLabels ?? (_filterLabels = new InputList<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabelsGetArgs>());
            set => _filterLabels = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies how individual filterLabel matches within the list of filterLabels
        /// contribute towards the overall metadataFilter match. Supported values are:
        /// - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        /// provided metadata.
        /// - MATCH_ALL: All filterLabels must have matching labels in
        /// the provided metadata.
        /// </summary>
        [Input("filterMatchCriteria", required: true)]
        public Input<string> FilterMatchCriteria { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        [Input("exactMatch")]
        public Input<string>? ExactMatch { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        [Input("presentMatch")]
        public Input<bool>? PresentMatch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        [Input("regexMatch")]
        public Input<string>? RegexMatch { get; set; }

        public RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatchesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicyArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionTimeoutArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewriteArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs>());
            set => _weightedBackendServices = value;
        }

        public RegionUrlMapPathMatchersRouteRulesRouteActionArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// If true, specifies the CORS policy is disabled.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        [Input("allowCredentials")]
        public Input<bool>? AllowCredentials { get; set; }

        [Input("allowHeaders")]
        private InputList<string>? _allowHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public InputList<string> AllowHeaders
        {
            get => _allowHeaders ?? (_allowHeaders = new InputList<string>());
            set => _allowHeaders = value;
        }

        [Input("allowMethods")]
        private InputList<string>? _allowMethods;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public InputList<string> AllowMethods
        {
            get => _allowMethods ?? (_allowMethods = new InputList<string>());
            set => _allowMethods = value;
        }

        [Input("allowOriginRegexes")]
        private InputList<string>? _allowOriginRegexes;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOriginRegexes
        {
            get => _allowOriginRegexes ?? (_allowOriginRegexes = new InputList<string>());
            set => _allowOriginRegexes = value;
        }

        [Input("allowOrigins")]
        private InputList<string>? _allowOrigins;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public InputList<string> AllowOrigins
        {
            get => _allowOrigins ?? (_allowOrigins = new InputList<string>());
            set => _allowOrigins = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// If true, specifies the CORS policy is disabled.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        [Input("exposeHeaders")]
        private InputList<string>? _exposeHeaders;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public InputList<string> ExposeHeaders
        {
            get => _exposeHeaders ?? (_exposeHeaders = new InputList<string>());
            set => _exposeHeaders = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus")]
        public Input<int>? HttpStatus { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        [Input("httpStatus")]
        public Input<int>? HttpStatus { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayArgs>? Delay { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs>? FixedDelay { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        [Input("fixedDelay")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayGetArgs>? FixedDelay { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        [Input("percentage")]
        public Input<double>? Percentage { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        [Input("abort")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbortGetArgs>? Abort { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        [Input("delay")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayGetArgs>? Delay { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        [Input("corsPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicyGetArgs>? CorsPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        [Input("faultInjectionPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyGetArgs>? FaultInjectionPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        [Input("requestMirrorPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyGetArgs>? RequestMirrorPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        [Input("retryPolicy")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyGetArgs>? RetryPolicy { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        [Input("timeout")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionTimeoutGetArgs>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        [Input("urlRewrite")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewriteGetArgs>? UrlRewrite { get; set; }

        [Input("weightedBackendServices")]
        private InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs>? _weightedBackendServices;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs> WeightedBackendServices
        {
            get => _weightedBackendServices ?? (_weightedBackendServices = new InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs>());
            set => _weightedBackendServices = value;
        }

        public RegionUrlMapPathMatchersRouteRulesRouteActionGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries", required: true)]
        public Input<int> NumRetries { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if
        /// the gRPC status code in the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        [Input("numRetries", required: true)]
        public Input<int> NumRetries { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        /// </summary>
        [Input("perTryTimeout")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutGetArgs>? PerTryTimeout { get; set; }

        [Input("retryConditions")]
        private InputList<string>? _retryConditions;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if
        /// the gRPC status code in the response header is set to unavailable
        /// </summary>
        public InputList<string> RetryConditions
        {
            get => _retryConditions ?? (_retryConditions = new InputList<string>());
            set => _retryConditions = value;
        }

        public RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeoutGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionTimeoutArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionTimeoutArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionTimeoutGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        [Input("nanos")]
        public Input<int>? Nanos { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        [Input("seconds", required: true)]
        public Input<string> Seconds { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionTimeoutGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewriteArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewriteArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewriteGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        [Input("hostRewrite")]
        public Input<string>? HostRewrite { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        [Input("pathPrefixRewrite")]
        public Input<string>? PathPrefixRewrite { get; set; }

        public RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewriteGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        [Input("backendService", required: true)]
        public Input<string> BackendService { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        [Input("headerAction")]
        public Input<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionGetArgs>? HeaderAction { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionGetArgs : Pulumi.ResourceArgs
    {
        [Input("requestHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>? _requestHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs> RequestHeadersToAdds
        {
            get => _requestHeadersToAdds ?? (_requestHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs>());
            set => _requestHeadersToAdds = value;
        }

        [Input("requestHeadersToRemoves")]
        private InputList<string>? _requestHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public InputList<string> RequestHeadersToRemoves
        {
            get => _requestHeadersToRemoves ?? (_requestHeadersToRemoves = new InputList<string>());
            set => _requestHeadersToRemoves = value;
        }

        [Input("responseHeadersToAdds")]
        private InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>? _responseHeadersToAdds;

        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs> ResponseHeadersToAdds
        {
            get => _responseHeadersToAdds ?? (_responseHeadersToAdds = new InputList<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs>());
            set => _responseHeadersToAdds = value;
        }

        [Input("responseHeadersToRemoves")]
        private InputList<string>? _responseHeadersToRemoves;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public InputList<string> ResponseHeadersToRemoves
        {
            get => _responseHeadersToRemoves ?? (_responseHeadersToRemoves = new InputList<string>());
            set => _responseHeadersToRemoves = value;
        }

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        [Input("headerName", required: true)]
        public Input<string> HeaderName { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        [Input("headerValue", required: true)]
        public Input<string> HeaderValue { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        [Input("replace", required: true)]
        public Input<bool> Replace { get; set; } = null!;

        public RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAddsGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesUrlRedirectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:
        /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        /// - FOUND, which corresponds to 302.
        /// - SEE_OTHER which corresponds to 303.
        /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.
        /// - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained.
        /// </summary>
        [Input("stripQuery")]
        public Input<bool>? StripQuery { get; set; }

        public RegionUrlMapPathMatchersRouteRulesUrlRedirectArgs()
        {
        }
    }

    public sealed class RegionUrlMapPathMatchersRouteRulesUrlRedirectGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        [Input("hostRedirect")]
        public Input<string>? HostRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        [Input("httpsRedirect")]
        public Input<bool>? HttpsRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        [Input("pathRedirect")]
        public Input<string>? PathRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        [Input("prefixRedirect")]
        public Input<string>? PrefixRedirect { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:
        /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        /// - FOUND, which corresponds to 302.
        /// - SEE_OTHER which corresponds to 303.
        /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.
        /// - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        [Input("redirectResponseCode")]
        public Input<string>? RedirectResponseCode { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained.
        /// </summary>
        [Input("stripQuery")]
        public Input<bool>? StripQuery { get; set; }

        public RegionUrlMapPathMatchersRouteRulesUrlRedirectGetArgs()
        {
        }
    }

    public sealed class RegionUrlMapTestsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Host portion of the URL.
        /// </summary>
        [Input("host", required: true)]
        public Input<string> Host { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// Path portion of the URL.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        [Input("service", required: true)]
        public Input<string> Service { get; set; } = null!;

        public RegionUrlMapTestsArgs()
        {
        }
    }

    public sealed class RegionUrlMapTestsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Host portion of the URL.
        /// </summary>
        [Input("host", required: true)]
        public Input<string> Host { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// Path portion of the URL.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        [Input("service", required: true)]
        public Input<string> Service { get; set; } = null!;

        public RegionUrlMapTestsGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class RegionUrlMapHostRules
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        public readonly string? Description;
        /// <summary>
        /// -
        /// (Required)
        /// The list of host patterns to match. They must be valid
        /// hostnames, except * will match any string of ([a-z0-9-.]*). In
        /// that case, * must be the first character and must be followed in
        /// the pattern by either - or ..
        /// </summary>
        public readonly ImmutableArray<string> Hosts;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the PathMatcher to use to match the path portion of
        /// the URL if the hostRule matches the URL's host portion.
        /// </summary>
        public readonly string PathMatcher;

        [OutputConstructor]
        private RegionUrlMapHostRules(
            string? description,
            ImmutableArray<string> hosts,
            string pathMatcher)
        {
            Description = description;
            Hosts = hosts;
            PathMatcher = pathMatcher;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchers
    {
        /// <summary>
        /// -
        /// (Required)
        /// A reference to a RegionBackendService resource. This will be used if
        /// none of the pathRules defined by this PathMatcher is matched by
        /// the URL's path portion.
        /// </summary>
        public readonly string DefaultService;
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        public readonly string? Description;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Optional)
        /// The list of path rules. Use this list instead of routeRules when routing based
        /// on simple path matching is all that's required. The order by which path rules
        /// are specified does not matter. Matches are always done on the longest-path-first
        /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        /// irrespective of the order in which those paths appear in this list. Within a
        /// given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersPathRules> PathRules;
        /// <summary>
        /// -
        /// (Optional)
        /// The list of ordered HTTP route rules. Use this list instead of pathRules when
        /// advanced route matching and routing actions are desired. The order of specifying
        /// routeRules matters: the first rule that matches will cause its specified routing
        /// action to take effect. Within a given pathMatcher, only one of pathRules or
        /// routeRules must be set. routeRules are not supported in UrlMaps intended for
        /// External load balancers.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRules> RouteRules;

        [OutputConstructor]
        private RegionUrlMapPathMatchers(
            string defaultService,
            string? description,
            string name,
            ImmutableArray<RegionUrlMapPathMatchersPathRules> pathRules,
            ImmutableArray<RegionUrlMapPathMatchersRouteRules> routeRules)
        {
            DefaultService = defaultService;
            Description = description;
            Name = name;
            PathRules = pathRules;
            RouteRules = routeRules;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRules
    {
        /// <summary>
        /// -
        /// (Required)
        /// The list of path patterns to match. Each must start with / and the only place a
        /// * is allowed is at the end following a /. The string fed to the path matcher
        /// does not include any text after the first ? or #, and those chars are not
        /// allowed here.
        /// </summary>
        public readonly ImmutableArray<string> Paths;
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching path, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteAction? RouteAction;
        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        public readonly string? Service;
        /// <summary>
        /// -
        /// (Optional)
        /// When a path pattern is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesUrlRedirect? UrlRedirect;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRules(
            ImmutableArray<string> paths,
            RegionUrlMapPathMatchersPathRulesRouteAction? routeAction,
            string? service,
            RegionUrlMapPathMatchersPathRulesUrlRedirect? urlRedirect)
        {
            Paths = paths;
            RouteAction = routeAction;
            Service = service;
            UrlRedirect = urlRedirect;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicy? CorsPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicy? FaultInjectionPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicy? RequestMirrorPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicy? RetryPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionTimeout? Timeout;
        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionUrlRewrite? UrlRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServices> WeightedBackendServices;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteAction(
            RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicy? corsPolicy,
            RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicy? faultInjectionPolicy,
            RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicy? requestMirrorPolicy,
            RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicy? retryPolicy,
            RegionUrlMapPathMatchersPathRulesRouteActionTimeout? timeout,
            RegionUrlMapPathMatchersPathRulesRouteActionUrlRewrite? urlRewrite,
            ImmutableArray<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServices> weightedBackendServices)
        {
            CorsPolicy = corsPolicy;
            FaultInjectionPolicy = faultInjectionPolicy;
            RequestMirrorPolicy = requestMirrorPolicy;
            RetryPolicy = retryPolicy;
            Timeout = timeout;
            UrlRewrite = urlRewrite;
            WeightedBackendServices = weightedBackendServices;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        public readonly bool? AllowCredentials;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> AllowHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public readonly ImmutableArray<string> AllowMethods;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOriginRegexes;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOrigins;
        /// <summary>
        /// -
        /// (Required)
        /// If true, specifies the CORS policy is disabled.
        /// </summary>
        public readonly bool Disabled;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> ExposeHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        public readonly int? MaxAge;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionCorsPolicy(
            bool? allowCredentials,
            ImmutableArray<string> allowHeaders,
            ImmutableArray<string> allowMethods,
            ImmutableArray<string> allowOriginRegexes,
            ImmutableArray<string> allowOrigins,
            bool disabled,
            ImmutableArray<string> exposeHeaders,
            int? maxAge)
        {
            AllowCredentials = allowCredentials;
            AllowHeaders = allowHeaders;
            AllowMethods = allowMethods;
            AllowOriginRegexes = allowOriginRegexes;
            AllowOrigins = allowOrigins;
            Disabled = disabled;
            ExposeHeaders = exposeHeaders;
            MaxAge = maxAge;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort? Abort;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay? Delay;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicy(
            RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort? abort,
            RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay? delay)
        {
            Abort = abort;
            Delay = delay;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort
    {
        /// <summary>
        /// -
        /// (Required)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        public readonly int HttpStatus;
        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double Percentage;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyAbort(
            int httpStatus,
            double percentage)
        {
            HttpStatus = httpStatus;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay FixedDelay;
        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double Percentage;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelay(
            RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay fixedDelay,
            double percentage)
        {
            FixedDelay = fixedDelay;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionFaultInjectionPolicyDelayFixedDelay(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicy
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionRequestMirrorPolicy(string backendService)
        {
            BackendService = backendService;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        public readonly int? NumRetries;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout? PerTryTimeout;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if
        /// the gRPC status code in the response header is set to unavailable
        /// </summary>
        public readonly ImmutableArray<string> RetryConditions;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicy(
            int? numRetries,
            RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout? perTryTimeout,
            ImmutableArray<string> retryConditions)
        {
            NumRetries = numRetries;
            PerTryTimeout = perTryTimeout;
            RetryConditions = retryConditions;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionRetryPolicyPerTryTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionUrlRewrite
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        public readonly string? HostRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathPrefixRewrite;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionUrlRewrite(
            string? hostRewrite,
            string? pathPrefixRewrite)
        {
            HostRewrite = hostRewrite;
            PathPrefixRewrite = pathPrefixRewrite;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServices
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction? HeaderAction;
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        public readonly int Weight;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServices(
            string backendService,
            RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction? headerAction,
            int weight)
        {
            BackendService = backendService;
            HeaderAction = headerAction;
            Weight = weight;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderAction(
            ImmutableArray<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersPathRulesUrlRedirect
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        public readonly string? HostRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        public readonly bool? HttpsRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        public readonly string? PrefixRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:
        /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        /// - FOUND, which corresponds to 302.
        /// - SEE_OTHER which corresponds to 303.
        /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.
        /// - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        public readonly string? RedirectResponseCode;
        /// <summary>
        /// -
        /// (Required)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained.
        /// </summary>
        public readonly bool StripQuery;

        [OutputConstructor]
        private RegionUrlMapPathMatchersPathRulesUrlRedirect(
            string? hostRedirect,
            bool? httpsRedirect,
            string? pathRedirect,
            string? prefixRedirect,
            string? redirectResponseCode,
            bool stripQuery)
        {
            HostRedirect = hostRedirect;
            HttpsRedirect = httpsRedirect;
            PathRedirect = pathRedirect;
            PrefixRedirect = prefixRedirect;
            RedirectResponseCode = redirectResponseCode;
            StripQuery = stripQuery;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRules
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesHeaderAction? HeaderAction;
        /// <summary>
        /// -
        /// (Optional)
        /// The rules for determining a match.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRules> MatchRules;
        /// <summary>
        /// -
        /// (Required)
        /// For routeRules within a given pathMatcher, priority determines the order
        /// in which load balancer will interpret routeRules. RouteRules are evaluated
        /// in order of priority, from the lowest to highest number. The priority of
        /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        /// that matches the request is applied.
        /// You cannot configure two or more routeRules with the same priority.
        /// Priority for each rule must be set to a number between 0 and
        /// 2147483647 inclusive.
        /// Priority numbers can have gaps, which enable you to add or remove rules
        /// in the future without affecting the rest of the rules. For example,
        /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        /// future without any impact on existing rules.
        /// </summary>
        public readonly int Priority;
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a matching path, the load balancer performs advanced routing
        /// actions like URL rewrites, header transformations, etc. prior to forwarding the
        /// request to the selected backend. If routeAction specifies any
        /// weightedBackendServices, service must not be set. Conversely if service is set,
        /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        /// or urlRedirect must be set.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteAction? RouteAction;
        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        public readonly string? Service;
        /// <summary>
        /// -
        /// (Optional)
        /// When a path pattern is matched, the request is redirected to a URL specified by
        /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
        /// set.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesUrlRedirect? UrlRedirect;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRules(
            RegionUrlMapPathMatchersRouteRulesHeaderAction? headerAction,
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRules> matchRules,
            int priority,
            RegionUrlMapPathMatchersRouteRulesRouteAction? routeAction,
            string? service,
            RegionUrlMapPathMatchersRouteRulesUrlRedirect? urlRedirect)
        {
            HeaderAction = headerAction;
            MatchRules = matchRules;
            Priority = priority;
            RouteAction = routeAction;
            Service = service;
            UrlRedirect = urlRedirect;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesHeaderAction(
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRules
    {
        /// <summary>
        /// -
        /// (Optional)
        /// For satifying the matchRule condition, the path of the request must exactly
        /// match the value specified in fullPathMatch after removing any query parameters
        /// and anchor that may be part of the original URL. FullPathMatch must be between 1
        /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        /// be specified.
        /// </summary>
        public readonly string? FullPathMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of header match criteria, all of which must match corresponding
        /// headers in the request.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatches> HeaderMatches;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        /// Defaults to false.
        /// </summary>
        public readonly bool? IgnoreCase;
        /// <summary>
        /// -
        /// (Optional)
        /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        /// clients present node metadata. If a match takes place, the relevant routing
        /// configuration is made available to those proxies. For each metadataFilter in
        /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        /// filterLabels must match the corresponding label provided in the metadata. If its
        /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        /// with corresponding labels in the provided metadata. metadataFilters specified
        /// here can be overrides those specified in ForwardingRule that refers to this
        /// UrlMap. metadataFilters only applies to Loadbalancers that have their
        /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFilters> MetadataFilters;
        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        public readonly string? PrefixMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a list of query parameter match criteria, all of which must match
        /// corresponding query parameters in the request.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatches> QueryParameterMatches;
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        public readonly string? RegexMatch;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesMatchRules(
            string? fullPathMatch,
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatches> headerMatches,
            bool? ignoreCase,
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFilters> metadataFilters,
            string? prefixMatch,
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatches> queryParameterMatches,
            string? regexMatch)
        {
            FullPathMatch = fullPathMatch;
            HeaderMatches = headerMatches;
            IgnoreCase = ignoreCase;
            MetadataFilters = metadataFilters;
            PrefixMatch = prefixMatch;
            QueryParameterMatches = queryParameterMatches;
            RegexMatch = regexMatch;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatches
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        public readonly string? ExactMatch;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to false, the headerMatch is considered a match if the match criteria
        /// above are met. If set to true, the headerMatch is considered a match if the
        /// match criteria above are NOT met. Defaults to false.
        /// </summary>
        public readonly bool? InvertMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must start with the contents of prefixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        public readonly string? PrefixMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        public readonly bool? PresentMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The header value must be an integer and its value must be in the range specified
        /// in rangeMatch. If the header does not contain an integer, number or is empty,
        /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch? RangeMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        public readonly string? RegexMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The value of the header must end with the contents of suffixMatch. Only one of
        /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        /// must be set.
        /// </summary>
        public readonly string? SuffixMatch;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatches(
            string? exactMatch,
            string headerName,
            bool? invertMatch,
            string? prefixMatch,
            bool? presentMatch,
            RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch? rangeMatch,
            string? regexMatch,
            string? suffixMatch)
        {
            ExactMatch = exactMatch;
            HeaderName = headerName;
            InvertMatch = invertMatch;
            PrefixMatch = prefixMatch;
            PresentMatch = presentMatch;
            RangeMatch = rangeMatch;
            RegexMatch = regexMatch;
            SuffixMatch = suffixMatch;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch
    {
        /// <summary>
        /// -
        /// (Required)
        /// The end of the range (exclusive).
        /// </summary>
        public readonly int RangeEnd;
        /// <summary>
        /// -
        /// (Required)
        /// The start of the range (inclusive).
        /// </summary>
        public readonly int RangeStart;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesMatchRulesHeaderMatchesRangeMatch(
            int rangeEnd,
            int rangeStart)
        {
            RangeEnd = rangeEnd;
            RangeStart = rangeStart;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFilters
    {
        /// <summary>
        /// -
        /// (Required)
        /// The list of label value pairs that must match labels in the provided metadata
        /// based on filterMatchCriteria  This list must not be empty and can have at the
        /// most 64 entries.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels> FilterLabels;
        /// <summary>
        /// -
        /// (Required)
        /// Specifies how individual filterLabel matches within the list of filterLabels
        /// contribute towards the overall metadataFilter match. Supported values are:
        /// - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        /// provided metadata.
        /// - MATCH_ALL: All filterLabels must have matching labels in
        /// the provided metadata.
        /// </summary>
        public readonly string FilterMatchCriteria;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFilters(
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels> filterLabels,
            string filterMatchCriteria)
        {
            FilterLabels = filterLabels;
            FilterMatchCriteria = filterMatchCriteria;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the label must match the specified value. value can have a maximum
        /// length of 1024 characters.
        /// </summary>
        public readonly string Value;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesMatchRulesMetadataFiltersFilterLabels(
            string name,
            string value)
        {
            Name = name;
            Value = value;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatches
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter exactly matches
        /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        /// must be set.
        /// </summary>
        public readonly string? ExactMatch;
        /// <summary>
        /// -
        /// (Required)
        /// The name of the query parameter to match. The query parameter must exist in the
        /// request, in the absence of which the request match fails.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies that the queryParameterMatch matches if the request contains the query
        /// parameter, irrespective of whether the parameter has a value or not. Only one of
        /// presentMatch, exactMatch and regexMatch must be set.
        /// </summary>
        public readonly bool? PresentMatch;
        /// <summary>
        /// -
        /// (Optional)
        /// The queryParameterMatch matches if the value of the parameter matches the
        /// regular expression specified by regexMatch. For the regular expression grammar,
        /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        /// exactMatch and regexMatch must be set.
        /// </summary>
        public readonly string? RegexMatch;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesMatchRulesQueryParameterMatches(
            string? exactMatch,
            string name,
            bool? presentMatch,
            string? regexMatch)
        {
            ExactMatch = exactMatch;
            Name = name;
            PresentMatch = presentMatch;
            RegexMatch = regexMatch;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for allowing client side cross-origin requests. Please see W3C
        /// Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicy? CorsPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for fault injection introduced into traffic to test the
        /// resiliency of clients to backend service failure. As part of fault injection,
        /// when clients send requests to a backend service, delays can be introduced by
        /// Loadbalancer on a percentage of requests before sending those request to the
        /// backend service. Similarly requests from clients can be aborted by the
        /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
        /// ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy? FaultInjectionPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the policy on how requests intended for the route's backends are
        /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        /// responses from the shadow service. Prior to sending traffic to the shadow
        /// service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy? RequestMirrorPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the retry policy associated with this route.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicy? RetryPolicy;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the timeout for the selected route. Timeout is computed from the time
        /// the request is has been fully processed (i.e. end-of-stream) up until the
        /// response has been completely processed. Timeout includes all retries. If not
        /// specified, the default value is 15 seconds.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionTimeout? Timeout;
        /// <summary>
        /// -
        /// (Optional)
        /// The spec to modify the URL of the request, prior to forwarding the request to
        /// the matched service  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewrite? UrlRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of weighted backend services to send traffic to when a route match
        /// occurs. The weights determine the fraction of traffic that flows to their
        /// corresponding backend service. If all traffic needs to go to a single backend
        /// service, there must be one  weightedBackendService with weight set to a non 0
        /// number. Once a backendService is identified and before forwarding the request to
        /// the backend service, advanced routing actions like Url rewrites and header
        /// transformations are applied depending on additional settings specified in this
        /// HttpRouteAction.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServices> WeightedBackendServices;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteAction(
            RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicy? corsPolicy,
            RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy? faultInjectionPolicy,
            RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy? requestMirrorPolicy,
            RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicy? retryPolicy,
            RegionUrlMapPathMatchersRouteRulesRouteActionTimeout? timeout,
            RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewrite? urlRewrite,
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServices> weightedBackendServices)
        {
            CorsPolicy = corsPolicy;
            FaultInjectionPolicy = faultInjectionPolicy;
            RequestMirrorPolicy = requestMirrorPolicy;
            RetryPolicy = retryPolicy;
            Timeout = timeout;
            UrlRewrite = urlRewrite;
            WeightedBackendServices = weightedBackendServices;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// In response to a preflight request, setting this to true indicates that the
        /// actual request can include user credentials. This translates to the Access-
        /// Control-Allow-Credentials header. Defaults to false.
        /// </summary>
        public readonly bool? AllowCredentials;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> AllowHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Allow-Methods header.
        /// </summary>
        public readonly ImmutableArray<string> AllowMethods;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the regualar expression patterns that match allowed origins. For
        /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOriginRegexes;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the list of origins that will be allowed to do CORS requests. An
        /// origin is allowed if it matches either allow_origins or allow_origin_regex.
        /// </summary>
        public readonly ImmutableArray<string> AllowOrigins;
        /// <summary>
        /// -
        /// (Required)
        /// If true, specifies the CORS policy is disabled.
        /// </summary>
        public readonly bool? Disabled;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the content for the Access-Control-Expose-Headers header.
        /// </summary>
        public readonly ImmutableArray<string> ExposeHeaders;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies how long the results of a preflight request can be cached. This
        /// translates to the content for the Access-Control-Max-Age header.
        /// </summary>
        public readonly int? MaxAge;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionCorsPolicy(
            bool? allowCredentials,
            ImmutableArray<string> allowHeaders,
            ImmutableArray<string> allowMethods,
            ImmutableArray<string> allowOriginRegexes,
            ImmutableArray<string> allowOrigins,
            bool? disabled,
            ImmutableArray<string> exposeHeaders,
            int? maxAge)
        {
            AllowCredentials = allowCredentials;
            AllowHeaders = allowHeaders;
            AllowMethods = allowMethods;
            AllowOriginRegexes = allowOriginRegexes;
            AllowOrigins = allowOrigins;
            Disabled = disabled;
            ExposeHeaders = exposeHeaders;
            MaxAge = maxAge;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are aborted as part of fault
        /// injection.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort? Abort;
        /// <summary>
        /// -
        /// (Optional)
        /// The specification for how client requests are delayed as part of fault
        /// injection, before being sent to a backend service.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay? Delay;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicy(
            RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort? abort,
            RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay? delay)
        {
            Abort = abort;
            Delay = delay;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort
    {
        /// <summary>
        /// -
        /// (Required)
        /// The HTTP status code used to abort the request. The value must be between 200
        /// and 599 inclusive.
        /// </summary>
        public readonly int? HttpStatus;
        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double? Percentage;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyAbort(
            int? httpStatus,
            double? percentage)
        {
            HttpStatus = httpStatus;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay
    {
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the value of the fixed delay interval.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay? FixedDelay;
        /// <summary>
        /// -
        /// (Required)
        /// The percentage of traffic (connections/operations/requests) on which delay will
        /// be introduced as part of fault injection. The value must be between 0.0 and
        /// 100.0 inclusive.
        /// </summary>
        public readonly double? Percentage;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelay(
            RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay? fixedDelay,
            double? percentage)
        {
            FixedDelay = fixedDelay;
            Percentage = percentage;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionRequestMirrorPolicy(string backendService)
        {
            BackendService = backendService;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicy
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies the allowed number retries. This number must be &gt; 0.
        /// </summary>
        public readonly int NumRetries;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout? PerTryTimeout;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies one or more conditions when this retry rule applies. Valid values are:
        /// - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        /// any 5xx response code, or if the backend service does not respond at all,
        /// example: disconnects, reset, read timeout, connection failure, and refused
        /// streams.
        /// - gateway-error: Similar to 5xx, but only applies to response codes
        /// 502, 503 or 504.
        /// - connect-failure: Loadbalancer will retry on failures
        /// connecting to backend services, for example due to connection timeouts.
        /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        /// Currently the only retriable error supported is 409.
        /// - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        /// REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        /// - cancelled: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to cancelled
        /// - deadline-exceeded: Loadbalancer will retry if the
        /// gRPC status code in the response header is set to deadline-exceeded
        /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        /// header is set to resource-exhausted
        /// - unavailable: Loadbalancer will retry if
        /// the gRPC status code in the response header is set to unavailable
        /// </summary>
        public readonly ImmutableArray<string> RetryConditions;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicy(
            int numRetries,
            RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout? perTryTimeout,
            ImmutableArray<string> retryConditions)
        {
            NumRetries = numRetries;
            PerTryTimeout = perTryTimeout;
            RetryConditions = retryConditions;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionRetryPolicyPerTryTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionTimeout
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Span of time that's a fraction of a second at nanosecond resolution. Durations
        /// less than one second are represented with a 0 `seconds` field and a positive
        /// `nanos` field. Must be from 0 to 999,999,999 inclusive.
        /// </summary>
        public readonly int? Nanos;
        /// <summary>
        /// -
        /// (Required)
        /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        /// inclusive.
        /// </summary>
        public readonly string Seconds;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionTimeout(
            int? nanos,
            string seconds)
        {
            Nanos = nanos;
            Seconds = seconds;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewrite
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected service, the request's host
        /// header is replaced with contents of hostRewrite. The value must be between 1 and
        /// 255 characters.
        /// </summary>
        public readonly string? HostRewrite;
        /// <summary>
        /// -
        /// (Optional)
        /// Prior to forwarding the request to the selected backend service, the matching
        /// portion of the request's path is replaced by pathPrefixRewrite. The value must
        /// be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathPrefixRewrite;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionUrlRewrite(
            string? hostRewrite,
            string? pathPrefixRewrite)
        {
            HostRewrite = hostRewrite;
            PathPrefixRewrite = pathPrefixRewrite;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServices
    {
        /// <summary>
        /// -
        /// (Required)
        /// The default RegionBackendService resource. Before
        /// forwarding the request to backendService, the loadbalancer applies any relevant
        /// headerActions specified as part of this backendServiceWeight.
        /// </summary>
        public readonly string BackendService;
        /// <summary>
        /// -
        /// (Optional)
        /// Specifies changes to request and response headers that need to take effect for
        /// the selected backendService. headerAction specified here take effect before
        /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        /// </summary>
        public readonly RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction? HeaderAction;
        /// <summary>
        /// -
        /// (Required)
        /// Specifies the fraction of traffic sent to backendService, computed as weight /
        /// (sum of all weightedBackendService weights in routeAction) . The selection of a
        /// backend service is determined only for new traffic. Once a user's request has
        /// been directed to a backendService, subsequent requests will be sent to the same
        /// backendService as determined by the BackendService's session affinity policy.
        /// The value must be between 0 and 1000
        /// </summary>
        public readonly int Weight;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServices(
            string backendService,
            RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction? headerAction,
            int weight)
        {
            BackendService = backendService;
            HeaderAction = headerAction;
            Weight = weight;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add to a matching request prior to forwarding the request to the
        /// backendService.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> RequestHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the request
        /// prior to forwarding the request to the backendService.
        /// </summary>
        public readonly ImmutableArray<string> RequestHeadersToRemoves;
        /// <summary>
        /// -
        /// (Optional)
        /// Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> ResponseHeadersToAdds;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of header names for headers that need to be removed from the response
        /// prior to sending the response back to the client.
        /// </summary>
        public readonly ImmutableArray<string> ResponseHeadersToRemoves;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderAction(
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds> requestHeadersToAdds,
            ImmutableArray<string> requestHeadersToRemoves,
            ImmutableArray<RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds> responseHeadersToAdds,
            ImmutableArray<string> responseHeadersToRemoves)
        {
            RequestHeadersToAdds = requestHeadersToAdds;
            RequestHeadersToRemoves = requestHeadersToRemoves;
            ResponseHeadersToAdds = responseHeadersToAdds;
            ResponseHeadersToRemoves = responseHeadersToRemoves;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds
    {
        /// <summary>
        /// -
        /// (Required)
        /// The name of the header.
        /// </summary>
        public readonly string HeaderName;
        /// <summary>
        /// -
        /// (Required)
        /// The value of the header to add.
        /// </summary>
        public readonly string HeaderValue;
        /// <summary>
        /// -
        /// (Required)
        /// If false, headerValue is appended to any values that already exist for the
        /// header. If true, headerValue is set for the header, discarding any values that
        /// were set for that header.
        /// </summary>
        public readonly bool Replace;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdds(
            string headerName,
            string headerValue,
            bool replace)
        {
            HeaderName = headerName;
            HeaderValue = headerValue;
            Replace = replace;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapPathMatchersRouteRulesUrlRedirect
    {
        /// <summary>
        /// -
        /// (Optional)
        /// The host that will be used in the redirect response instead of the one that was
        /// supplied in the request. The value must be between 1 and 255 characters.
        /// </summary>
        public readonly string? HostRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// If set to true, the URL scheme in the redirected request is set to https. If set
        /// to false, the URL scheme of the redirected request will remain the same as that
        /// of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        /// Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        /// </summary>
        public readonly bool? HttpsRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The path that will be used in the redirect response instead of the one that was
        /// supplied in the request. Only one of pathRedirect or prefixRedirect must be
        /// specified. The value must be between 1 and 1024 characters.
        /// </summary>
        public readonly string? PathRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        /// retaining the remaining portion of the URL before redirecting the request.
        /// </summary>
        public readonly string? PrefixRedirect;
        /// <summary>
        /// -
        /// (Optional)
        /// The HTTP Status code to use for this RedirectAction. Supported values are:
        /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        /// - FOUND, which corresponds to 302.
        /// - SEE_OTHER which corresponds to 303.
        /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        /// will be retained.
        /// - PERMANENT_REDIRECT, which corresponds to 308. In this case,
        /// the request method will be retained.
        /// </summary>
        public readonly string? RedirectResponseCode;
        /// <summary>
        /// -
        /// (Required)
        /// If set to true, any accompanying query portion of the original URL is removed
        /// prior to redirecting the request. If set to false, the query portion of the
        /// original URL is retained.
        /// </summary>
        public readonly bool? StripQuery;

        [OutputConstructor]
        private RegionUrlMapPathMatchersRouteRulesUrlRedirect(
            string? hostRedirect,
            bool? httpsRedirect,
            string? pathRedirect,
            string? prefixRedirect,
            string? redirectResponseCode,
            bool? stripQuery)
        {
            HostRedirect = hostRedirect;
            HttpsRedirect = httpsRedirect;
            PathRedirect = pathRedirect;
            PrefixRedirect = prefixRedirect;
            RedirectResponseCode = redirectResponseCode;
            StripQuery = stripQuery;
        }
    }

    [OutputType]
    public sealed class RegionUrlMapTests
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Description of this test case.
        /// </summary>
        public readonly string? Description;
        /// <summary>
        /// -
        /// (Required)
        /// Host portion of the URL.
        /// </summary>
        public readonly string Host;
        /// <summary>
        /// -
        /// (Required)
        /// Path portion of the URL.
        /// </summary>
        public readonly string Path;
        /// <summary>
        /// -
        /// (Required)
        /// A reference to expected RegionBackendService resource the given URL should be mapped to.
        /// </summary>
        public readonly string Service;

        [OutputConstructor]
        private RegionUrlMapTests(
            string? description,
            string host,
            string path,
            string service)
        {
            Description = description;
            Host = host;
            Path = path;
            Service = service;
        }
    }
    }
}
