// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.CloudBuild
{
    /// <summary>
    /// Configuration for an automated build in response to source repository changes.
    /// 
    /// 
    /// To get more information about Trigger, see:
    /// 
    /// * [API documentation](https://cloud.google.com/cloud-build/docs/api/reference/rest/)
    /// * How-to Guides
    ///     * [Automating builds using build triggers](https://cloud.google.com/cloud-build/docs/running-builds/automate-builds)
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-google/blob/master/website/docs/r/cloudbuild_trigger.html.markdown.
    /// </summary>
    public partial class Trigger : Pulumi.CustomResource
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Contents of the build template. Either a filename or build template must be provided.  Structure is documented below.
        /// </summary>
        [Output("build")]
        public Output<Outputs.TriggerBuild?> Build { get; private set; } = null!;

        /// <summary>
        /// Time when the trigger was created.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Human-readable description of the trigger.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
        /// </summary>
        [Output("disabled")]
        public Output<bool?> Disabled { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
        /// </summary>
        [Output("filename")]
        public Output<string?> Filename { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
        /// One of `trigger_template` or `github` must be provided.  Structure is documented below.
        /// </summary>
        [Output("github")]
        public Output<Outputs.TriggerGithub?> Github { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
        /// extended with support for `**`.
        /// If ignoredFiles and changed files are both empty, then they are not
        /// used to determine whether or not to trigger a build.
        /// If ignoredFiles is not empty, then we ignore any files that match any
        /// of the ignored_file globs. If the change has no files that are outside
        /// of the ignoredFiles globs, then we do not trigger a build.
        /// </summary>
        [Output("ignoredFiles")]
        public Output<ImmutableArray<string>> IgnoredFiles { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
        /// extended with support for `**`.
        /// If any of the files altered in the commit pass the ignoredFiles filter
        /// and includedFiles is empty, then as far as this filter is concerned, we
        /// should trigger the build.
        /// If any of the files altered in the commit pass the ignoredFiles filter
        /// and includedFiles is not empty, then we make sure that at least one of
        /// those files matches a includedFiles glob. If not, then we do not trigger
        /// a build.
        /// </summary>
        [Output("includedFiles")]
        public Output<ImmutableArray<string>> IncludedFiles { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Substitutions data for Build resource.
        /// </summary>
        [Output("substitutions")]
        public Output<ImmutableDictionary<string, string>?> Substitutions { get; private set; } = null!;

        /// <summary>
        /// The unique identifier for the trigger.
        /// </summary>
        [Output("triggerId")]
        public Output<string> TriggerId { get; private set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Template describing the types of source changes to trigger a build.
        /// Branch and tag names in trigger templates are interpreted as regular
        /// expressions. Any branch or tag change that matches that regular
        /// expression will trigger a build.
        /// One of `trigger_template` or `github` must be provided.  Structure is documented below.
        /// </summary>
        [Output("triggerTemplate")]
        public Output<Outputs.TriggerTriggerTemplate?> TriggerTemplate { get; private set; } = null!;


        /// <summary>
        /// Create a Trigger resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Trigger(string name, TriggerArgs? args = null, CustomResourceOptions? options = null)
            : base("gcp:cloudbuild/trigger:Trigger", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private Trigger(string name, Input<string> id, TriggerState? state = null, CustomResourceOptions? options = null)
            : base("gcp:cloudbuild/trigger:Trigger", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Trigger resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Trigger Get(string name, Input<string> id, TriggerState? state = null, CustomResourceOptions? options = null)
        {
            return new Trigger(name, id, state, options);
        }
    }

    public sealed class TriggerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Contents of the build template. Either a filename or build template must be provided.  Structure is documented below.
        /// </summary>
        [Input("build")]
        public Input<Inputs.TriggerBuildArgs>? Build { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Human-readable description of the trigger.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
        /// </summary>
        [Input("filename")]
        public Input<string>? Filename { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
        /// One of `trigger_template` or `github` must be provided.  Structure is documented below.
        /// </summary>
        [Input("github")]
        public Input<Inputs.TriggerGithubArgs>? Github { get; set; }

        [Input("ignoredFiles")]
        private InputList<string>? _ignoredFiles;

        /// <summary>
        /// -
        /// (Optional)
        /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
        /// extended with support for `**`.
        /// If ignoredFiles and changed files are both empty, then they are not
        /// used to determine whether or not to trigger a build.
        /// If ignoredFiles is not empty, then we ignore any files that match any
        /// of the ignored_file globs. If the change has no files that are outside
        /// of the ignoredFiles globs, then we do not trigger a build.
        /// </summary>
        public InputList<string> IgnoredFiles
        {
            get => _ignoredFiles ?? (_ignoredFiles = new InputList<string>());
            set => _ignoredFiles = value;
        }

        [Input("includedFiles")]
        private InputList<string>? _includedFiles;

        /// <summary>
        /// -
        /// (Optional)
        /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
        /// extended with support for `**`.
        /// If any of the files altered in the commit pass the ignoredFiles filter
        /// and includedFiles is empty, then as far as this filter is concerned, we
        /// should trigger the build.
        /// If any of the files altered in the commit pass the ignoredFiles filter
        /// and includedFiles is not empty, then we make sure that at least one of
        /// those files matches a includedFiles glob. If not, then we do not trigger
        /// a build.
        /// </summary>
        public InputList<string> IncludedFiles
        {
            get => _includedFiles ?? (_includedFiles = new InputList<string>());
            set => _includedFiles = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("substitutions")]
        private InputMap<string>? _substitutions;

        /// <summary>
        /// -
        /// (Optional)
        /// Substitutions data for Build resource.
        /// </summary>
        public InputMap<string> Substitutions
        {
            get => _substitutions ?? (_substitutions = new InputMap<string>());
            set => _substitutions = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Template describing the types of source changes to trigger a build.
        /// Branch and tag names in trigger templates are interpreted as regular
        /// expressions. Any branch or tag change that matches that regular
        /// expression will trigger a build.
        /// One of `trigger_template` or `github` must be provided.  Structure is documented below.
        /// </summary>
        [Input("triggerTemplate")]
        public Input<Inputs.TriggerTriggerTemplateArgs>? TriggerTemplate { get; set; }

        public TriggerArgs()
        {
        }
    }

    public sealed class TriggerState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Contents of the build template. Either a filename or build template must be provided.  Structure is documented below.
        /// </summary>
        [Input("build")]
        public Input<Inputs.TriggerBuildGetArgs>? Build { get; set; }

        /// <summary>
        /// Time when the trigger was created.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Human-readable description of the trigger.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
        /// </summary>
        [Input("filename")]
        public Input<string>? Filename { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
        /// One of `trigger_template` or `github` must be provided.  Structure is documented below.
        /// </summary>
        [Input("github")]
        public Input<Inputs.TriggerGithubGetArgs>? Github { get; set; }

        [Input("ignoredFiles")]
        private InputList<string>? _ignoredFiles;

        /// <summary>
        /// -
        /// (Optional)
        /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
        /// extended with support for `**`.
        /// If ignoredFiles and changed files are both empty, then they are not
        /// used to determine whether or not to trigger a build.
        /// If ignoredFiles is not empty, then we ignore any files that match any
        /// of the ignored_file globs. If the change has no files that are outside
        /// of the ignoredFiles globs, then we do not trigger a build.
        /// </summary>
        public InputList<string> IgnoredFiles
        {
            get => _ignoredFiles ?? (_ignoredFiles = new InputList<string>());
            set => _ignoredFiles = value;
        }

        [Input("includedFiles")]
        private InputList<string>? _includedFiles;

        /// <summary>
        /// -
        /// (Optional)
        /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
        /// extended with support for `**`.
        /// If any of the files altered in the commit pass the ignoredFiles filter
        /// and includedFiles is empty, then as far as this filter is concerned, we
        /// should trigger the build.
        /// If any of the files altered in the commit pass the ignoredFiles filter
        /// and includedFiles is not empty, then we make sure that at least one of
        /// those files matches a includedFiles glob. If not, then we do not trigger
        /// a build.
        /// </summary>
        public InputList<string> IncludedFiles
        {
            get => _includedFiles ?? (_includedFiles = new InputList<string>());
            set => _includedFiles = value;
        }

        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("substitutions")]
        private InputMap<string>? _substitutions;

        /// <summary>
        /// -
        /// (Optional)
        /// Substitutions data for Build resource.
        /// </summary>
        public InputMap<string> Substitutions
        {
            get => _substitutions ?? (_substitutions = new InputMap<string>());
            set => _substitutions = value;
        }

        /// <summary>
        /// The unique identifier for the trigger.
        /// </summary>
        [Input("triggerId")]
        public Input<string>? TriggerId { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Template describing the types of source changes to trigger a build.
        /// Branch and tag names in trigger templates are interpreted as regular
        /// expressions. Any branch or tag change that matches that regular
        /// expression will trigger a build.
        /// One of `trigger_template` or `github` must be provided.  Structure is documented below.
        /// </summary>
        [Input("triggerTemplate")]
        public Input<Inputs.TriggerTriggerTemplateGetArgs>? TriggerTemplate { get; set; }

        public TriggerState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class TriggerBuildArgs : Pulumi.ResourceArgs
    {
        [Input("images")]
        private InputList<string>? _images;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of images to be pushed upon the successful completion of all build steps.
        /// The images are pushed using the builder service account's credentials.
        /// The digests of the pushed images will be stored in the Build resource's results field.
        /// If any of the images fail to be pushed, the build status is marked FAILURE.
        /// </summary>
        public InputList<string> Images
        {
            get => _images ?? (_images = new InputList<string>());
            set => _images = value;
        }

        [Input("steps", required: true)]
        private InputList<TriggerBuildStepsArgs>? _steps;

        /// <summary>
        /// -
        /// (Required)
        /// The operations to be performed on the workspace.  Structure is documented below.
        /// </summary>
        public InputList<TriggerBuildStepsArgs> Steps
        {
            get => _steps ?? (_steps = new InputList<TriggerBuildStepsArgs>());
            set => _steps = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// -
        /// (Optional)
        /// Tags for annotation of a Build. These are not docker tags.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Time limit for executing this build step. If not defined,
        /// the step has no
        /// time limit and will be allowed to continue to run until either it
        /// completes or the build itself times out.
        /// </summary>
        [Input("timeout")]
        public Input<string>? Timeout { get; set; }

        public TriggerBuildArgs()
        {
        }
    }

    public sealed class TriggerBuildGetArgs : Pulumi.ResourceArgs
    {
        [Input("images")]
        private InputList<string>? _images;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of images to be pushed upon the successful completion of all build steps.
        /// The images are pushed using the builder service account's credentials.
        /// The digests of the pushed images will be stored in the Build resource's results field.
        /// If any of the images fail to be pushed, the build status is marked FAILURE.
        /// </summary>
        public InputList<string> Images
        {
            get => _images ?? (_images = new InputList<string>());
            set => _images = value;
        }

        [Input("steps", required: true)]
        private InputList<TriggerBuildStepsGetArgs>? _steps;

        /// <summary>
        /// -
        /// (Required)
        /// The operations to be performed on the workspace.  Structure is documented below.
        /// </summary>
        public InputList<TriggerBuildStepsGetArgs> Steps
        {
            get => _steps ?? (_steps = new InputList<TriggerBuildStepsGetArgs>());
            set => _steps = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// -
        /// (Optional)
        /// Tags for annotation of a Build. These are not docker tags.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Time limit for executing this build step. If not defined,
        /// the step has no
        /// time limit and will be allowed to continue to run until either it
        /// completes or the build itself times out.
        /// </summary>
        [Input("timeout")]
        public Input<string>? Timeout { get; set; }

        public TriggerBuildGetArgs()
        {
        }
    }

    public sealed class TriggerBuildStepsArgs : Pulumi.ResourceArgs
    {
        [Input("args")]
        private InputList<string>? _args;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of arguments that will be presented to the step when it is started.
        /// If the image used to run the step's container has an entrypoint, the args
        /// are used as arguments to that entrypoint. If the image does not define an
        /// entrypoint, the first element in args is used as the entrypoint, and the
        /// remainder will be used as arguments.
        /// </summary>
        public InputList<string> Args
        {
            get => _args ?? (_args = new InputList<string>());
            set => _args = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Working directory to use when running this step's container.
        /// If this value is a relative path, it is relative to the build's working
        /// directory. If this value is absolute, it may be outside the build's working
        /// directory, in which case the contents of the path may not be persisted
        /// across build step executions, unless a `volume` for that path is specified.
        /// If the build specifies a `RepoSource` with `dir` and a step with a
        /// `dir`,
        /// which specifies an absolute path, the `RepoSource` `dir` is ignored
        /// for the step's execution.
        /// </summary>
        [Input("dir")]
        public Input<string>? Dir { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Entrypoint to be used instead of the build step image's
        /// default entrypoint.
        /// If unset, the image's default entrypoint is used
        /// </summary>
        [Input("entrypoint")]
        public Input<string>? Entrypoint { get; set; }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of environment variable definitions to be used when
        /// running a step.
        /// The elements are of the form "KEY=VALUE" for the environment variable
        /// "KEY" being given the value "VALUE".
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Unique identifier for this build step, used in `wait_for` to
        /// reference this build step as a dependency.
        /// </summary>
        [Input("id")]
        public Input<string>? Id { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("secretEnvs")]
        private InputList<string>? _secretEnvs;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of environment variables which are encrypted using
        /// a Cloud Key
        /// Management Service crypto key. These values must be specified in
        /// the build's `Secret`.
        /// </summary>
        public InputList<string> SecretEnvs
        {
            get => _secretEnvs ?? (_secretEnvs = new InputList<string>());
            set => _secretEnvs = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Time limit for executing this build step. If not defined,
        /// the step has no
        /// time limit and will be allowed to continue to run until either it
        /// completes or the build itself times out.
        /// </summary>
        [Input("timeout")]
        public Input<string>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Output only. Stores timing information for executing this
        /// build step.
        /// </summary>
        [Input("timing")]
        public Input<string>? Timing { get; set; }

        [Input("volumes")]
        private InputList<TriggerBuildStepsVolumesArgs>? _volumes;

        /// <summary>
        /// -
        /// (Optional)
        /// List of volumes to mount into the build step.
        /// Each volume is created as an empty volume prior to execution of the
        /// build step. Upon completion of the build, volumes and their contents
        /// are discarded.
        /// Using a named volume in only one step is not valid as it is
        /// indicative of a build request with an incorrect configuration.  Structure is documented below.
        /// </summary>
        public InputList<TriggerBuildStepsVolumesArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<TriggerBuildStepsVolumesArgs>());
            set => _volumes = value;
        }

        [Input("waitFors")]
        private InputList<string>? _waitFors;

        /// <summary>
        /// -
        /// (Optional)
        /// The ID(s) of the step(s) that this build step depends on.
        /// This build step will not start until all the build steps in `wait_for`
        /// have completed successfully. If `wait_for` is empty, this build step
        /// will start when all previous build steps in the `Build.Steps` list
        /// have completed successfully.
        /// </summary>
        public InputList<string> WaitFors
        {
            get => _waitFors ?? (_waitFors = new InputList<string>());
            set => _waitFors = value;
        }

        public TriggerBuildStepsArgs()
        {
        }
    }

    public sealed class TriggerBuildStepsGetArgs : Pulumi.ResourceArgs
    {
        [Input("args")]
        private InputList<string>? _args;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of arguments that will be presented to the step when it is started.
        /// If the image used to run the step's container has an entrypoint, the args
        /// are used as arguments to that entrypoint. If the image does not define an
        /// entrypoint, the first element in args is used as the entrypoint, and the
        /// remainder will be used as arguments.
        /// </summary>
        public InputList<string> Args
        {
            get => _args ?? (_args = new InputList<string>());
            set => _args = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Working directory to use when running this step's container.
        /// If this value is a relative path, it is relative to the build's working
        /// directory. If this value is absolute, it may be outside the build's working
        /// directory, in which case the contents of the path may not be persisted
        /// across build step executions, unless a `volume` for that path is specified.
        /// If the build specifies a `RepoSource` with `dir` and a step with a
        /// `dir`,
        /// which specifies an absolute path, the `RepoSource` `dir` is ignored
        /// for the step's execution.
        /// </summary>
        [Input("dir")]
        public Input<string>? Dir { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Entrypoint to be used instead of the build step image's
        /// default entrypoint.
        /// If unset, the image's default entrypoint is used
        /// </summary>
        [Input("entrypoint")]
        public Input<string>? Entrypoint { get; set; }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of environment variable definitions to be used when
        /// running a step.
        /// The elements are of the form "KEY=VALUE" for the environment variable
        /// "KEY" being given the value "VALUE".
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Unique identifier for this build step, used in `wait_for` to
        /// reference this build step as a dependency.
        /// </summary>
        [Input("id")]
        public Input<string>? Id { get; set; }

        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("secretEnvs")]
        private InputList<string>? _secretEnvs;

        /// <summary>
        /// -
        /// (Optional)
        /// A list of environment variables which are encrypted using
        /// a Cloud Key
        /// Management Service crypto key. These values must be specified in
        /// the build's `Secret`.
        /// </summary>
        public InputList<string> SecretEnvs
        {
            get => _secretEnvs ?? (_secretEnvs = new InputList<string>());
            set => _secretEnvs = value;
        }

        /// <summary>
        /// -
        /// (Optional)
        /// Time limit for executing this build step. If not defined,
        /// the step has no
        /// time limit and will be allowed to continue to run until either it
        /// completes or the build itself times out.
        /// </summary>
        [Input("timeout")]
        public Input<string>? Timeout { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Output only. Stores timing information for executing this
        /// build step.
        /// </summary>
        [Input("timing")]
        public Input<string>? Timing { get; set; }

        [Input("volumes")]
        private InputList<TriggerBuildStepsVolumesGetArgs>? _volumes;

        /// <summary>
        /// -
        /// (Optional)
        /// List of volumes to mount into the build step.
        /// Each volume is created as an empty volume prior to execution of the
        /// build step. Upon completion of the build, volumes and their contents
        /// are discarded.
        /// Using a named volume in only one step is not valid as it is
        /// indicative of a build request with an incorrect configuration.  Structure is documented below.
        /// </summary>
        public InputList<TriggerBuildStepsVolumesGetArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<TriggerBuildStepsVolumesGetArgs>());
            set => _volumes = value;
        }

        [Input("waitFors")]
        private InputList<string>? _waitFors;

        /// <summary>
        /// -
        /// (Optional)
        /// The ID(s) of the step(s) that this build step depends on.
        /// This build step will not start until all the build steps in `wait_for`
        /// have completed successfully. If `wait_for` is empty, this build step
        /// will start when all previous build steps in the `Build.Steps` list
        /// have completed successfully.
        /// </summary>
        public InputList<string> WaitFors
        {
            get => _waitFors ?? (_waitFors = new InputList<string>());
            set => _waitFors = value;
        }

        public TriggerBuildStepsGetArgs()
        {
        }
    }

    public sealed class TriggerBuildStepsVolumesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// Path at which to mount the volume.
        /// Paths must be absolute and cannot conflict with other volume paths on
        /// the same build step or with certain reserved volume paths.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        public TriggerBuildStepsVolumesArgs()
        {
        }
    }

    public sealed class TriggerBuildStepsVolumesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// -
        /// (Required)
        /// Path at which to mount the volume.
        /// Paths must be absolute and cannot conflict with other volume paths on
        /// the same build step or with certain reserved volume paths.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        public TriggerBuildStepsVolumesGetArgs()
        {
        }
    }

    public sealed class TriggerGithubArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Owner of the repository. For example: The owner for
        /// https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
        /// </summary>
        [Input("owner")]
        public Input<string>? Owner { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// filter to match changes in pull requests.  Specify only one of pullRequest or push.  Structure is documented below.
        /// </summary>
        [Input("pullRequest")]
        public Input<TriggerGithubPullRequestArgs>? PullRequest { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// filter to match changes in refs, like branches or tags.  Specify only one of pullRequest or push.  Structure is documented below.
        /// </summary>
        [Input("push")]
        public Input<TriggerGithubPushArgs>? Push { get; set; }

        public TriggerGithubArgs()
        {
        }
    }

    public sealed class TriggerGithubGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Owner of the repository. For example: The owner for
        /// https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
        /// </summary>
        [Input("owner")]
        public Input<string>? Owner { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// filter to match changes in pull requests.  Specify only one of pullRequest or push.  Structure is documented below.
        /// </summary>
        [Input("pullRequest")]
        public Input<TriggerGithubPullRequestGetArgs>? PullRequest { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// filter to match changes in refs, like branches or tags.  Specify only one of pullRequest or push.  Structure is documented below.
        /// </summary>
        [Input("push")]
        public Input<TriggerGithubPushGetArgs>? Push { get; set; }

        public TriggerGithubGetArgs()
        {
        }
    }

    public sealed class TriggerGithubPullRequestArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Regex of branches to match.  Specify only one of branch or tag.
        /// </summary>
        [Input("branch", required: true)]
        public Input<string> Branch { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Whether to block builds on a "/gcbrun" comment from a repository owner or collaborator.
        /// </summary>
        [Input("commentControl")]
        public Input<string>? CommentControl { get; set; }

        public TriggerGithubPullRequestArgs()
        {
        }
    }

    public sealed class TriggerGithubPullRequestGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Regex of branches to match.  Specify only one of branch or tag.
        /// </summary>
        [Input("branch", required: true)]
        public Input<string> Branch { get; set; } = null!;

        /// <summary>
        /// -
        /// (Optional)
        /// Whether to block builds on a "/gcbrun" comment from a repository owner or collaborator.
        /// </summary>
        [Input("commentControl")]
        public Input<string>? CommentControl { get; set; }

        public TriggerGithubPullRequestGetArgs()
        {
        }
    }

    public sealed class TriggerGithubPushArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Regex of branches to match.  Specify only one of branch or tag.
        /// </summary>
        [Input("branch")]
        public Input<string>? Branch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Regex of tags to match.  Specify only one of branch or tag.
        /// </summary>
        [Input("tag")]
        public Input<string>? Tag { get; set; }

        public TriggerGithubPushArgs()
        {
        }
    }

    public sealed class TriggerGithubPushGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Regex of branches to match.  Specify only one of branch or tag.
        /// </summary>
        [Input("branch")]
        public Input<string>? Branch { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Regex of tags to match.  Specify only one of branch or tag.
        /// </summary>
        [Input("tag")]
        public Input<string>? Tag { get; set; }

        public TriggerGithubPushGetArgs()
        {
        }
    }

    public sealed class TriggerTriggerTemplateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
        /// This field is a regular expression.
        /// </summary>
        [Input("branchName")]
        public Input<string>? BranchName { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
        /// </summary>
        [Input("commitSha")]
        public Input<string>? CommitSha { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Working directory to use when running this step's container.
        /// If this value is a relative path, it is relative to the build's working
        /// directory. If this value is absolute, it may be outside the build's working
        /// directory, in which case the contents of the path may not be persisted
        /// across build step executions, unless a `volume` for that path is specified.
        /// If the build specifies a `RepoSource` with `dir` and a step with a
        /// `dir`,
        /// which specifies an absolute path, the `RepoSource` `dir` is ignored
        /// for the step's execution.
        /// </summary>
        [Input("dir")]
        public Input<string>? Dir { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// ID of the project that owns the Cloud Source Repository. If
        /// omitted, the project ID requesting the build is assumed.
        /// </summary>
        [Input("projectId")]
        public Input<string>? ProjectId { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
        /// </summary>
        [Input("repoName")]
        public Input<string>? RepoName { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
        /// This field is a regular expression.
        /// </summary>
        [Input("tagName")]
        public Input<string>? TagName { get; set; }

        public TriggerTriggerTemplateArgs()
        {
        }
    }

    public sealed class TriggerTriggerTemplateGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
        /// This field is a regular expression.
        /// </summary>
        [Input("branchName")]
        public Input<string>? BranchName { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
        /// </summary>
        [Input("commitSha")]
        public Input<string>? CommitSha { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Working directory to use when running this step's container.
        /// If this value is a relative path, it is relative to the build's working
        /// directory. If this value is absolute, it may be outside the build's working
        /// directory, in which case the contents of the path may not be persisted
        /// across build step executions, unless a `volume` for that path is specified.
        /// If the build specifies a `RepoSource` with `dir` and a step with a
        /// `dir`,
        /// which specifies an absolute path, the `RepoSource` `dir` is ignored
        /// for the step's execution.
        /// </summary>
        [Input("dir")]
        public Input<string>? Dir { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// ID of the project that owns the Cloud Source Repository. If
        /// omitted, the project ID requesting the build is assumed.
        /// </summary>
        [Input("projectId")]
        public Input<string>? ProjectId { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
        /// </summary>
        [Input("repoName")]
        public Input<string>? RepoName { get; set; }

        /// <summary>
        /// -
        /// (Optional)
        /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
        /// This field is a regular expression.
        /// </summary>
        [Input("tagName")]
        public Input<string>? TagName { get; set; }

        public TriggerTriggerTemplateGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class TriggerBuild
    {
        /// <summary>
        /// -
        /// (Optional)
        /// A list of images to be pushed upon the successful completion of all build steps.
        /// The images are pushed using the builder service account's credentials.
        /// The digests of the pushed images will be stored in the Build resource's results field.
        /// If any of the images fail to be pushed, the build status is marked FAILURE.
        /// </summary>
        public readonly ImmutableArray<string> Images;
        /// <summary>
        /// -
        /// (Required)
        /// The operations to be performed on the workspace.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<TriggerBuildSteps> Steps;
        /// <summary>
        /// -
        /// (Optional)
        /// Tags for annotation of a Build. These are not docker tags.
        /// </summary>
        public readonly ImmutableArray<string> Tags;
        /// <summary>
        /// -
        /// (Optional)
        /// Time limit for executing this build step. If not defined,
        /// the step has no
        /// time limit and will be allowed to continue to run until either it
        /// completes or the build itself times out.
        /// </summary>
        public readonly string? Timeout;

        [OutputConstructor]
        private TriggerBuild(
            ImmutableArray<string> images,
            ImmutableArray<TriggerBuildSteps> steps,
            ImmutableArray<string> tags,
            string? timeout)
        {
            Images = images;
            Steps = steps;
            Tags = tags;
            Timeout = timeout;
        }
    }

    [OutputType]
    public sealed class TriggerBuildSteps
    {
        /// <summary>
        /// -
        /// (Optional)
        /// A list of arguments that will be presented to the step when it is started.
        /// If the image used to run the step's container has an entrypoint, the args
        /// are used as arguments to that entrypoint. If the image does not define an
        /// entrypoint, the first element in args is used as the entrypoint, and the
        /// remainder will be used as arguments.
        /// </summary>
        public readonly ImmutableArray<string> Args;
        /// <summary>
        /// -
        /// (Optional)
        /// Working directory to use when running this step's container.
        /// If this value is a relative path, it is relative to the build's working
        /// directory. If this value is absolute, it may be outside the build's working
        /// directory, in which case the contents of the path may not be persisted
        /// across build step executions, unless a `volume` for that path is specified.
        /// If the build specifies a `RepoSource` with `dir` and a step with a
        /// `dir`,
        /// which specifies an absolute path, the `RepoSource` `dir` is ignored
        /// for the step's execution.
        /// </summary>
        public readonly string? Dir;
        /// <summary>
        /// -
        /// (Optional)
        /// Entrypoint to be used instead of the build step image's
        /// default entrypoint.
        /// If unset, the image's default entrypoint is used
        /// </summary>
        public readonly string? Entrypoint;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of environment variable definitions to be used when
        /// running a step.
        /// The elements are of the form "KEY=VALUE" for the environment variable
        /// "KEY" being given the value "VALUE".
        /// </summary>
        public readonly ImmutableArray<string> Envs;
        /// <summary>
        /// -
        /// (Optional)
        /// Unique identifier for this build step, used in `wait_for` to
        /// reference this build step as a dependency.
        /// </summary>
        public readonly string? Id;
        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Optional)
        /// A list of environment variables which are encrypted using
        /// a Cloud Key
        /// Management Service crypto key. These values must be specified in
        /// the build's `Secret`.
        /// </summary>
        public readonly ImmutableArray<string> SecretEnvs;
        /// <summary>
        /// -
        /// (Optional)
        /// Time limit for executing this build step. If not defined,
        /// the step has no
        /// time limit and will be allowed to continue to run until either it
        /// completes or the build itself times out.
        /// </summary>
        public readonly string? Timeout;
        /// <summary>
        /// -
        /// (Optional)
        /// Output only. Stores timing information for executing this
        /// build step.
        /// </summary>
        public readonly string? Timing;
        /// <summary>
        /// -
        /// (Optional)
        /// List of volumes to mount into the build step.
        /// Each volume is created as an empty volume prior to execution of the
        /// build step. Upon completion of the build, volumes and their contents
        /// are discarded.
        /// Using a named volume in only one step is not valid as it is
        /// indicative of a build request with an incorrect configuration.  Structure is documented below.
        /// </summary>
        public readonly ImmutableArray<TriggerBuildStepsVolumes> Volumes;
        /// <summary>
        /// -
        /// (Optional)
        /// The ID(s) of the step(s) that this build step depends on.
        /// This build step will not start until all the build steps in `wait_for`
        /// have completed successfully. If `wait_for` is empty, this build step
        /// will start when all previous build steps in the `Build.Steps` list
        /// have completed successfully.
        /// </summary>
        public readonly ImmutableArray<string> WaitFors;

        [OutputConstructor]
        private TriggerBuildSteps(
            ImmutableArray<string> args,
            string? dir,
            string? entrypoint,
            ImmutableArray<string> envs,
            string? id,
            string name,
            ImmutableArray<string> secretEnvs,
            string? timeout,
            string? timing,
            ImmutableArray<TriggerBuildStepsVolumes> volumes,
            ImmutableArray<string> waitFors)
        {
            Args = args;
            Dir = dir;
            Entrypoint = entrypoint;
            Envs = envs;
            Id = id;
            Name = name;
            SecretEnvs = secretEnvs;
            Timeout = timeout;
            Timing = timing;
            Volumes = volumes;
            WaitFors = waitFors;
        }
    }

    [OutputType]
    public sealed class TriggerBuildStepsVolumes
    {
        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// -
        /// (Required)
        /// Path at which to mount the volume.
        /// Paths must be absolute and cannot conflict with other volume paths on
        /// the same build step or with certain reserved volume paths.
        /// </summary>
        public readonly string Path;

        [OutputConstructor]
        private TriggerBuildStepsVolumes(
            string name,
            string path)
        {
            Name = name;
            Path = path;
        }
    }

    [OutputType]
    public sealed class TriggerGithub
    {
        /// <summary>
        /// -
        /// (Required)
        /// Name of the volume to mount.
        /// Volume names must be unique per build step and must be valid names for
        /// Docker volumes. Each named volume must be used by at least two build steps.
        /// </summary>
        public readonly string? Name;
        /// <summary>
        /// -
        /// (Optional)
        /// Owner of the repository. For example: The owner for
        /// https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
        /// </summary>
        public readonly string? Owner;
        /// <summary>
        /// -
        /// (Optional)
        /// filter to match changes in pull requests.  Specify only one of pullRequest or push.  Structure is documented below.
        /// </summary>
        public readonly TriggerGithubPullRequest? PullRequest;
        /// <summary>
        /// -
        /// (Optional)
        /// filter to match changes in refs, like branches or tags.  Specify only one of pullRequest or push.  Structure is documented below.
        /// </summary>
        public readonly TriggerGithubPush? Push;

        [OutputConstructor]
        private TriggerGithub(
            string? name,
            string? owner,
            TriggerGithubPullRequest? pullRequest,
            TriggerGithubPush? push)
        {
            Name = name;
            Owner = owner;
            PullRequest = pullRequest;
            Push = push;
        }
    }

    [OutputType]
    public sealed class TriggerGithubPullRequest
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Regex of branches to match.  Specify only one of branch or tag.
        /// </summary>
        public readonly string Branch;
        /// <summary>
        /// -
        /// (Optional)
        /// Whether to block builds on a "/gcbrun" comment from a repository owner or collaborator.
        /// </summary>
        public readonly string? CommentControl;

        [OutputConstructor]
        private TriggerGithubPullRequest(
            string branch,
            string? commentControl)
        {
            Branch = branch;
            CommentControl = commentControl;
        }
    }

    [OutputType]
    public sealed class TriggerGithubPush
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Regex of branches to match.  Specify only one of branch or tag.
        /// </summary>
        public readonly string? Branch;
        /// <summary>
        /// -
        /// (Optional)
        /// Regex of tags to match.  Specify only one of branch or tag.
        /// </summary>
        public readonly string? Tag;

        [OutputConstructor]
        private TriggerGithubPush(
            string? branch,
            string? tag)
        {
            Branch = branch;
            Tag = tag;
        }
    }

    [OutputType]
    public sealed class TriggerTriggerTemplate
    {
        /// <summary>
        /// -
        /// (Optional)
        /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
        /// This field is a regular expression.
        /// </summary>
        public readonly string? BranchName;
        /// <summary>
        /// -
        /// (Optional)
        /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
        /// </summary>
        public readonly string? CommitSha;
        /// <summary>
        /// -
        /// (Optional)
        /// Working directory to use when running this step's container.
        /// If this value is a relative path, it is relative to the build's working
        /// directory. If this value is absolute, it may be outside the build's working
        /// directory, in which case the contents of the path may not be persisted
        /// across build step executions, unless a `volume` for that path is specified.
        /// If the build specifies a `RepoSource` with `dir` and a step with a
        /// `dir`,
        /// which specifies an absolute path, the `RepoSource` `dir` is ignored
        /// for the step's execution.
        /// </summary>
        public readonly string? Dir;
        /// <summary>
        /// -
        /// (Optional)
        /// ID of the project that owns the Cloud Source Repository. If
        /// omitted, the project ID requesting the build is assumed.
        /// </summary>
        public readonly string ProjectId;
        /// <summary>
        /// -
        /// (Optional)
        /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
        /// </summary>
        public readonly string? RepoName;
        /// <summary>
        /// -
        /// (Optional)
        /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
        /// This field is a regular expression.
        /// </summary>
        public readonly string? TagName;

        [OutputConstructor]
        private TriggerTriggerTemplate(
            string? branchName,
            string? commitSha,
            string? dir,
            string projectId,
            string? repoName,
            string? tagName)
        {
            BranchName = branchName;
            CommitSha = commitSha;
            Dir = dir;
            ProjectId = projectId;
            RepoName = repoName;
            TagName = tagName;
        }
    }
    }
}
