# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Optional, Tuple, Union
from .. import _utilities, _tables
from . import outputs

__all__ = [
    'ManagedZoneDnssecConfig',
    'ManagedZoneDnssecConfigDefaultKeySpec',
    'ManagedZoneForwardingConfig',
    'ManagedZoneForwardingConfigTargetNameServer',
    'ManagedZonePeeringConfig',
    'ManagedZonePeeringConfigTargetNetwork',
    'ManagedZonePrivateVisibilityConfig',
    'ManagedZonePrivateVisibilityConfigNetwork',
    'ManagedZoneServiceDirectoryConfig',
    'ManagedZoneServiceDirectoryConfigNamespace',
    'PolicyAlternativeNameServerConfig',
    'PolicyAlternativeNameServerConfigTargetNameServer',
    'PolicyNetwork',
    'GetKeysKeySigningKey',
    'GetKeysKeySigningKeyDigest',
    'GetKeysZoneSigningKey',
    'GetKeysZoneSigningKeyDigest',
]

@pulumi.output_type
class ManagedZoneDnssecConfig(dict):
    default_key_specs: Optional[List['outputs.ManagedZoneDnssecConfigDefaultKeySpec']] = pulumi.output_property("defaultKeySpecs")
    """
    Specifies parameters that will be used for generating initial DnsKeys
    for this ManagedZone. If you provide a spec for keySigning or zoneSigning,
    you must also provide one for the other.
    default_key_specs can only be updated when the state is `off`.  Structure is documented below.
    """
    kind: Optional[str] = pulumi.output_property("kind")
    """
    Identifies what kind of resource this is
    """
    non_existence: Optional[str] = pulumi.output_property("nonExistence")
    """
    Specifies the mechanism used to provide authenticated denial-of-existence responses.
    non_existence can only be updated when the state is `off`.
    """
    state: Optional[str] = pulumi.output_property("state")
    """
    Specifies whether DNSSEC is enabled, and what mode it is in
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZoneDnssecConfigDefaultKeySpec(dict):
    algorithm: Optional[str] = pulumi.output_property("algorithm")
    """
    String mnemonic specifying the DNSSEC algorithm of this key
    """
    key_length: Optional[float] = pulumi.output_property("keyLength")
    """
    Length of the keys in bits
    """
    key_type: Optional[str] = pulumi.output_property("keyType")
    """
    Specifies whether this is a key signing key (KSK) or a zone
    signing key (ZSK). Key signing keys have the Secure Entry
    Point flag set and, when active, will only be used to sign
    resource record sets of type DNSKEY. Zone signing keys do
    not have the Secure Entry Point flag set and will be used
    to sign all other types of resource record sets.
    """
    kind: Optional[str] = pulumi.output_property("kind")
    """
    Identifies what kind of resource this is
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZoneForwardingConfig(dict):
    target_name_servers: List['outputs.ManagedZoneForwardingConfigTargetNameServer'] = pulumi.output_property("targetNameServers")
    """
    List of target name servers to forward to. Cloud DNS will
    select the best available name server if more than
    one target is given.  Structure is documented below.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZoneForwardingConfigTargetNameServer(dict):
    forwarding_path: Optional[str] = pulumi.output_property("forwardingPath")
    """
    Forwarding path for this TargetNameServer. If unset or `default` Cloud DNS will make forwarding
    decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
    to the Internet. When set to `private`, Cloud DNS will always send queries through VPC for this target
    """
    ipv4_address: str = pulumi.output_property("ipv4Address")
    """
    IPv4 address of a target name server.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZonePeeringConfig(dict):
    target_network: 'outputs.ManagedZonePeeringConfigTargetNetwork' = pulumi.output_property("targetNetwork")
    """
    The network with which to peer.  Structure is documented below.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZonePeeringConfigTargetNetwork(dict):
    network_url: str = pulumi.output_property("networkUrl")
    """
    The id or fully qualified URL of the VPC network to forward queries to.
    This should be formatted like `projects/{project}/global/networks/{network}` or
    `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZonePrivateVisibilityConfig(dict):
    networks: List['outputs.ManagedZonePrivateVisibilityConfigNetwork'] = pulumi.output_property("networks")
    """
    The list of VPC networks that can see this zone. Structure is documented below.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZonePrivateVisibilityConfigNetwork(dict):
    network_url: str = pulumi.output_property("networkUrl")
    """
    The id or fully qualified URL of the VPC network to forward queries to.
    This should be formatted like `projects/{project}/global/networks/{network}` or
    `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZoneServiceDirectoryConfig(dict):
    namespace: 'outputs.ManagedZoneServiceDirectoryConfigNamespace' = pulumi.output_property("namespace")
    """
    The namespace associated with the zone.  Structure is documented below.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedZoneServiceDirectoryConfigNamespace(dict):
    namespace_url: str = pulumi.output_property("namespaceUrl")
    """
    The fully qualified or partial URL of the service directory namespace that should be
    associated with the zone. This should be formatted like
    `https://servicedirectory.googleapis.com/v1/projects/{project}/locations/{location}/namespaces/{namespace_id}`
    or simply `projects/{project}/locations/{location}/namespaces/{namespace_id}`
    Ignored for `public` visibility zones.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PolicyAlternativeNameServerConfig(dict):
    target_name_servers: List['outputs.PolicyAlternativeNameServerConfigTargetNameServer'] = pulumi.output_property("targetNameServers")
    """
    Sets an alternative name server for the associated networks. When specified,
    all DNS queries are forwarded to a name server that you choose. Names such as .internal
    are not available when an alternative name server is specified.  Structure is documented below.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PolicyAlternativeNameServerConfigTargetNameServer(dict):
    ipv4_address: str = pulumi.output_property("ipv4Address")
    """
    IPv4 address to forward to.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PolicyNetwork(dict):
    network_url: str = pulumi.output_property("networkUrl")
    """
    The id or fully qualified URL of the VPC network to forward queries to.
    This should be formatted like `projects/{project}/global/networks/{network}` or
    `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetKeysKeySigningKey(dict):
    algorithm: str = pulumi.output_property("algorithm")
    """
    String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
    """
    creation_time: str = pulumi.output_property("creationTime")
    """
    The time that this resource was created in the control plane. This is in RFC3339 text format.
    """
    description: str = pulumi.output_property("description")
    """
    A mutable string of at most 1024 characters associated with this resource for the user's convenience.
    """
    digests: List['outputs.GetKeysKeySigningKeyDigest'] = pulumi.output_property("digests")
    """
    A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
    - `digest` - The base-16 encoded bytes of this digest. Suitable for use in a DS resource record.
    - `type` - Specifies the algorithm used to calculate this digest. Possible values are `sha1`, `sha256` and `sha384`
    """
    ds_record: str = pulumi.output_property("dsRecord")
    """
    The DS record based on the KSK record. This is used when [delegating](https://cloud.google.com/dns/docs/dnssec-advanced#subdelegation) DNSSEC-signed subdomains.
    """
    id: str = pulumi.output_property("id")
    """
    Unique identifier for the resource; defined by the server.
    """
    is_active: bool = pulumi.output_property("isActive")
    """
    Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
    """
    key_length: float = pulumi.output_property("keyLength")
    """
    Length of the key in bits. Specified at creation time then immutable.
    """
    key_tag: float = pulumi.output_property("keyTag")
    """
    The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone's DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
    """
    public_key: str = pulumi.output_property("publicKey")
    """
    Base64 encoded public half of this key.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetKeysKeySigningKeyDigest(dict):
    digest: Optional[str] = pulumi.output_property("digest")
    type: Optional[str] = pulumi.output_property("type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetKeysZoneSigningKey(dict):
    algorithm: str = pulumi.output_property("algorithm")
    """
    String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
    """
    creation_time: str = pulumi.output_property("creationTime")
    """
    The time that this resource was created in the control plane. This is in RFC3339 text format.
    """
    description: str = pulumi.output_property("description")
    """
    A mutable string of at most 1024 characters associated with this resource for the user's convenience.
    """
    digests: List['outputs.GetKeysZoneSigningKeyDigest'] = pulumi.output_property("digests")
    """
    A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
    - `digest` - The base-16 encoded bytes of this digest. Suitable for use in a DS resource record.
    - `type` - Specifies the algorithm used to calculate this digest. Possible values are `sha1`, `sha256` and `sha384`
    """
    id: str = pulumi.output_property("id")
    """
    Unique identifier for the resource; defined by the server.
    """
    is_active: bool = pulumi.output_property("isActive")
    """
    Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
    """
    key_length: float = pulumi.output_property("keyLength")
    """
    Length of the key in bits. Specified at creation time then immutable.
    """
    key_tag: float = pulumi.output_property("keyTag")
    """
    The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone's DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
    """
    public_key: str = pulumi.output_property("publicKey")
    """
    Base64 encoded public half of this key.
    """

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetKeysZoneSigningKeyDigest(dict):
    digest: Optional[str] = pulumi.output_property("digest")
    type: Optional[str] = pulumi.output_property("type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


