# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Optional, Tuple, Union
from .. import _utilities, _tables
from ._inputs import *
from . import outputs

@pulumi.input_type
class BillingAccountSinkBigqueryOptionsArgs:
    use_partitioned_tables: pulumi.Input[bool] = pulumi.input_property("usePartitionedTables")
    """
    Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
    By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
    tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
    has to be used instead. In both cases, tables are sharded based on UTC timezone.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, use_partitioned_tables: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[bool] use_partitioned_tables: Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
               By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
               tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
               has to be used instead. In both cases, tables are sharded based on UTC timezone.
        """
        __self__.use_partitioned_tables = use_partitioned_tables

@pulumi.input_type
class FolderSinkBigqueryOptionsArgs:
    use_partitioned_tables: pulumi.Input[bool] = pulumi.input_property("usePartitionedTables")
    """
    Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
    By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
    tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
    has to be used instead. In both cases, tables are sharded based on UTC timezone.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, use_partitioned_tables: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[bool] use_partitioned_tables: Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
               By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
               tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
               has to be used instead. In both cases, tables are sharded based on UTC timezone.
        """
        __self__.use_partitioned_tables = use_partitioned_tables

@pulumi.input_type
class MetricBucketOptionsArgs:
    explicit_buckets: Optional[pulumi.Input['MetricBucketOptionsExplicitBucketsArgs']] = pulumi.input_property("explicitBuckets")
    """
    Specifies a set of buckets with arbitrary widths.  Structure is documented below.
    """
    exponential_buckets: Optional[pulumi.Input['MetricBucketOptionsExponentialBucketsArgs']] = pulumi.input_property("exponentialBuckets")
    """
    Specifies an exponential sequence of buckets that have a width that is proportional to the value of
    the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.  Structure is documented below.
    """
    linear_buckets: Optional[pulumi.Input['MetricBucketOptionsLinearBucketsArgs']] = pulumi.input_property("linearBuckets")
    """
    Specifies a linear sequence of buckets that all have the same width (except overflow and underflow).
    Each bucket represents a constant absolute uncertainty on the specific value in the bucket.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, explicit_buckets: Optional[pulumi.Input['MetricBucketOptionsExplicitBucketsArgs']] = None, exponential_buckets: Optional[pulumi.Input['MetricBucketOptionsExponentialBucketsArgs']] = None, linear_buckets: Optional[pulumi.Input['MetricBucketOptionsLinearBucketsArgs']] = None) -> None:
        """
        :param pulumi.Input['MetricBucketOptionsExplicitBucketsArgs'] explicit_buckets: Specifies a set of buckets with arbitrary widths.  Structure is documented below.
        :param pulumi.Input['MetricBucketOptionsExponentialBucketsArgs'] exponential_buckets: Specifies an exponential sequence of buckets that have a width that is proportional to the value of
               the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.  Structure is documented below.
        :param pulumi.Input['MetricBucketOptionsLinearBucketsArgs'] linear_buckets: Specifies a linear sequence of buckets that all have the same width (except overflow and underflow).
               Each bucket represents a constant absolute uncertainty on the specific value in the bucket.  Structure is documented below.
        """
        __self__.explicit_buckets = explicit_buckets
        __self__.exponential_buckets = exponential_buckets
        __self__.linear_buckets = linear_buckets

@pulumi.input_type
class MetricBucketOptionsExplicitBucketsArgs:
    bounds: pulumi.Input[List[pulumi.Input[float]]] = pulumi.input_property("bounds")
    """
    The values must be monotonically increasing.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, bounds: pulumi.Input[List[pulumi.Input[float]]]) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[float]]] bounds: The values must be monotonically increasing.
        """
        __self__.bounds = bounds

@pulumi.input_type
class MetricBucketOptionsExponentialBucketsArgs:
    growth_factor: Optional[pulumi.Input[float]] = pulumi.input_property("growthFactor")
    """
    Must be greater than 1.
    """
    num_finite_buckets: Optional[pulumi.Input[float]] = pulumi.input_property("numFiniteBuckets")
    """
    Must be greater than 0.
    """
    scale: Optional[pulumi.Input[float]] = pulumi.input_property("scale")
    """
    Must be greater than 0.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, growth_factor: Optional[pulumi.Input[float]] = None, num_finite_buckets: Optional[pulumi.Input[float]] = None, scale: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] growth_factor: Must be greater than 1.
        :param pulumi.Input[float] num_finite_buckets: Must be greater than 0.
        :param pulumi.Input[float] scale: Must be greater than 0.
        """
        __self__.growth_factor = growth_factor
        __self__.num_finite_buckets = num_finite_buckets
        __self__.scale = scale

@pulumi.input_type
class MetricBucketOptionsLinearBucketsArgs:
    num_finite_buckets: Optional[pulumi.Input[float]] = pulumi.input_property("numFiniteBuckets")
    """
    Must be greater than 0.
    """
    offset: Optional[pulumi.Input[float]] = pulumi.input_property("offset")
    """
    Lower bound of the first bucket.
    """
    width: Optional[pulumi.Input[float]] = pulumi.input_property("width")
    """
    Must be greater than 0.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, num_finite_buckets: Optional[pulumi.Input[float]] = None, offset: Optional[pulumi.Input[float]] = None, width: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] num_finite_buckets: Must be greater than 0.
        :param pulumi.Input[float] offset: Lower bound of the first bucket.
        :param pulumi.Input[float] width: Must be greater than 0.
        """
        __self__.num_finite_buckets = num_finite_buckets
        __self__.offset = offset
        __self__.width = width

@pulumi.input_type
class MetricMetricDescriptorArgs:
    metric_kind: pulumi.Input[str] = pulumi.input_property("metricKind")
    """
    Whether the metric records instantaneous values, changes to a value, etc.
    Some combinations of metricKind and valueType might not be supported.
    For counter metrics, set this to DELTA.
    """
    value_type: pulumi.Input[str] = pulumi.input_property("valueType")
    """
    The type of data that can be assigned to the label.
    """
    display_name: Optional[pulumi.Input[str]] = pulumi.input_property("displayName")
    """
    A concise name for the metric, which can be displayed in user interfaces. Use sentence case
    without an ending period, for example "Request count". This field is optional but it is
    recommended to be set for any metrics associated with user-visible concepts, such as Quota.
    """
    labels: Optional[pulumi.Input[List[pulumi.Input['MetricMetricDescriptorLabelArgs']]]] = pulumi.input_property("labels")
    """
    The set of labels that can be used to describe a specific instance of this metric type. For
    example, the appengine.googleapis.com/http/server/response_latencies metric type has a label
    for the HTTP response code, response_code, so you can look at latencies for successful responses
    or just for responses that failed.  Structure is documented below.
    """
    unit: Optional[pulumi.Input[str]] = pulumi.input_property("unit")
    """
    The unit in which the metric value is reported. It is only applicable if the valueType is
    `INT64`, `DOUBLE`, or `DISTRIBUTION`. The supported units are a subset of
    [The Unified Code for Units of Measure](http://unitsofmeasure.org/ucum.html) standard
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, metric_kind: pulumi.Input[str], value_type: pulumi.Input[str], display_name: Optional[pulumi.Input[str]] = None, labels: Optional[pulumi.Input[List[pulumi.Input['MetricMetricDescriptorLabelArgs']]]] = None, unit: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] metric_kind: Whether the metric records instantaneous values, changes to a value, etc.
               Some combinations of metricKind and valueType might not be supported.
               For counter metrics, set this to DELTA.
        :param pulumi.Input[str] value_type: The type of data that can be assigned to the label.
        :param pulumi.Input[str] display_name: A concise name for the metric, which can be displayed in user interfaces. Use sentence case
               without an ending period, for example "Request count". This field is optional but it is
               recommended to be set for any metrics associated with user-visible concepts, such as Quota.
        :param pulumi.Input[List[pulumi.Input['MetricMetricDescriptorLabelArgs']]] labels: The set of labels that can be used to describe a specific instance of this metric type. For
               example, the appengine.googleapis.com/http/server/response_latencies metric type has a label
               for the HTTP response code, response_code, so you can look at latencies for successful responses
               or just for responses that failed.  Structure is documented below.
        :param pulumi.Input[str] unit: The unit in which the metric value is reported. It is only applicable if the valueType is
               `INT64`, `DOUBLE`, or `DISTRIBUTION`. The supported units are a subset of
               [The Unified Code for Units of Measure](http://unitsofmeasure.org/ucum.html) standard
        """
        __self__.metric_kind = metric_kind
        __self__.value_type = value_type
        __self__.display_name = display_name
        __self__.labels = labels
        __self__.unit = unit

@pulumi.input_type
class MetricMetricDescriptorLabelArgs:
    key: pulumi.Input[str] = pulumi.input_property("key")
    """
    The label key.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    A description of this metric, which is used in documentation. The maximum length of the
    description is 8000 characters.
    """
    value_type: Optional[pulumi.Input[str]] = pulumi.input_property("valueType")
    """
    The type of data that can be assigned to the label.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, key: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None, value_type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] description: A description of this metric, which is used in documentation. The maximum length of the
               description is 8000 characters.
        :param pulumi.Input[str] value_type: The type of data that can be assigned to the label.
        """
        __self__.key = key
        __self__.description = description
        __self__.value_type = value_type

@pulumi.input_type
class OrganizationSinkBigqueryOptionsArgs:
    use_partitioned_tables: pulumi.Input[bool] = pulumi.input_property("usePartitionedTables")
    """
    Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
    By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
    tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
    has to be used instead. In both cases, tables are sharded based on UTC timezone.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, use_partitioned_tables: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[bool] use_partitioned_tables: Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
               By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
               tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
               has to be used instead. In both cases, tables are sharded based on UTC timezone.
        """
        __self__.use_partitioned_tables = use_partitioned_tables

@pulumi.input_type
class ProjectSinkBigqueryOptionsArgs:
    use_partitioned_tables: pulumi.Input[bool] = pulumi.input_property("usePartitionedTables")
    """
    Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
    By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
    tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
    has to be used instead. In both cases, tables are sharded based on UTC timezone.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, use_partitioned_tables: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[bool] use_partitioned_tables: Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
               By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
               tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
               has to be used instead. In both cases, tables are sharded based on UTC timezone.
        """
        __self__.use_partitioned_tables = use_partitioned_tables

