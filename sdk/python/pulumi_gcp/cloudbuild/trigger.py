# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Optional, Tuple, Union
from .. import _utilities, _tables
from . import outputs
from ._inputs import *

__all__ = ['Trigger']


class Trigger(pulumi.CustomResource):
    build: pulumi.Output[Optional['outputs.TriggerBuild']] = pulumi.output_property("build")
    """
    Contents of the build template. Either a filename or build template must be provided.  Structure is documented below.
    """
    create_time: pulumi.Output[str] = pulumi.output_property("createTime")
    """
    Time when the trigger was created.
    """
    description: pulumi.Output[Optional[str]] = pulumi.output_property("description")
    """
    Human-readable description of the trigger.
    """
    disabled: pulumi.Output[Optional[bool]] = pulumi.output_property("disabled")
    """
    Whether the trigger is disabled or not. If true, the trigger will never result in a build.
    """
    filename: pulumi.Output[Optional[str]] = pulumi.output_property("filename")
    """
    Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
    """
    github: pulumi.Output[Optional['outputs.TriggerGithub']] = pulumi.output_property("github")
    """
    Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
    One of `trigger_template` or `github` must be provided.  Structure is documented below.
    """
    ignored_files: pulumi.Output[Optional[List[str]]] = pulumi.output_property("ignoredFiles")
    """
    ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    extended with support for `**`.
    If ignoredFiles and changed files are both empty, then they are not
    used to determine whether or not to trigger a build.
    If ignoredFiles is not empty, then we ignore any files that match any
    of the ignored_file globs. If the change has no files that are outside
    of the ignoredFiles globs, then we do not trigger a build.
    """
    included_files: pulumi.Output[Optional[List[str]]] = pulumi.output_property("includedFiles")
    """
    ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    extended with support for `**`.
    If any of the files altered in the commit pass the ignoredFiles filter
    and includedFiles is empty, then as far as this filter is concerned, we
    should trigger the build.
    If any of the files altered in the commit pass the ignoredFiles filter
    and includedFiles is not empty, then we make sure that at least one of
    those files matches a includedFiles glob. If not, then we do not trigger
    a build.
    """
    name: pulumi.Output[str] = pulumi.output_property("name")
    """
    Name of the volume to mount.
    Volume names must be unique per build step and must be valid names for
    Docker volumes. Each named volume must be used by at least two build steps.
    """
    project: pulumi.Output[str] = pulumi.output_property("project")
    """
    The ID of the project in which the resource belongs.
    If it is not provided, the provider project is used.
    """
    substitutions: pulumi.Output[Optional[Dict[str, str]]] = pulumi.output_property("substitutions")
    """
    Substitutions data for Build resource.
    """
    trigger_id: pulumi.Output[str] = pulumi.output_property("triggerId")
    """
    The unique identifier for the trigger.
    """
    trigger_template: pulumi.Output[Optional['outputs.TriggerTriggerTemplate']] = pulumi.output_property("triggerTemplate")
    """
    Template describing the types of source changes to trigger a build.
    Branch and tag names in trigger templates are interpreted as regular
    expressions. Any branch or tag change that matches that regular
    expression will trigger a build.
    One of `trigger_template` or `github` must be provided.  Structure is documented below.
    """
    # pylint: disable=no-self-argument
    def __init__(__self__, resource_name, opts: Optional[pulumi.ResourceOptions] = None, build: Optional[pulumi.Input[pulumi.InputType['TriggerBuildArgs']]] = None, description: Optional[pulumi.Input[str]] = None, disabled: Optional[pulumi.Input[bool]] = None, filename: Optional[pulumi.Input[str]] = None, github: Optional[pulumi.Input[pulumi.InputType['TriggerGithubArgs']]] = None, ignored_files: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, included_files: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, name: Optional[pulumi.Input[str]] = None, project: Optional[pulumi.Input[str]] = None, substitutions: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = None, trigger_template: Optional[pulumi.Input[pulumi.InputType['TriggerTriggerTemplateArgs']]] = None, __props__=None, __name__=None, __opts__=None) -> None:
        """
        Configuration for an automated build in response to source repository changes.

        To get more information about Trigger, see:

        * [API documentation](https://cloud.google.com/cloud-build/docs/api/reference/rest/)
        * How-to Guides
            * [Automating builds using build triggers](https://cloud.google.com/cloud-build/docs/running-builds/automate-builds)

        ## Example Usage
        ### Cloudbuild Trigger Filename

        ```python
        import pulumi
        import pulumi_gcp as gcp

        filename_trigger = gcp.cloudbuild.Trigger("filename-trigger",
            filename="cloudbuild.yaml",
            substitutions={
                "_BAZ": "qux",
                "_FOO": "bar",
            },
            trigger_template={
                "branchName": "master",
                "repoName": "my-repo",
            })
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[pulumi.InputType['TriggerBuildArgs']] build: Contents of the build template. Either a filename or build template must be provided.  Structure is documented below.
        :param pulumi.Input[str] description: Human-readable description of the trigger.
        :param pulumi.Input[bool] disabled: Whether the trigger is disabled or not. If true, the trigger will never result in a build.
        :param pulumi.Input[str] filename: Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
        :param pulumi.Input[pulumi.InputType['TriggerGithubArgs']] github: Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
               One of `trigger_template` or `github` must be provided.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] ignored_files: ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
               extended with support for `**`.
               If ignoredFiles and changed files are both empty, then they are not
               used to determine whether or not to trigger a build.
               If ignoredFiles is not empty, then we ignore any files that match any
               of the ignored_file globs. If the change has no files that are outside
               of the ignoredFiles globs, then we do not trigger a build.
        :param pulumi.Input[List[pulumi.Input[str]]] included_files: ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
               extended with support for `**`.
               If any of the files altered in the commit pass the ignoredFiles filter
               and includedFiles is empty, then as far as this filter is concerned, we
               should trigger the build.
               If any of the files altered in the commit pass the ignoredFiles filter
               and includedFiles is not empty, then we make sure that at least one of
               those files matches a includedFiles glob. If not, then we do not trigger
               a build.
        :param pulumi.Input[str] name: Name of the volume to mount.
               Volume names must be unique per build step and must be valid names for
               Docker volumes. Each named volume must be used by at least two build steps.
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] substitutions: Substitutions data for Build resource.
        :param pulumi.Input[pulumi.InputType['TriggerTriggerTemplateArgs']] trigger_template: Template describing the types of source changes to trigger a build.
               Branch and tag names in trigger templates are interpreted as regular
               expressions. Any branch or tag change that matches that regular
               expression will trigger a build.
               One of `trigger_template` or `github` must be provided.  Structure is documented below.
        """
        if __name__ is not None:
            warnings.warn("explicit use of __name__ is deprecated", DeprecationWarning)
            resource_name = __name__
        if __opts__ is not None:
            warnings.warn("explicit use of __opts__ is deprecated, use 'opts' instead", DeprecationWarning)
            opts = __opts__
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = _utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = dict()

            __props__['build'] = build
            __props__['description'] = description
            __props__['disabled'] = disabled
            __props__['filename'] = filename
            __props__['github'] = github
            __props__['ignored_files'] = ignored_files
            __props__['included_files'] = included_files
            __props__['name'] = name
            __props__['project'] = project
            __props__['substitutions'] = substitutions
            __props__['trigger_template'] = trigger_template
            __props__['create_time'] = None
            __props__['trigger_id'] = None
        super(Trigger, __self__).__init__(
            'gcp:cloudbuild/trigger:Trigger',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str, id: str, opts: Optional[pulumi.ResourceOptions] = None, build: Optional[pulumi.Input[pulumi.InputType['TriggerBuildArgs']]] = None, create_time: Optional[pulumi.Input[str]] = None, description: Optional[pulumi.Input[str]] = None, disabled: Optional[pulumi.Input[bool]] = None, filename: Optional[pulumi.Input[str]] = None, github: Optional[pulumi.Input[pulumi.InputType['TriggerGithubArgs']]] = None, ignored_files: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, included_files: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, name: Optional[pulumi.Input[str]] = None, project: Optional[pulumi.Input[str]] = None, substitutions: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = None, trigger_id: Optional[pulumi.Input[str]] = None, trigger_template: Optional[pulumi.Input[pulumi.InputType['TriggerTriggerTemplateArgs']]] = None) -> 'Trigger':
        """
        Get an existing Trigger resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param str id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[pulumi.InputType['TriggerBuildArgs']] build: Contents of the build template. Either a filename or build template must be provided.  Structure is documented below.
        :param pulumi.Input[str] create_time: Time when the trigger was created.
        :param pulumi.Input[str] description: Human-readable description of the trigger.
        :param pulumi.Input[bool] disabled: Whether the trigger is disabled or not. If true, the trigger will never result in a build.
        :param pulumi.Input[str] filename: Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
        :param pulumi.Input[pulumi.InputType['TriggerGithubArgs']] github: Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
               One of `trigger_template` or `github` must be provided.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] ignored_files: ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
               extended with support for `**`.
               If ignoredFiles and changed files are both empty, then they are not
               used to determine whether or not to trigger a build.
               If ignoredFiles is not empty, then we ignore any files that match any
               of the ignored_file globs. If the change has no files that are outside
               of the ignoredFiles globs, then we do not trigger a build.
        :param pulumi.Input[List[pulumi.Input[str]]] included_files: ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
               extended with support for `**`.
               If any of the files altered in the commit pass the ignoredFiles filter
               and includedFiles is empty, then as far as this filter is concerned, we
               should trigger the build.
               If any of the files altered in the commit pass the ignoredFiles filter
               and includedFiles is not empty, then we make sure that at least one of
               those files matches a includedFiles glob. If not, then we do not trigger
               a build.
        :param pulumi.Input[str] name: Name of the volume to mount.
               Volume names must be unique per build step and must be valid names for
               Docker volumes. Each named volume must be used by at least two build steps.
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] substitutions: Substitutions data for Build resource.
        :param pulumi.Input[str] trigger_id: The unique identifier for the trigger.
        :param pulumi.Input[pulumi.InputType['TriggerTriggerTemplateArgs']] trigger_template: Template describing the types of source changes to trigger a build.
               Branch and tag names in trigger templates are interpreted as regular
               expressions. Any branch or tag change that matches that regular
               expression will trigger a build.
               One of `trigger_template` or `github` must be provided.  Structure is documented below.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = dict()

        __props__["build"] = build
        __props__["create_time"] = create_time
        __props__["description"] = description
        __props__["disabled"] = disabled
        __props__["filename"] = filename
        __props__["github"] = github
        __props__["ignored_files"] = ignored_files
        __props__["included_files"] = included_files
        __props__["name"] = name
        __props__["project"] = project
        __props__["substitutions"] = substitutions
        __props__["trigger_id"] = trigger_id
        __props__["trigger_template"] = trigger_template
        return Trigger(resource_name, opts=opts, __props__=__props__)

    def translate_output_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop):
        return _tables.SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop

