# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Optional, Tuple, Union
from .. import _utilities, _tables

@pulumi.input_type
class AlertPolicyConditionArgs:
    display_name: pulumi.Input[str] = pulumi.input_property("displayName")
    """
    A short name or phrase used to identify the
    condition in dashboards, notifications, and
    incidents. To avoid confusion, don't use the same
    display name for multiple conditions in the same
    policy.
    """
    condition_absent: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentArgs']] = pulumi.input_property("conditionAbsent")
    """
    A condition that checks that a time series
    continues to receive new data points.  Structure is documented below.
    """
    condition_threshold: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdArgs']] = pulumi.input_property("conditionThreshold")
    """
    A condition that compares a time series against a
    threshold.  Structure is documented below.
    """
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    -
    The unique resource name for this condition.
    Its syntax is:
    projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
    [CONDITION_ID] is assigned by Stackdriver Monitoring when
    the condition is created as part of a new or updated alerting
    policy.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, display_name: pulumi.Input[str], condition_absent: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentArgs']] = None, condition_threshold: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdArgs']] = None, name: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] display_name: A short name or phrase used to identify the
               condition in dashboards, notifications, and
               incidents. To avoid confusion, don't use the same
               display name for multiple conditions in the same
               policy.
        :param pulumi.Input['AlertPolicyConditionConditionAbsentArgs'] condition_absent: A condition that checks that a time series
               continues to receive new data points.  Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionThresholdArgs'] condition_threshold: A condition that compares a time series against a
               threshold.  Structure is documented below.
        :param pulumi.Input[str] name: -
               The unique resource name for this condition.
               Its syntax is:
               projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
               [CONDITION_ID] is assigned by Stackdriver Monitoring when
               the condition is created as part of a new or updated alerting
               policy.
        """
        __self__.display_name = display_name
        __self__.condition_absent = condition_absent
        __self__.condition_threshold = condition_threshold
        __self__.name = name

@pulumi.input_type
class AlertPolicyConditionConditionAbsentArgs:
    duration: pulumi.Input[str] = pulumi.input_property("duration")
    """
    The amount of time that a time series must
    violate the threshold to be considered
    failing. Currently, only values that are a
    multiple of a minute--e.g., 0, 60, 120, or
    300 seconds--are supported. If an invalid
    value is given, an error will be returned.
    When choosing a duration, it is useful to
    keep in mind the frequency of the underlying
    time series data (which may also be affected
    by any alignments specified in the
    aggregations field); a good duration is long
    enough so that a single outlier does not
    generate spurious alerts, but short enough
    that unhealthy states are detected and
    alerted on quickly.
    """
    aggregations: Optional[pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgs']]]] = pulumi.input_property("aggregations")
    """
    Specifies the alignment of data points in
    individual time series as well as how to
    combine the retrieved time series together
    (such as when aggregating multiple streams
    on each resource to a single stream for each
    resource or when aggregating streams across
    all members of a group of resources).
    Multiple aggregations are applied in the
    order specified.This field is similar to the
    one in the MetricService.ListTimeSeries
    request. It is advisable to use the
    ListTimeSeries method when debugging this
    field.  Structure is documented below.
    """
    filter: Optional[pulumi.Input[str]] = pulumi.input_property("filter")
    """
    A filter that identifies which time series
    should be compared with the threshold.The
    filter is similar to the one that is
    specified in the
    MetricService.ListTimeSeries request (that
    call is useful to verify the time series
    that will be retrieved / processed) and must
    specify the metric type and optionally may
    contain restrictions on resource type,
    resource labels, and metric labels. This
    field may not exceed 2048 Unicode characters
    in length.
    """
    trigger: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgs']] = pulumi.input_property("trigger")
    """
    The number/percent of time series for which
    the comparison must hold in order for the
    condition to trigger. If unspecified, then
    the condition will trigger if the comparison
    is true for any of the time series that have
    been identified by filter and aggregations,
    or by the ratio, if denominator_filter and
    denominator_aggregations are specified.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, duration: pulumi.Input[str], aggregations: Optional[pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgs']]]] = None, filter: Optional[pulumi.Input[str]] = None, trigger: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgs']] = None) -> None:
        """
        :param pulumi.Input[str] duration: The amount of time that a time series must
               violate the threshold to be considered
               failing. Currently, only values that are a
               multiple of a minute--e.g., 0, 60, 120, or
               300 seconds--are supported. If an invalid
               value is given, an error will be returned.
               When choosing a duration, it is useful to
               keep in mind the frequency of the underlying
               time series data (which may also be affected
               by any alignments specified in the
               aggregations field); a good duration is long
               enough so that a single outlier does not
               generate spurious alerts, but short enough
               that unhealthy states are detected and
               alerted on quickly.
        :param pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgs']]] aggregations: Specifies the alignment of data points in
               individual time series as well as how to
               combine the retrieved time series together
               (such as when aggregating multiple streams
               on each resource to a single stream for each
               resource or when aggregating streams across
               all members of a group of resources).
               Multiple aggregations are applied in the
               order specified.This field is similar to the
               one in the MetricService.ListTimeSeries
               request. It is advisable to use the
               ListTimeSeries method when debugging this
               field.  Structure is documented below.
        :param pulumi.Input[str] filter: A filter that identifies which time series
               should be compared with the threshold.The
               filter is similar to the one that is
               specified in the
               MetricService.ListTimeSeries request (that
               call is useful to verify the time series
               that will be retrieved / processed) and must
               specify the metric type and optionally may
               contain restrictions on resource type,
               resource labels, and metric labels. This
               field may not exceed 2048 Unicode characters
               in length.
        :param pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgs'] trigger: The number/percent of time series for which
               the comparison must hold in order for the
               condition to trigger. If unspecified, then
               the condition will trigger if the comparison
               is true for any of the time series that have
               been identified by filter and aggregations,
               or by the ratio, if denominator_filter and
               denominator_aggregations are specified.  Structure is documented below.
        """
        __self__.duration = duration
        __self__.aggregations = aggregations
        __self__.filter = filter
        __self__.trigger = trigger

@pulumi.input_type
class AlertPolicyConditionConditionAbsentAggregationArgs:
    alignment_period: Optional[pulumi.Input[str]] = pulumi.input_property("alignmentPeriod")
    """
    The alignment period for per-time
    series alignment. If present,
    alignmentPeriod must be at least
    60 seconds. After per-time series
    alignment, each time series will
    contain data points only on the
    period boundaries. If
    perSeriesAligner is not specified
    or equals ALIGN_NONE, then this
    field is ignored. If
    perSeriesAligner is specified and
    does not equal ALIGN_NONE, then
    this field must be defined;
    otherwise an error is returned.
    """
    cross_series_reducer: Optional[pulumi.Input[str]] = pulumi.input_property("crossSeriesReducer")
    """
    The approach to be used to combine
    time series. Not all reducer
    functions may be applied to all
    time series, depending on the
    metric type and the value type of
    the original time series.
    Reduction may change the metric
    type of value type of the time
    series.Time series data must be
    aligned in order to perform cross-
    time series reduction. If
    crossSeriesReducer is specified,
    then perSeriesAligner must be
    specified and not equal ALIGN_NONE
    and alignmentPeriod must be
    specified; otherwise, an error is
    returned.
    """
    group_by_fields: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("groupByFields")
    """
    The set of fields to preserve when
    crossSeriesReducer is specified.
    The groupByFields determine how
    the time series are partitioned
    into subsets prior to applying the
    aggregation function. Each subset
    contains time series that have the
    same value for each of the
    grouping fields. Each individual
    time series is a member of exactly
    one subset. The crossSeriesReducer
    is applied to each subset of time
    series. It is not possible to
    reduce across different resource
    types, so this field implicitly
    contains resource.type. Fields not
    specified in groupByFields are
    aggregated away. If groupByFields
    is not specified and all the time
    series have the same resource
    type, then the time series are
    aggregated into a single output
    time series. If crossSeriesReducer
    is not defined, this field is
    ignored.
    """
    per_series_aligner: Optional[pulumi.Input[str]] = pulumi.input_property("perSeriesAligner")
    """
    The approach to be used to align
    individual time series. Not all
    alignment functions may be applied
    to all time series, depending on
    the metric type and value type of
    the original time series.
    Alignment may change the metric
    type or the value type of the time
    series.Time series data must be
    aligned in order to perform cross-
    time series reduction. If
    crossSeriesReducer is specified,
    then perSeriesAligner must be
    specified and not equal ALIGN_NONE
    and alignmentPeriod must be
    specified; otherwise, an error is
    returned.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, alignment_period: Optional[pulumi.Input[str]] = None, cross_series_reducer: Optional[pulumi.Input[str]] = None, group_by_fields: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, per_series_aligner: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] alignment_period: The alignment period for per-time
               series alignment. If present,
               alignmentPeriod must be at least
               60 seconds. After per-time series
               alignment, each time series will
               contain data points only on the
               period boundaries. If
               perSeriesAligner is not specified
               or equals ALIGN_NONE, then this
               field is ignored. If
               perSeriesAligner is specified and
               does not equal ALIGN_NONE, then
               this field must be defined;
               otherwise an error is returned.
        :param pulumi.Input[str] cross_series_reducer: The approach to be used to combine
               time series. Not all reducer
               functions may be applied to all
               time series, depending on the
               metric type and the value type of
               the original time series.
               Reduction may change the metric
               type of value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
        :param pulumi.Input[List[pulumi.Input[str]]] group_by_fields: The set of fields to preserve when
               crossSeriesReducer is specified.
               The groupByFields determine how
               the time series are partitioned
               into subsets prior to applying the
               aggregation function. Each subset
               contains time series that have the
               same value for each of the
               grouping fields. Each individual
               time series is a member of exactly
               one subset. The crossSeriesReducer
               is applied to each subset of time
               series. It is not possible to
               reduce across different resource
               types, so this field implicitly
               contains resource.type. Fields not
               specified in groupByFields are
               aggregated away. If groupByFields
               is not specified and all the time
               series have the same resource
               type, then the time series are
               aggregated into a single output
               time series. If crossSeriesReducer
               is not defined, this field is
               ignored.
        :param pulumi.Input[str] per_series_aligner: The approach to be used to align
               individual time series. Not all
               alignment functions may be applied
               to all time series, depending on
               the metric type and value type of
               the original time series.
               Alignment may change the metric
               type or the value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
        """
        __self__.alignment_period = alignment_period
        __self__.cross_series_reducer = cross_series_reducer
        __self__.group_by_fields = group_by_fields
        __self__.per_series_aligner = per_series_aligner

@pulumi.input_type
class AlertPolicyConditionConditionAbsentTriggerArgs:
    count: Optional[pulumi.Input[float]] = pulumi.input_property("count")
    """
    The absolute number of time series
    that must fail the predicate for the
    condition to be triggered.
    """
    percent: Optional[pulumi.Input[float]] = pulumi.input_property("percent")
    """
    The percentage of time series that
    must fail the predicate for the
    condition to be triggered.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, count: Optional[pulumi.Input[float]] = None, percent: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] count: The absolute number of time series
               that must fail the predicate for the
               condition to be triggered.
        :param pulumi.Input[float] percent: The percentage of time series that
               must fail the predicate for the
               condition to be triggered.
        """
        __self__.count = count
        __self__.percent = percent

@pulumi.input_type
class AlertPolicyConditionConditionThresholdArgs:
    comparison: pulumi.Input[str] = pulumi.input_property("comparison")
    """
    The comparison to apply between the time
    series (indicated by filter and aggregation)
    and the threshold (indicated by
    threshold_value). The comparison is applied
    on each time series, with the time series on
    the left-hand side and the threshold on the
    right-hand side. Only COMPARISON_LT and
    COMPARISON_GT are supported currently.
    """
    duration: pulumi.Input[str] = pulumi.input_property("duration")
    """
    The amount of time that a time series must
    violate the threshold to be considered
    failing. Currently, only values that are a
    multiple of a minute--e.g., 0, 60, 120, or
    300 seconds--are supported. If an invalid
    value is given, an error will be returned.
    When choosing a duration, it is useful to
    keep in mind the frequency of the underlying
    time series data (which may also be affected
    by any alignments specified in the
    aggregations field); a good duration is long
    enough so that a single outlier does not
    generate spurious alerts, but short enough
    that unhealthy states are detected and
    alerted on quickly.
    """
    aggregations: Optional[pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgs']]]] = pulumi.input_property("aggregations")
    """
    Specifies the alignment of data points in
    individual time series as well as how to
    combine the retrieved time series together
    (such as when aggregating multiple streams
    on each resource to a single stream for each
    resource or when aggregating streams across
    all members of a group of resources).
    Multiple aggregations are applied in the
    order specified.This field is similar to the
    one in the MetricService.ListTimeSeries
    request. It is advisable to use the
    ListTimeSeries method when debugging this
    field.  Structure is documented below.
    """
    denominator_aggregations: Optional[pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgs']]]] = pulumi.input_property("denominatorAggregations")
    """
    Specifies the alignment of data points in
    individual time series selected by
    denominatorFilter as well as how to combine
    the retrieved time series together (such as
    when aggregating multiple streams on each
    resource to a single stream for each
    resource or when aggregating streams across
    all members of a group of resources).When
    computing ratios, the aggregations and
    denominator_aggregations fields must use the
    same alignment period and produce time
    series that have the same periodicity and
    labels.This field is similar to the one in
    the MetricService.ListTimeSeries request. It
    is advisable to use the ListTimeSeries
    method when debugging this field.  Structure is documented below.
    """
    denominator_filter: Optional[pulumi.Input[str]] = pulumi.input_property("denominatorFilter")
    """
    A filter that identifies a time series that
    should be used as the denominator of a ratio
    that will be compared with the threshold. If
    a denominator_filter is specified, the time
    series specified by the filter field will be
    used as the numerator.The filter is similar
    to the one that is specified in the
    MetricService.ListTimeSeries request (that
    call is useful to verify the time series
    that will be retrieved / processed) and must
    specify the metric type and optionally may
    contain restrictions on resource type,
    resource labels, and metric labels. This
    field may not exceed 2048 Unicode characters
    in length.
    """
    filter: Optional[pulumi.Input[str]] = pulumi.input_property("filter")
    """
    A filter that identifies which time series
    should be compared with the threshold.The
    filter is similar to the one that is
    specified in the
    MetricService.ListTimeSeries request (that
    call is useful to verify the time series
    that will be retrieved / processed) and must
    specify the metric type and optionally may
    contain restrictions on resource type,
    resource labels, and metric labels. This
    field may not exceed 2048 Unicode characters
    in length.
    """
    threshold_value: Optional[pulumi.Input[float]] = pulumi.input_property("thresholdValue")
    """
    A value against which to compare the time
    series.
    """
    trigger: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgs']] = pulumi.input_property("trigger")
    """
    The number/percent of time series for which
    the comparison must hold in order for the
    condition to trigger. If unspecified, then
    the condition will trigger if the comparison
    is true for any of the time series that have
    been identified by filter and aggregations,
    or by the ratio, if denominator_filter and
    denominator_aggregations are specified.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, comparison: pulumi.Input[str], duration: pulumi.Input[str], aggregations: Optional[pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgs']]]] = None, denominator_aggregations: Optional[pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgs']]]] = None, denominator_filter: Optional[pulumi.Input[str]] = None, filter: Optional[pulumi.Input[str]] = None, threshold_value: Optional[pulumi.Input[float]] = None, trigger: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgs']] = None) -> None:
        """
        :param pulumi.Input[str] comparison: The comparison to apply between the time
               series (indicated by filter and aggregation)
               and the threshold (indicated by
               threshold_value). The comparison is applied
               on each time series, with the time series on
               the left-hand side and the threshold on the
               right-hand side. Only COMPARISON_LT and
               COMPARISON_GT are supported currently.
        :param pulumi.Input[str] duration: The amount of time that a time series must
               violate the threshold to be considered
               failing. Currently, only values that are a
               multiple of a minute--e.g., 0, 60, 120, or
               300 seconds--are supported. If an invalid
               value is given, an error will be returned.
               When choosing a duration, it is useful to
               keep in mind the frequency of the underlying
               time series data (which may also be affected
               by any alignments specified in the
               aggregations field); a good duration is long
               enough so that a single outlier does not
               generate spurious alerts, but short enough
               that unhealthy states are detected and
               alerted on quickly.
        :param pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgs']]] aggregations: Specifies the alignment of data points in
               individual time series as well as how to
               combine the retrieved time series together
               (such as when aggregating multiple streams
               on each resource to a single stream for each
               resource or when aggregating streams across
               all members of a group of resources).
               Multiple aggregations are applied in the
               order specified.This field is similar to the
               one in the MetricService.ListTimeSeries
               request. It is advisable to use the
               ListTimeSeries method when debugging this
               field.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgs']]] denominator_aggregations: Specifies the alignment of data points in
               individual time series selected by
               denominatorFilter as well as how to combine
               the retrieved time series together (such as
               when aggregating multiple streams on each
               resource to a single stream for each
               resource or when aggregating streams across
               all members of a group of resources).When
               computing ratios, the aggregations and
               denominator_aggregations fields must use the
               same alignment period and produce time
               series that have the same periodicity and
               labels.This field is similar to the one in
               the MetricService.ListTimeSeries request. It
               is advisable to use the ListTimeSeries
               method when debugging this field.  Structure is documented below.
        :param pulumi.Input[str] denominator_filter: A filter that identifies a time series that
               should be used as the denominator of a ratio
               that will be compared with the threshold. If
               a denominator_filter is specified, the time
               series specified by the filter field will be
               used as the numerator.The filter is similar
               to the one that is specified in the
               MetricService.ListTimeSeries request (that
               call is useful to verify the time series
               that will be retrieved / processed) and must
               specify the metric type and optionally may
               contain restrictions on resource type,
               resource labels, and metric labels. This
               field may not exceed 2048 Unicode characters
               in length.
        :param pulumi.Input[str] filter: A filter that identifies which time series
               should be compared with the threshold.The
               filter is similar to the one that is
               specified in the
               MetricService.ListTimeSeries request (that
               call is useful to verify the time series
               that will be retrieved / processed) and must
               specify the metric type and optionally may
               contain restrictions on resource type,
               resource labels, and metric labels. This
               field may not exceed 2048 Unicode characters
               in length.
        :param pulumi.Input[float] threshold_value: A value against which to compare the time
               series.
        :param pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgs'] trigger: The number/percent of time series for which
               the comparison must hold in order for the
               condition to trigger. If unspecified, then
               the condition will trigger if the comparison
               is true for any of the time series that have
               been identified by filter and aggregations,
               or by the ratio, if denominator_filter and
               denominator_aggregations are specified.  Structure is documented below.
        """
        __self__.comparison = comparison
        __self__.duration = duration
        __self__.aggregations = aggregations
        __self__.denominator_aggregations = denominator_aggregations
        __self__.denominator_filter = denominator_filter
        __self__.filter = filter
        __self__.threshold_value = threshold_value
        __self__.trigger = trigger

@pulumi.input_type
class AlertPolicyConditionConditionThresholdAggregationArgs:
    alignment_period: Optional[pulumi.Input[str]] = pulumi.input_property("alignmentPeriod")
    """
    The alignment period for per-time
    series alignment. If present,
    alignmentPeriod must be at least
    60 seconds. After per-time series
    alignment, each time series will
    contain data points only on the
    period boundaries. If
    perSeriesAligner is not specified
    or equals ALIGN_NONE, then this
    field is ignored. If
    perSeriesAligner is specified and
    does not equal ALIGN_NONE, then
    this field must be defined;
    otherwise an error is returned.
    """
    cross_series_reducer: Optional[pulumi.Input[str]] = pulumi.input_property("crossSeriesReducer")
    """
    The approach to be used to combine
    time series. Not all reducer
    functions may be applied to all
    time series, depending on the
    metric type and the value type of
    the original time series.
    Reduction may change the metric
    type of value type of the time
    series.Time series data must be
    aligned in order to perform cross-
    time series reduction. If
    crossSeriesReducer is specified,
    then perSeriesAligner must be
    specified and not equal ALIGN_NONE
    and alignmentPeriod must be
    specified; otherwise, an error is
    returned.
    """
    group_by_fields: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("groupByFields")
    """
    The set of fields to preserve when
    crossSeriesReducer is specified.
    The groupByFields determine how
    the time series are partitioned
    into subsets prior to applying the
    aggregation function. Each subset
    contains time series that have the
    same value for each of the
    grouping fields. Each individual
    time series is a member of exactly
    one subset. The crossSeriesReducer
    is applied to each subset of time
    series. It is not possible to
    reduce across different resource
    types, so this field implicitly
    contains resource.type. Fields not
    specified in groupByFields are
    aggregated away. If groupByFields
    is not specified and all the time
    series have the same resource
    type, then the time series are
    aggregated into a single output
    time series. If crossSeriesReducer
    is not defined, this field is
    ignored.
    """
    per_series_aligner: Optional[pulumi.Input[str]] = pulumi.input_property("perSeriesAligner")
    """
    The approach to be used to align
    individual time series. Not all
    alignment functions may be applied
    to all time series, depending on
    the metric type and value type of
    the original time series.
    Alignment may change the metric
    type or the value type of the time
    series.Time series data must be
    aligned in order to perform cross-
    time series reduction. If
    crossSeriesReducer is specified,
    then perSeriesAligner must be
    specified and not equal ALIGN_NONE
    and alignmentPeriod must be
    specified; otherwise, an error is
    returned.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, alignment_period: Optional[pulumi.Input[str]] = None, cross_series_reducer: Optional[pulumi.Input[str]] = None, group_by_fields: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, per_series_aligner: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] alignment_period: The alignment period for per-time
               series alignment. If present,
               alignmentPeriod must be at least
               60 seconds. After per-time series
               alignment, each time series will
               contain data points only on the
               period boundaries. If
               perSeriesAligner is not specified
               or equals ALIGN_NONE, then this
               field is ignored. If
               perSeriesAligner is specified and
               does not equal ALIGN_NONE, then
               this field must be defined;
               otherwise an error is returned.
        :param pulumi.Input[str] cross_series_reducer: The approach to be used to combine
               time series. Not all reducer
               functions may be applied to all
               time series, depending on the
               metric type and the value type of
               the original time series.
               Reduction may change the metric
               type of value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
        :param pulumi.Input[List[pulumi.Input[str]]] group_by_fields: The set of fields to preserve when
               crossSeriesReducer is specified.
               The groupByFields determine how
               the time series are partitioned
               into subsets prior to applying the
               aggregation function. Each subset
               contains time series that have the
               same value for each of the
               grouping fields. Each individual
               time series is a member of exactly
               one subset. The crossSeriesReducer
               is applied to each subset of time
               series. It is not possible to
               reduce across different resource
               types, so this field implicitly
               contains resource.type. Fields not
               specified in groupByFields are
               aggregated away. If groupByFields
               is not specified and all the time
               series have the same resource
               type, then the time series are
               aggregated into a single output
               time series. If crossSeriesReducer
               is not defined, this field is
               ignored.
        :param pulumi.Input[str] per_series_aligner: The approach to be used to align
               individual time series. Not all
               alignment functions may be applied
               to all time series, depending on
               the metric type and value type of
               the original time series.
               Alignment may change the metric
               type or the value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
        """
        __self__.alignment_period = alignment_period
        __self__.cross_series_reducer = cross_series_reducer
        __self__.group_by_fields = group_by_fields
        __self__.per_series_aligner = per_series_aligner

@pulumi.input_type
class AlertPolicyConditionConditionThresholdDenominatorAggregationArgs:
    alignment_period: Optional[pulumi.Input[str]] = pulumi.input_property("alignmentPeriod")
    """
    The alignment period for per-time
    series alignment. If present,
    alignmentPeriod must be at least
    60 seconds. After per-time series
    alignment, each time series will
    contain data points only on the
    period boundaries. If
    perSeriesAligner is not specified
    or equals ALIGN_NONE, then this
    field is ignored. If
    perSeriesAligner is specified and
    does not equal ALIGN_NONE, then
    this field must be defined;
    otherwise an error is returned.
    """
    cross_series_reducer: Optional[pulumi.Input[str]] = pulumi.input_property("crossSeriesReducer")
    """
    The approach to be used to combine
    time series. Not all reducer
    functions may be applied to all
    time series, depending on the
    metric type and the value type of
    the original time series.
    Reduction may change the metric
    type of value type of the time
    series.Time series data must be
    aligned in order to perform cross-
    time series reduction. If
    crossSeriesReducer is specified,
    then perSeriesAligner must be
    specified and not equal ALIGN_NONE
    and alignmentPeriod must be
    specified; otherwise, an error is
    returned.
    """
    group_by_fields: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("groupByFields")
    """
    The set of fields to preserve when
    crossSeriesReducer is specified.
    The groupByFields determine how
    the time series are partitioned
    into subsets prior to applying the
    aggregation function. Each subset
    contains time series that have the
    same value for each of the
    grouping fields. Each individual
    time series is a member of exactly
    one subset. The crossSeriesReducer
    is applied to each subset of time
    series. It is not possible to
    reduce across different resource
    types, so this field implicitly
    contains resource.type. Fields not
    specified in groupByFields are
    aggregated away. If groupByFields
    is not specified and all the time
    series have the same resource
    type, then the time series are
    aggregated into a single output
    time series. If crossSeriesReducer
    is not defined, this field is
    ignored.
    """
    per_series_aligner: Optional[pulumi.Input[str]] = pulumi.input_property("perSeriesAligner")
    """
    The approach to be used to align
    individual time series. Not all
    alignment functions may be applied
    to all time series, depending on
    the metric type and value type of
    the original time series.
    Alignment may change the metric
    type or the value type of the time
    series.Time series data must be
    aligned in order to perform cross-
    time series reduction. If
    crossSeriesReducer is specified,
    then perSeriesAligner must be
    specified and not equal ALIGN_NONE
    and alignmentPeriod must be
    specified; otherwise, an error is
    returned.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, alignment_period: Optional[pulumi.Input[str]] = None, cross_series_reducer: Optional[pulumi.Input[str]] = None, group_by_fields: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, per_series_aligner: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] alignment_period: The alignment period for per-time
               series alignment. If present,
               alignmentPeriod must be at least
               60 seconds. After per-time series
               alignment, each time series will
               contain data points only on the
               period boundaries. If
               perSeriesAligner is not specified
               or equals ALIGN_NONE, then this
               field is ignored. If
               perSeriesAligner is specified and
               does not equal ALIGN_NONE, then
               this field must be defined;
               otherwise an error is returned.
        :param pulumi.Input[str] cross_series_reducer: The approach to be used to combine
               time series. Not all reducer
               functions may be applied to all
               time series, depending on the
               metric type and the value type of
               the original time series.
               Reduction may change the metric
               type of value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
        :param pulumi.Input[List[pulumi.Input[str]]] group_by_fields: The set of fields to preserve when
               crossSeriesReducer is specified.
               The groupByFields determine how
               the time series are partitioned
               into subsets prior to applying the
               aggregation function. Each subset
               contains time series that have the
               same value for each of the
               grouping fields. Each individual
               time series is a member of exactly
               one subset. The crossSeriesReducer
               is applied to each subset of time
               series. It is not possible to
               reduce across different resource
               types, so this field implicitly
               contains resource.type. Fields not
               specified in groupByFields are
               aggregated away. If groupByFields
               is not specified and all the time
               series have the same resource
               type, then the time series are
               aggregated into a single output
               time series. If crossSeriesReducer
               is not defined, this field is
               ignored.
        :param pulumi.Input[str] per_series_aligner: The approach to be used to align
               individual time series. Not all
               alignment functions may be applied
               to all time series, depending on
               the metric type and value type of
               the original time series.
               Alignment may change the metric
               type or the value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
        """
        __self__.alignment_period = alignment_period
        __self__.cross_series_reducer = cross_series_reducer
        __self__.group_by_fields = group_by_fields
        __self__.per_series_aligner = per_series_aligner

@pulumi.input_type
class AlertPolicyConditionConditionThresholdTriggerArgs:
    count: Optional[pulumi.Input[float]] = pulumi.input_property("count")
    """
    The absolute number of time series
    that must fail the predicate for the
    condition to be triggered.
    """
    percent: Optional[pulumi.Input[float]] = pulumi.input_property("percent")
    """
    The percentage of time series that
    must fail the predicate for the
    condition to be triggered.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, count: Optional[pulumi.Input[float]] = None, percent: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] count: The absolute number of time series
               that must fail the predicate for the
               condition to be triggered.
        :param pulumi.Input[float] percent: The percentage of time series that
               must fail the predicate for the
               condition to be triggered.
        """
        __self__.count = count
        __self__.percent = percent

@pulumi.input_type
class AlertPolicyCreationRecordArgs:
    mutate_time: Optional[pulumi.Input[str]] = pulumi.input_property("mutateTime")
    mutated_by: Optional[pulumi.Input[str]] = pulumi.input_property("mutatedBy")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, mutate_time: Optional[pulumi.Input[str]] = None, mutated_by: Optional[pulumi.Input[str]] = None) -> None:
        __self__.mutate_time = mutate_time
        __self__.mutated_by = mutated_by

@pulumi.input_type
class AlertPolicyDocumentationArgs:
    content: Optional[pulumi.Input[str]] = pulumi.input_property("content")
    """
    The text of the documentation, interpreted according to mimeType.
    The content may not exceed 8,192 Unicode characters and may not
    exceed more than 10,240 bytes when encoded in UTF-8 format,
    whichever is smaller.
    """
    mime_type: Optional[pulumi.Input[str]] = pulumi.input_property("mimeType")
    """
    The format of the content field. Presently, only the value
    "text/markdown" is supported.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, content: Optional[pulumi.Input[str]] = None, mime_type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] content: The text of the documentation, interpreted according to mimeType.
               The content may not exceed 8,192 Unicode characters and may not
               exceed more than 10,240 bytes when encoded in UTF-8 format,
               whichever is smaller.
        :param pulumi.Input[str] mime_type: The format of the content field. Presently, only the value
               "text/markdown" is supported.
        """
        __self__.content = content
        __self__.mime_type = mime_type

@pulumi.input_type
class CustomServiceTelemetryArgs:
    resource_name: Optional[pulumi.Input[str]] = pulumi.input_property("resourceName")
    """
    The full name of the resource that defines this service.
    Formatted as described in
    https://cloud.google.com/apis/design/resource_names.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, resource_name: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] resource_name: The full name of the resource that defines this service.
               Formatted as described in
               https://cloud.google.com/apis/design/resource_names.
        """
        __self__.resource_name = resource_name

@pulumi.input_type
class NotificationChannelSensitiveLabelsArgs:
    auth_token: Optional[pulumi.Input[str]] = pulumi.input_property("authToken")
    """
    An authorization token for a notification channel. Channel types that support this field include: slack  **Note**: This property is sensitive and will not be displayed in the plan.
    """
    password: Optional[pulumi.Input[str]] = pulumi.input_property("password")
    """
    An password for a notification channel. Channel types that support this field include: webhook_basicauth  **Note**: This property is sensitive and will not be displayed in the plan.
    """
    service_key: Optional[pulumi.Input[str]] = pulumi.input_property("serviceKey")
    """
    An servicekey token for a notification channel. Channel types that support this field include: pagerduty  **Note**: This property is sensitive and will not be displayed in the plan.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, auth_token: Optional[pulumi.Input[str]] = None, password: Optional[pulumi.Input[str]] = None, service_key: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] auth_token: An authorization token for a notification channel. Channel types that support this field include: slack  **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] password: An password for a notification channel. Channel types that support this field include: webhook_basicauth  **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] service_key: An servicekey token for a notification channel. Channel types that support this field include: pagerduty  **Note**: This property is sensitive and will not be displayed in the plan.
        """
        __self__.auth_token = auth_token
        __self__.password = password
        __self__.service_key = service_key

@pulumi.input_type
class SloBasicSliArgs:
    latency: pulumi.Input['SloBasicSliLatencyArgs'] = pulumi.input_property("latency")
    """
    Parameters for a latency threshold SLI.  Structure is documented below.
    """
    locations: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("locations")
    """
    An optional set of locations to which this SLI is relevant.
    Telemetry from other locations will not be used to calculate
    performance for this SLI. If omitted, this SLI applies to all
    locations in which the Service has activity. For service types
    that don't support breaking down by location, setting this
    field will result in an error.
    """
    methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("methods")
    """
    An optional set of RPCs to which this SLI is relevant.
    Telemetry from other methods will not be used to calculate
    performance for this SLI. If omitted, this SLI applies to all
    the Service's methods. For service types that don't support
    breaking down by method, setting this field will result in an
    error.
    """
    versions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("versions")
    """
    The set of API versions to which this SLI is relevant.
    Telemetry from other API versions will not be used to
    calculate performance for this SLI. If omitted,
    this SLI applies to all API versions. For service types
    that don't support breaking down by version, setting this
    field will result in an error.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, latency: pulumi.Input['SloBasicSliLatencyArgs'], locations: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, versions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input['SloBasicSliLatencyArgs'] latency: Parameters for a latency threshold SLI.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] locations: An optional set of locations to which this SLI is relevant.
               Telemetry from other locations will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               locations in which the Service has activity. For service types
               that don't support breaking down by location, setting this
               field will result in an error.
        :param pulumi.Input[List[pulumi.Input[str]]] methods: An optional set of RPCs to which this SLI is relevant.
               Telemetry from other methods will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               the Service's methods. For service types that don't support
               breaking down by method, setting this field will result in an
               error.
        :param pulumi.Input[List[pulumi.Input[str]]] versions: The set of API versions to which this SLI is relevant.
               Telemetry from other API versions will not be used to
               calculate performance for this SLI. If omitted,
               this SLI applies to all API versions. For service types
               that don't support breaking down by version, setting this
               field will result in an error.
        """
        __self__.latency = latency
        __self__.locations = locations
        __self__.methods = methods
        __self__.versions = versions

@pulumi.input_type
class SloBasicSliLatencyArgs:
    threshold: pulumi.Input[str] = pulumi.input_property("threshold")
    """
    A duration string, e.g. 10s.
    Good service is defined to be the count of requests made to
    this service that return in no more than threshold.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, threshold: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] threshold: A duration string, e.g. 10s.
               Good service is defined to be the count of requests made to
               this service that return in no more than threshold.
        """
        __self__.threshold = threshold

@pulumi.input_type
class SloRequestBasedSliArgs:
    distribution_cut: Optional[pulumi.Input['SloRequestBasedSliDistributionCutArgs']] = pulumi.input_property("distributionCut")
    """
    Used when good_service is defined by a count of values aggregated in a
    Distribution that fall into a good range. The total_service is the
    total count of all values aggregated in the Distribution.
    Defines a distribution TimeSeries filter and thresholds used for
    measuring good service and total service.  Structure is documented below.
    """
    good_total_ratio: Optional[pulumi.Input['SloRequestBasedSliGoodTotalRatioArgs']] = pulumi.input_property("goodTotalRatio")
    """
    A means to compute a ratio of `good_service` to `total_service`.
    Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
    Must specify exactly two of good, bad, and total service filters.
    The relationship good_service + bad_service = total_service
    will be assumed.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, distribution_cut: Optional[pulumi.Input['SloRequestBasedSliDistributionCutArgs']] = None, good_total_ratio: Optional[pulumi.Input['SloRequestBasedSliGoodTotalRatioArgs']] = None) -> None:
        """
        :param pulumi.Input['SloRequestBasedSliDistributionCutArgs'] distribution_cut: Used when good_service is defined by a count of values aggregated in a
               Distribution that fall into a good range. The total_service is the
               total count of all values aggregated in the Distribution.
               Defines a distribution TimeSeries filter and thresholds used for
               measuring good service and total service.  Structure is documented below.
        :param pulumi.Input['SloRequestBasedSliGoodTotalRatioArgs'] good_total_ratio: A means to compute a ratio of `good_service` to `total_service`.
               Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
               Must specify exactly two of good, bad, and total service filters.
               The relationship good_service + bad_service = total_service
               will be assumed.  Structure is documented below.
        """
        __self__.distribution_cut = distribution_cut
        __self__.good_total_ratio = good_total_ratio

@pulumi.input_type
class SloRequestBasedSliDistributionCutArgs:
    distribution_filter: pulumi.Input[str] = pulumi.input_property("distributionFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    aggregating values to quantify the good service provided.
    Must have ValueType = DISTRIBUTION and
    MetricKind = DELTA or MetricKind = CUMULATIVE.
    """
    range: pulumi.Input['SloRequestBasedSliDistributionCutRangeArgs'] = pulumi.input_property("range")
    """
    Range of numerical values. The computed good_service
    will be the count of values x in the Distribution such
    that range.min <= x < range.max. inclusive of min and
    exclusive of max. Open ranges can be defined by setting
    just one of min or max. Summed value `X` should satisfy
    `range.min <= X < range.max` for a good window.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, distribution_filter: pulumi.Input[str], range: pulumi.Input['SloRequestBasedSliDistributionCutRangeArgs']) -> None:
        """
        :param pulumi.Input[str] distribution_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               aggregating values to quantify the good service provided.
               Must have ValueType = DISTRIBUTION and
               MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input['SloRequestBasedSliDistributionCutRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x < range.max. inclusive of min and
               exclusive of max. Open ranges can be defined by setting
               just one of min or max. Summed value `X` should satisfy
               `range.min <= X < range.max` for a good window.  Structure is documented below.
        """
        __self__.distribution_filter = distribution_filter
        __self__.range = range

@pulumi.input_type
class SloRequestBasedSliDistributionCutRangeArgs:
    max: Optional[pulumi.Input[float]] = pulumi.input_property("max")
    """
    max value for the range (inclusive). If not given,
    will be set to "infinity", defining an open range
    ">= range.min"
    """
    min: Optional[pulumi.Input[float]] = pulumi.input_property("min")
    """
    Min value for the range (inclusive). If not given,
    will be set to "-infinity", defining an open range
    "< range.max"
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max: Optional[pulumi.Input[float]] = None, min: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        __self__.max = max
        __self__.min = min

@pulumi.input_type
class SloRequestBasedSliGoodTotalRatioArgs:
    bad_service_filter: Optional[pulumi.Input[str]] = pulumi.input_property("badServiceFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    quantifying bad service provided, either demanded service that
    was not provided or demanded service that was of inadequate
    quality. Exactly two of
    good, bad, or total service filter must be defined (where
    good + bad = total is assumed)
    Must have ValueType = DOUBLE or ValueType = INT64 and
    must have MetricKind = DELTA or MetricKind = CUMULATIVE.
    """
    good_service_filter: Optional[pulumi.Input[str]] = pulumi.input_property("goodServiceFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    quantifying good service provided. Exactly two of
    good, bad, or total service filter must be defined (where
    good + bad = total is assumed)
    Must have ValueType = DOUBLE or ValueType = INT64 and
    must have MetricKind = DELTA or MetricKind = CUMULATIVE.
    """
    total_service_filter: Optional[pulumi.Input[str]] = pulumi.input_property("totalServiceFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    quantifying total demanded service. Exactly two of
    good, bad, or total service filter must be defined (where
    good + bad = total is assumed)
    Must have ValueType = DOUBLE or ValueType = INT64 and
    must have MetricKind = DELTA or MetricKind = CUMULATIVE.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, bad_service_filter: Optional[pulumi.Input[str]] = None, good_service_filter: Optional[pulumi.Input[str]] = None, total_service_filter: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] bad_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying bad service provided, either demanded service that
               was not provided or demanded service that was of inadequate
               quality. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] good_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying good service provided. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] total_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying total demanded service. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        __self__.bad_service_filter = bad_service_filter
        __self__.good_service_filter = good_service_filter
        __self__.total_service_filter = total_service_filter

@pulumi.input_type
class SloWindowsBasedSliArgs:
    good_bad_metric_filter: Optional[pulumi.Input[str]] = pulumi.input_property("goodBadMetricFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    with ValueType = BOOL. The window is good if any true values
    appear in the window. One of `good_bad_metric_filter`,
    `good_total_ratio_threshold`, `metric_mean_in_range`,
    `metric_sum_in_range` must be set for `windows_based_sli`.
    """
    good_total_ratio_threshold: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgs']] = pulumi.input_property("goodTotalRatioThreshold")
    """
    Criterion that describes a window as good if its performance is
    high enough. One of `good_bad_metric_filter`,
    `good_total_ratio_threshold`, `metric_mean_in_range`,
    `metric_sum_in_range` must be set for `windows_based_sli`.  Structure is documented below.
    """
    metric_mean_in_range: Optional[pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgs']] = pulumi.input_property("metricMeanInRange")
    """
    Criterion that describes a window as good if the metric's value
    is in a good range, *averaged* across returned streams.
    One of `good_bad_metric_filter`,
    `good_total_ratio_threshold`, `metric_mean_in_range`,
    `metric_sum_in_range` must be set for `windows_based_sli`.
    Average value X of `time_series` should satisfy
    `range.min <= X < range.max` for a good window.  Structure is documented below.
    """
    metric_sum_in_range: Optional[pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgs']] = pulumi.input_property("metricSumInRange")
    """
    Criterion that describes a window as good if the metric's value
    is in a good range, *summed* across returned streams.
    Summed value `X` of `time_series` should satisfy
    `range.min <= X < range.max` for a good window.
    One of `good_bad_metric_filter`,
    `good_total_ratio_threshold`, `metric_mean_in_range`,
    `metric_sum_in_range` must be set for `windows_based_sli`.  Structure is documented below.
    """
    window_period: Optional[pulumi.Input[str]] = pulumi.input_property("windowPeriod")
    """
    Duration over which window quality is evaluated, given as a
    duration string "{X}s" representing X seconds. Must be an
    integer fraction of a day and at least 60s.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, good_bad_metric_filter: Optional[pulumi.Input[str]] = None, good_total_ratio_threshold: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgs']] = None, metric_mean_in_range: Optional[pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgs']] = None, metric_sum_in_range: Optional[pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgs']] = None, window_period: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] good_bad_metric_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               with ValueType = BOOL. The window is good if any true values
               appear in the window. One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgs'] good_total_ratio_threshold: Criterion that describes a window as good if its performance is
               high enough. One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.  Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgs'] metric_mean_in_range: Criterion that describes a window as good if the metric's value
               is in a good range, *averaged* across returned streams.
               One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.
               Average value X of `time_series` should satisfy
               `range.min <= X < range.max` for a good window.  Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgs'] metric_sum_in_range: Criterion that describes a window as good if the metric's value
               is in a good range, *summed* across returned streams.
               Summed value `X` of `time_series` should satisfy
               `range.min <= X < range.max` for a good window.
               One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.  Structure is documented below.
        :param pulumi.Input[str] window_period: Duration over which window quality is evaluated, given as a
               duration string "{X}s" representing X seconds. Must be an
               integer fraction of a day and at least 60s.
        """
        __self__.good_bad_metric_filter = good_bad_metric_filter
        __self__.good_total_ratio_threshold = good_total_ratio_threshold
        __self__.metric_mean_in_range = metric_mean_in_range
        __self__.metric_sum_in_range = metric_sum_in_range
        __self__.window_period = window_period

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdArgs:
    basic_sli_performance: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs']] = pulumi.input_property("basicSliPerformance")
    """
    Basic SLI to evaluate to judge window quality.  Structure is documented below.
    """
    performance: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs']] = pulumi.input_property("performance")
    """
    Request-based SLI to evaluate to judge window quality.  Structure is documented below.
    """
    threshold: Optional[pulumi.Input[float]] = pulumi.input_property("threshold")
    """
    A duration string, e.g. 10s.
    Good service is defined to be the count of requests made to
    this service that return in no more than threshold.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, basic_sli_performance: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs']] = None, performance: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs']] = None, threshold: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs'] basic_sli_performance: Basic SLI to evaluate to judge window quality.  Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs'] performance: Request-based SLI to evaluate to judge window quality.  Structure is documented below.
        :param pulumi.Input[float] threshold: A duration string, e.g. 10s.
               Good service is defined to be the count of requests made to
               this service that return in no more than threshold.
        """
        __self__.basic_sli_performance = basic_sli_performance
        __self__.performance = performance
        __self__.threshold = threshold

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs:
    latency: pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs'] = pulumi.input_property("latency")
    """
    Parameters for a latency threshold SLI.  Structure is documented below.
    """
    locations: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("locations")
    """
    An optional set of locations to which this SLI is relevant.
    Telemetry from other locations will not be used to calculate
    performance for this SLI. If omitted, this SLI applies to all
    locations in which the Service has activity. For service types
    that don't support breaking down by location, setting this
    field will result in an error.
    """
    methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("methods")
    """
    An optional set of RPCs to which this SLI is relevant.
    Telemetry from other methods will not be used to calculate
    performance for this SLI. If omitted, this SLI applies to all
    the Service's methods. For service types that don't support
    breaking down by method, setting this field will result in an
    error.
    """
    versions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("versions")
    """
    The set of API versions to which this SLI is relevant.
    Telemetry from other API versions will not be used to
    calculate performance for this SLI. If omitted,
    this SLI applies to all API versions. For service types
    that don't support breaking down by version, setting this
    field will result in an error.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, latency: pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs'], locations: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, versions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs'] latency: Parameters for a latency threshold SLI.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] locations: An optional set of locations to which this SLI is relevant.
               Telemetry from other locations will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               locations in which the Service has activity. For service types
               that don't support breaking down by location, setting this
               field will result in an error.
        :param pulumi.Input[List[pulumi.Input[str]]] methods: An optional set of RPCs to which this SLI is relevant.
               Telemetry from other methods will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               the Service's methods. For service types that don't support
               breaking down by method, setting this field will result in an
               error.
        :param pulumi.Input[List[pulumi.Input[str]]] versions: The set of API versions to which this SLI is relevant.
               Telemetry from other API versions will not be used to
               calculate performance for this SLI. If omitted,
               this SLI applies to all API versions. For service types
               that don't support breaking down by version, setting this
               field will result in an error.
        """
        __self__.latency = latency
        __self__.locations = locations
        __self__.methods = methods
        __self__.versions = versions

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs:
    threshold: pulumi.Input[str] = pulumi.input_property("threshold")
    """
    A duration string, e.g. 10s.
    Good service is defined to be the count of requests made to
    this service that return in no more than threshold.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, threshold: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] threshold: A duration string, e.g. 10s.
               Good service is defined to be the count of requests made to
               this service that return in no more than threshold.
        """
        __self__.threshold = threshold

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs:
    distribution_cut: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs']] = pulumi.input_property("distributionCut")
    """
    Used when good_service is defined by a count of values aggregated in a
    Distribution that fall into a good range. The total_service is the
    total count of all values aggregated in the Distribution.
    Defines a distribution TimeSeries filter and thresholds used for
    measuring good service and total service.  Structure is documented below.
    """
    good_total_ratio: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs']] = pulumi.input_property("goodTotalRatio")
    """
    A means to compute a ratio of `good_service` to `total_service`.
    Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
    Must specify exactly two of good, bad, and total service filters.
    The relationship good_service + bad_service = total_service
    will be assumed.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, distribution_cut: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs']] = None, good_total_ratio: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs']] = None) -> None:
        """
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs'] distribution_cut: Used when good_service is defined by a count of values aggregated in a
               Distribution that fall into a good range. The total_service is the
               total count of all values aggregated in the Distribution.
               Defines a distribution TimeSeries filter and thresholds used for
               measuring good service and total service.  Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs'] good_total_ratio: A means to compute a ratio of `good_service` to `total_service`.
               Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
               Must specify exactly two of good, bad, and total service filters.
               The relationship good_service + bad_service = total_service
               will be assumed.  Structure is documented below.
        """
        __self__.distribution_cut = distribution_cut
        __self__.good_total_ratio = good_total_ratio

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs:
    distribution_filter: pulumi.Input[str] = pulumi.input_property("distributionFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    aggregating values to quantify the good service provided.
    Must have ValueType = DISTRIBUTION and
    MetricKind = DELTA or MetricKind = CUMULATIVE.
    """
    range: pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs'] = pulumi.input_property("range")
    """
    Range of numerical values. The computed good_service
    will be the count of values x in the Distribution such
    that range.min <= x < range.max. inclusive of min and
    exclusive of max. Open ranges can be defined by setting
    just one of min or max. Summed value `X` should satisfy
    `range.min <= X < range.max` for a good window.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, distribution_filter: pulumi.Input[str], range: pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs']) -> None:
        """
        :param pulumi.Input[str] distribution_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               aggregating values to quantify the good service provided.
               Must have ValueType = DISTRIBUTION and
               MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x < range.max. inclusive of min and
               exclusive of max. Open ranges can be defined by setting
               just one of min or max. Summed value `X` should satisfy
               `range.min <= X < range.max` for a good window.  Structure is documented below.
        """
        __self__.distribution_filter = distribution_filter
        __self__.range = range

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs:
    max: Optional[pulumi.Input[float]] = pulumi.input_property("max")
    """
    max value for the range (inclusive). If not given,
    will be set to "infinity", defining an open range
    ">= range.min"
    """
    min: Optional[pulumi.Input[float]] = pulumi.input_property("min")
    """
    Min value for the range (inclusive). If not given,
    will be set to "-infinity", defining an open range
    "< range.max"
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max: Optional[pulumi.Input[float]] = None, min: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        __self__.max = max
        __self__.min = min

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs:
    bad_service_filter: Optional[pulumi.Input[str]] = pulumi.input_property("badServiceFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    quantifying bad service provided, either demanded service that
    was not provided or demanded service that was of inadequate
    quality. Exactly two of
    good, bad, or total service filter must be defined (where
    good + bad = total is assumed)
    Must have ValueType = DOUBLE or ValueType = INT64 and
    must have MetricKind = DELTA or MetricKind = CUMULATIVE.
    """
    good_service_filter: Optional[pulumi.Input[str]] = pulumi.input_property("goodServiceFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    quantifying good service provided. Exactly two of
    good, bad, or total service filter must be defined (where
    good + bad = total is assumed)
    Must have ValueType = DOUBLE or ValueType = INT64 and
    must have MetricKind = DELTA or MetricKind = CUMULATIVE.
    """
    total_service_filter: Optional[pulumi.Input[str]] = pulumi.input_property("totalServiceFilter")
    """
    A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    quantifying total demanded service. Exactly two of
    good, bad, or total service filter must be defined (where
    good + bad = total is assumed)
    Must have ValueType = DOUBLE or ValueType = INT64 and
    must have MetricKind = DELTA or MetricKind = CUMULATIVE.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, bad_service_filter: Optional[pulumi.Input[str]] = None, good_service_filter: Optional[pulumi.Input[str]] = None, total_service_filter: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] bad_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying bad service provided, either demanded service that
               was not provided or demanded service that was of inadequate
               quality. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] good_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying good service provided. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] total_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying total demanded service. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        __self__.bad_service_filter = bad_service_filter
        __self__.good_service_filter = good_service_filter
        __self__.total_service_filter = total_service_filter

@pulumi.input_type
class SloWindowsBasedSliMetricMeanInRangeArgs:
    range: pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgs'] = pulumi.input_property("range")
    """
    Range of numerical values. The computed good_service
    will be the count of values x in the Distribution such
    that range.min <= x < range.max. inclusive of min and
    exclusive of max. Open ranges can be defined by setting
    just one of min or max. Summed value `X` should satisfy
    `range.min <= X < range.max` for a good window.  Structure is documented below.
    """
    time_series: pulumi.Input[str] = pulumi.input_property("timeSeries")
    """
    A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    specifying the TimeSeries to use for evaluating window
    quality. The provided TimeSeries must have
    ValueType = INT64 or ValueType = DOUBLE and
    MetricKind = GAUGE.
    Summed value `X` should satisfy
    `range.min <= X < range.max` for a good window.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, range: pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgs'], time_series: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x < range.max. inclusive of min and
               exclusive of max. Open ranges can be defined by setting
               just one of min or max. Summed value `X` should satisfy
               `range.min <= X < range.max` for a good window.  Structure is documented below.
        :param pulumi.Input[str] time_series: A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               specifying the TimeSeries to use for evaluating window
               quality. The provided TimeSeries must have
               ValueType = INT64 or ValueType = DOUBLE and
               MetricKind = GAUGE.
               Summed value `X` should satisfy
               `range.min <= X < range.max` for a good window.
        """
        __self__.range = range
        __self__.time_series = time_series

@pulumi.input_type
class SloWindowsBasedSliMetricMeanInRangeRangeArgs:
    max: Optional[pulumi.Input[float]] = pulumi.input_property("max")
    """
    max value for the range (inclusive). If not given,
    will be set to "infinity", defining an open range
    ">= range.min"
    """
    min: Optional[pulumi.Input[float]] = pulumi.input_property("min")
    """
    Min value for the range (inclusive). If not given,
    will be set to "-infinity", defining an open range
    "< range.max"
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max: Optional[pulumi.Input[float]] = None, min: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        __self__.max = max
        __self__.min = min

@pulumi.input_type
class SloWindowsBasedSliMetricSumInRangeArgs:
    range: pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgs'] = pulumi.input_property("range")
    """
    Range of numerical values. The computed good_service
    will be the count of values x in the Distribution such
    that range.min <= x < range.max. inclusive of min and
    exclusive of max. Open ranges can be defined by setting
    just one of min or max. Summed value `X` should satisfy
    `range.min <= X < range.max` for a good window.  Structure is documented below.
    """
    time_series: pulumi.Input[str] = pulumi.input_property("timeSeries")
    """
    A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    specifying the TimeSeries to use for evaluating window
    quality. The provided TimeSeries must have
    ValueType = INT64 or ValueType = DOUBLE and
    MetricKind = GAUGE.
    Summed value `X` should satisfy
    `range.min <= X < range.max` for a good window.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, range: pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgs'], time_series: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x < range.max. inclusive of min and
               exclusive of max. Open ranges can be defined by setting
               just one of min or max. Summed value `X` should satisfy
               `range.min <= X < range.max` for a good window.  Structure is documented below.
        :param pulumi.Input[str] time_series: A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               specifying the TimeSeries to use for evaluating window
               quality. The provided TimeSeries must have
               ValueType = INT64 or ValueType = DOUBLE and
               MetricKind = GAUGE.
               Summed value `X` should satisfy
               `range.min <= X < range.max` for a good window.
        """
        __self__.range = range
        __self__.time_series = time_series

@pulumi.input_type
class SloWindowsBasedSliMetricSumInRangeRangeArgs:
    max: Optional[pulumi.Input[float]] = pulumi.input_property("max")
    """
    max value for the range (inclusive). If not given,
    will be set to "infinity", defining an open range
    ">= range.min"
    """
    min: Optional[pulumi.Input[float]] = pulumi.input_property("min")
    """
    Min value for the range (inclusive). If not given,
    will be set to "-infinity", defining an open range
    "< range.max"
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max: Optional[pulumi.Input[float]] = None, min: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        __self__.max = max
        __self__.min = min

@pulumi.input_type
class UptimeCheckConfigContentMatcherArgs:
    content: pulumi.Input[str] = pulumi.input_property("content")
    """
    String or regex content to match (max 1024 bytes)
    """
    matcher: Optional[pulumi.Input[str]] = pulumi.input_property("matcher")
    """
    The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, content: pulumi.Input[str], matcher: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] content: String or regex content to match (max 1024 bytes)
        :param pulumi.Input[str] matcher: The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
        """
        __self__.content = content
        __self__.matcher = matcher

@pulumi.input_type
class UptimeCheckConfigHttpCheckArgs:
    auth_info: Optional[pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgs']] = pulumi.input_property("authInfo")
    """
    The authentication information. Optional when creating an HTTP check; defaults to empty.  Structure is documented below.
    """
    body: Optional[pulumi.Input[str]] = pulumi.input_property("body")
    """
    The request body associated with the HTTP POST request. If contentType is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the requestMethod is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
    """
    content_type: Optional[pulumi.Input[str]] = pulumi.input_property("contentType")
    """
    The content type to use for the check.
    """
    headers: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = pulumi.input_property("headers")
    """
    The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
    """
    mask_headers: Optional[pulumi.Input[bool]] = pulumi.input_property("maskHeaders")
    """
    Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to True then the headers will be obscured with ******.
    """
    path: Optional[pulumi.Input[str]] = pulumi.input_property("path")
    """
    The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. Optional (defaults to "/").
    """
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
    """
    request_method: Optional[pulumi.Input[str]] = pulumi.input_property("requestMethod")
    """
    The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then requestMethod defaults to GET.
    """
    use_ssl: Optional[pulumi.Input[bool]] = pulumi.input_property("useSsl")
    """
    If true, use HTTPS instead of HTTP to run the check.
    """
    validate_ssl: Optional[pulumi.Input[bool]] = pulumi.input_property("validateSsl")
    """
    Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, auth_info: Optional[pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgs']] = None, body: Optional[pulumi.Input[str]] = None, content_type: Optional[pulumi.Input[str]] = None, headers: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = None, mask_headers: Optional[pulumi.Input[bool]] = None, path: Optional[pulumi.Input[str]] = None, port: Optional[pulumi.Input[float]] = None, request_method: Optional[pulumi.Input[str]] = None, use_ssl: Optional[pulumi.Input[bool]] = None, validate_ssl: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgs'] auth_info: The authentication information. Optional when creating an HTTP check; defaults to empty.  Structure is documented below.
        :param pulumi.Input[str] body: The request body associated with the HTTP POST request. If contentType is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the requestMethod is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
        :param pulumi.Input[str] content_type: The content type to use for the check.
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] headers: The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
        :param pulumi.Input[bool] mask_headers: Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to True then the headers will be obscured with ******.
        :param pulumi.Input[str] path: The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. Optional (defaults to "/").
        :param pulumi.Input[float] port: The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
        :param pulumi.Input[str] request_method: The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then requestMethod defaults to GET.
        :param pulumi.Input[bool] use_ssl: If true, use HTTPS instead of HTTP to run the check.
        :param pulumi.Input[bool] validate_ssl: Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
        """
        __self__.auth_info = auth_info
        __self__.body = body
        __self__.content_type = content_type
        __self__.headers = headers
        __self__.mask_headers = mask_headers
        __self__.path = path
        __self__.port = port
        __self__.request_method = request_method
        __self__.use_ssl = use_ssl
        __self__.validate_ssl = validate_ssl

@pulumi.input_type
class UptimeCheckConfigHttpCheckAuthInfoArgs:
    password: pulumi.Input[str] = pulumi.input_property("password")
    """
    The password to authenticate.  **Note**: This property is sensitive and will not be displayed in the plan.
    """
    username: pulumi.Input[str] = pulumi.input_property("username")
    """
    The username to authenticate.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, password: pulumi.Input[str], username: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] password: The password to authenticate.  **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: The username to authenticate.
        """
        __self__.password = password
        __self__.username = username

@pulumi.input_type
class UptimeCheckConfigMonitoredResourceArgs:
    labels: pulumi.Input[Dict[str, pulumi.Input[str]]] = pulumi.input_property("labels")
    """
    Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
    """
    type: pulumi.Input[str] = pulumi.input_property("type")
    """
    The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, labels: pulumi.Input[Dict[str, pulumi.Input[str]]], type: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] labels: Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
        :param pulumi.Input[str] type: The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
        """
        __self__.labels = labels
        __self__.type = type

@pulumi.input_type
class UptimeCheckConfigResourceGroupArgs:
    group_id: Optional[pulumi.Input[str]] = pulumi.input_property("groupId")
    """
    The group of resources being monitored. Should be the `name` of a group
    """
    resource_type: Optional[pulumi.Input[str]] = pulumi.input_property("resourceType")
    """
    The resource type of the group members.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, group_id: Optional[pulumi.Input[str]] = None, resource_type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] group_id: The group of resources being monitored. Should be the `name` of a group
        :param pulumi.Input[str] resource_type: The resource type of the group members.
        """
        __self__.group_id = group_id
        __self__.resource_type = resource_type

@pulumi.input_type
class UptimeCheckConfigTcpCheckArgs:
    port: pulumi.Input[float] = pulumi.input_property("port")
    """
    The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, port: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] port: The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
        """
        __self__.port = port

