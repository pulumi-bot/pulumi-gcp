# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from .. import _utilities, _tables
from . import outputs

__all__ = [
    'AlertPolicyCondition',
    'AlertPolicyConditionConditionAbsent',
    'AlertPolicyConditionConditionAbsentAggregation',
    'AlertPolicyConditionConditionAbsentTrigger',
    'AlertPolicyConditionConditionThreshold',
    'AlertPolicyConditionConditionThresholdAggregation',
    'AlertPolicyConditionConditionThresholdDenominatorAggregation',
    'AlertPolicyConditionConditionThresholdTrigger',
    'AlertPolicyCreationRecord',
    'AlertPolicyDocumentation',
    'CustomServiceTelemetry',
    'MetricDescriptorLabel',
    'MetricDescriptorMetadata',
    'NotificationChannelSensitiveLabels',
    'SloBasicSli',
    'SloBasicSliLatency',
    'SloRequestBasedSli',
    'SloRequestBasedSliDistributionCut',
    'SloRequestBasedSliDistributionCutRange',
    'SloRequestBasedSliGoodTotalRatio',
    'SloWindowsBasedSli',
    'SloWindowsBasedSliGoodTotalRatioThreshold',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformance',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio',
    'SloWindowsBasedSliMetricMeanInRange',
    'SloWindowsBasedSliMetricMeanInRangeRange',
    'SloWindowsBasedSliMetricSumInRange',
    'SloWindowsBasedSliMetricSumInRangeRange',
    'UptimeCheckConfigContentMatcher',
    'UptimeCheckConfigHttpCheck',
    'UptimeCheckConfigHttpCheckAuthInfo',
    'UptimeCheckConfigMonitoredResource',
    'UptimeCheckConfigResourceGroup',
    'UptimeCheckConfigTcpCheck',
    'GetAppEngineServiceTelemetryResult',
    'GetNotificationChannelSensitiveLabelResult',
    'GetUptimeCheckIPsUptimeCheckIpResult',
]

@pulumi.output_type
class AlertPolicyCondition(dict):
    @property
    @pulumi.getter(name="conditionAbsent")
    def condition_absent(self) -> Optional['outputs.AlertPolicyConditionConditionAbsent']:
        """
        A condition that checks that a time series
        continues to receive new data points.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="conditionThreshold")
    def condition_threshold(self) -> Optional['outputs.AlertPolicyConditionConditionThreshold']:
        """
        A condition that compares a time series against a
        threshold.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A short name or phrase used to identify the
        condition in dashboards, notifications, and
        incidents. To avoid confusion, don't use the same
        display name for multiple conditions in the same
        policy.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        -
        The unique resource name for this condition.
        Its syntax is:
        projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
        [CONDITION_ID] is assigned by Stackdriver Monitoring when
        the condition is created as part of a new or updated alerting
        policy.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyConditionConditionAbsent(dict):
    @property
    @pulumi.getter
    def aggregations(self) -> Optional[List['outputs.AlertPolicyConditionConditionAbsentAggregation']]:
        """
        Specifies the alignment of data points in
        individual time series as well as how to
        combine the retrieved time series together
        (such as when aggregating multiple streams
        on each resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).
        Multiple aggregations are applied in the
        order specified.This field is similar to the
        one in the MetricService.ListTimeSeries
        request. It is advisable to use the
        ListTimeSeries method when debugging this
        field.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The amount of time that a time series must
        violate the threshold to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g., 0, 60, 120, or
        300 seconds--are supported. If an invalid
        value is given, an error will be returned.
        When choosing a duration, it is useful to
        keep in mind the frequency of the underlying
        time series data (which may also be affected
        by any alignments specified in the
        aggregations field); a good duration is long
        enough so that a single outlier does not
        generate spurious alerts, but short enough
        that unhealthy states are detected and
        alerted on quickly.
        """
        ...

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter that identifies which time series
        should be compared with the threshold.The
        filter is similar to the one that is
        specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        ...

    @property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.AlertPolicyConditionConditionAbsentTrigger']:
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations,
        or by the ratio, if denominator_filter and
        denominator_aggregations are specified.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyConditionConditionAbsentAggregation(dict):
    @property
    @pulumi.getter(name="alignmentPeriod")
    def alignment_period(self) -> Optional[str]:
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        ...

    @property
    @pulumi.getter(name="crossSeriesReducer")
    def cross_series_reducer(self) -> Optional[str]:
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, and `REDUCE_PERCENTILE_05`.
        """
        ...

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[List[str]]:
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        ...

    @property
    @pulumi.getter(name="perSeriesAligner")
    def per_series_aligner(self) -> Optional[str]:
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, and `ALIGN_PERCENT_CHANGE`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyConditionConditionAbsentTrigger(dict):
    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        ...

    @property
    @pulumi.getter
    def percent(self) -> Optional[float]:
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyConditionConditionThreshold(dict):
    @property
    @pulumi.getter
    def aggregations(self) -> Optional[List['outputs.AlertPolicyConditionConditionThresholdAggregation']]:
        """
        Specifies the alignment of data points in
        individual time series as well as how to
        combine the retrieved time series together
        (such as when aggregating multiple streams
        on each resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).
        Multiple aggregations are applied in the
        order specified.This field is similar to the
        one in the MetricService.ListTimeSeries
        request. It is advisable to use the
        ListTimeSeries method when debugging this
        field.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def comparison(self) -> str:
        """
        The comparison to apply between the time
        series (indicated by filter and aggregation)
        and the threshold (indicated by
        threshold_value). The comparison is applied
        on each time series, with the time series on
        the left-hand side and the threshold on the
        right-hand side. Only COMPARISON_LT and
        COMPARISON_GT are supported currently.
        Possible values are `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, and `COMPARISON_NE`.
        """
        ...

    @property
    @pulumi.getter(name="denominatorAggregations")
    def denominator_aggregations(self) -> Optional[List['outputs.AlertPolicyConditionConditionThresholdDenominatorAggregation']]:
        """
        Specifies the alignment of data points in
        individual time series selected by
        denominatorFilter as well as how to combine
        the retrieved time series together (such as
        when aggregating multiple streams on each
        resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).When
        computing ratios, the aggregations and
        denominator_aggregations fields must use the
        same alignment period and produce time
        series that have the same periodicity and
        labels.This field is similar to the one in
        the MetricService.ListTimeSeries request. It
        is advisable to use the ListTimeSeries
        method when debugging this field.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="denominatorFilter")
    def denominator_filter(self) -> Optional[str]:
        """
        A filter that identifies a time series that
        should be used as the denominator of a ratio
        that will be compared with the threshold. If
        a denominator_filter is specified, the time
        series specified by the filter field will be
        used as the numerator.The filter is similar
        to the one that is specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        ...

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The amount of time that a time series must
        violate the threshold to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g., 0, 60, 120, or
        300 seconds--are supported. If an invalid
        value is given, an error will be returned.
        When choosing a duration, it is useful to
        keep in mind the frequency of the underlying
        time series data (which may also be affected
        by any alignments specified in the
        aggregations field); a good duration is long
        enough so that a single outlier does not
        generate spurious alerts, but short enough
        that unhealthy states are detected and
        alerted on quickly.
        """
        ...

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter that identifies which time series
        should be compared with the threshold.The
        filter is similar to the one that is
        specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        ...

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[float]:
        """
        A value against which to compare the time
        series.
        """
        ...

    @property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.AlertPolicyConditionConditionThresholdTrigger']:
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations,
        or by the ratio, if denominator_filter and
        denominator_aggregations are specified.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyConditionConditionThresholdAggregation(dict):
    @property
    @pulumi.getter(name="alignmentPeriod")
    def alignment_period(self) -> Optional[str]:
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        ...

    @property
    @pulumi.getter(name="crossSeriesReducer")
    def cross_series_reducer(self) -> Optional[str]:
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, and `REDUCE_PERCENTILE_05`.
        """
        ...

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[List[str]]:
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        ...

    @property
    @pulumi.getter(name="perSeriesAligner")
    def per_series_aligner(self) -> Optional[str]:
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, and `ALIGN_PERCENT_CHANGE`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyConditionConditionThresholdDenominatorAggregation(dict):
    @property
    @pulumi.getter(name="alignmentPeriod")
    def alignment_period(self) -> Optional[str]:
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        ...

    @property
    @pulumi.getter(name="crossSeriesReducer")
    def cross_series_reducer(self) -> Optional[str]:
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, and `REDUCE_PERCENTILE_05`.
        """
        ...

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[List[str]]:
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        ...

    @property
    @pulumi.getter(name="perSeriesAligner")
    def per_series_aligner(self) -> Optional[str]:
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, and `ALIGN_PERCENT_CHANGE`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyConditionConditionThresholdTrigger(dict):
    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        ...

    @property
    @pulumi.getter
    def percent(self) -> Optional[float]:
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyCreationRecord(dict):
    @property
    @pulumi.getter(name="mutateTime")
    def mutate_time(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="mutatedBy")
    def mutated_by(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyDocumentation(dict):
    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The text of the documentation, interpreted according to mimeType.
        The content may not exceed 8,192 Unicode characters and may not
        exceed more than 10,240 bytes when encoded in UTF-8 format,
        whichever is smaller.
        """
        ...

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[str]:
        """
        The format of the content field. Presently, only the value
        "text/markdown" is supported.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CustomServiceTelemetry(dict):
    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        The full name of the resource that defines this service.
        Formatted as described in
        https://cloud.google.com/apis/design/resource_names.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MetricDescriptorLabel(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A human-readable description for the label.
        """
        ...

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key for this label. The key must not exceed 100 characters. The first character of the key must be an upper- or lower-case letter, the remaining characters must be letters, digits or underscores, and the key must match the regular expression [a-zA-Z][a-zA-Z0-9_]*
        """
        ...

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[str]:
        """
        The type of data that can be assigned to the label.
        Default value is `STRING`.
        Possible values are `STRING`, `BOOL`, and `INT64`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MetricDescriptorMetadata(dict):
    @property
    @pulumi.getter(name="ingestDelay")
    def ingest_delay(self) -> Optional[str]:
        """
        The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        """
        ...

    @property
    @pulumi.getter(name="samplePeriod")
    def sample_period(self) -> Optional[str]:
        """
        The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationChannelSensitiveLabels(dict):
    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[str]:
        """
        An authorization token for a notification channel. Channel types that support this field include: slack
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        An password for a notification channel. Channel types that support this field include: webhook_basicauth
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[str]:
        """
        An servicekey token for a notification channel. Channel types that support this field include: pagerduty
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloBasicSli(dict):
    @property
    @pulumi.getter
    def latency(self) -> 'outputs.SloBasicSliLatency':
        """
        Parameters for a latency threshold SLI.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def locations(self) -> Optional[List[str]]:
        """
        An optional set of locations to which this SLI is relevant.
        Telemetry from other locations will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        locations in which the Service has activity. For service types
        that don't support breaking down by location, setting this
        field will result in an error.
        """
        ...

    @property
    @pulumi.getter
    def methods(self) -> Optional[List[str]]:
        """
        An optional set of RPCs to which this SLI is relevant.
        Telemetry from other methods will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        the Service's methods. For service types that don't support
        breaking down by method, setting this field will result in an
        error.
        """
        ...

    @property
    @pulumi.getter
    def versions(self) -> Optional[List[str]]:
        """
        The set of API versions to which this SLI is relevant.
        Telemetry from other API versions will not be used to
        calculate performance for this SLI. If omitted,
        this SLI applies to all API versions. For service types
        that don't support breaking down by version, setting this
        field will result in an error.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloBasicSliLatency(dict):
    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        A duration string, e.g. 10s.
        Good service is defined to be the count of requests made to
        this service that return in no more than threshold.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloRequestBasedSli(dict):
    @property
    @pulumi.getter(name="distributionCut")
    def distribution_cut(self) -> Optional['outputs.SloRequestBasedSliDistributionCut']:
        """
        Used when good_service is defined by a count of values aggregated in a
        Distribution that fall into a good range. The total_service is the
        total count of all values aggregated in the Distribution.
        Defines a distribution TimeSeries filter and thresholds used for
        measuring good service and total service.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="goodTotalRatio")
    def good_total_ratio(self) -> Optional['outputs.SloRequestBasedSliGoodTotalRatio']:
        """
        A means to compute a ratio of `good_service` to `total_service`.
        Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
        Must specify exactly two of good, bad, and total service filters.
        The relationship good_service + bad_service = total_service
        will be assumed.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloRequestBasedSliDistributionCut(dict):
    @property
    @pulumi.getter(name="distributionFilter")
    def distribution_filter(self) -> str:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        aggregating values to quantify the good service provided.
        Must have ValueType = DISTRIBUTION and
        MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    @property
    @pulumi.getter
    def range(self) -> 'outputs.SloRequestBasedSliDistributionCutRange':
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x < range.max. inclusive of min and
        exclusive of max. Open ranges can be defined by setting
        just one of min or max. Summed value `X` should satisfy
        `range.min <= X < range.max` for a good window.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloRequestBasedSliDistributionCutRange(dict):
    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        ...

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloRequestBasedSliGoodTotalRatio(dict):
    @property
    @pulumi.getter(name="badServiceFilter")
    def bad_service_filter(self) -> Optional[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying bad service provided, either demanded service that
        was not provided or demanded service that was of inadequate
        quality. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    @property
    @pulumi.getter(name="goodServiceFilter")
    def good_service_filter(self) -> Optional[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying good service provided. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    @property
    @pulumi.getter(name="totalServiceFilter")
    def total_service_filter(self) -> Optional[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying total demanded service. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSli(dict):
    @property
    @pulumi.getter(name="goodBadMetricFilter")
    def good_bad_metric_filter(self) -> Optional[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        with ValueType = BOOL. The window is good if any true values
        appear in the window. One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        """
        ...

    @property
    @pulumi.getter(name="goodTotalRatioThreshold")
    def good_total_ratio_threshold(self) -> Optional['outputs.SloWindowsBasedSliGoodTotalRatioThreshold']:
        """
        Criterion that describes a window as good if its performance is
        high enough. One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="metricMeanInRange")
    def metric_mean_in_range(self) -> Optional['outputs.SloWindowsBasedSliMetricMeanInRange']:
        """
        Criterion that describes a window as good if the metric's value
        is in a good range, *averaged* across returned streams.
        One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Average value X of `time_series` should satisfy
        `range.min <= X < range.max` for a good window.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="metricSumInRange")
    def metric_sum_in_range(self) -> Optional['outputs.SloWindowsBasedSliMetricSumInRange']:
        """
        Criterion that describes a window as good if the metric's value
        is in a good range, *summed* across returned streams.
        Summed value `X` of `time_series` should satisfy
        `range.min <= X < range.max` for a good window.
        One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="windowPeriod")
    def window_period(self) -> Optional[str]:
        """
        Duration over which window quality is evaluated, given as a
        duration string "{X}s" representing X seconds. Must be an
        integer fraction of a day and at least 60s.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliGoodTotalRatioThreshold(dict):
    @property
    @pulumi.getter(name="basicSliPerformance")
    def basic_sli_performance(self) -> Optional['outputs.SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance']:
        """
        Basic SLI to evaluate to judge window quality.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def performance(self) -> Optional['outputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformance']:
        """
        Request-based SLI to evaluate to judge window quality.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        A duration string, e.g. 10s.
        Good service is defined to be the count of requests made to
        this service that return in no more than threshold.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance(dict):
    @property
    @pulumi.getter
    def latency(self) -> 'outputs.SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency':
        """
        Parameters for a latency threshold SLI.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def locations(self) -> Optional[List[str]]:
        """
        An optional set of locations to which this SLI is relevant.
        Telemetry from other locations will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        locations in which the Service has activity. For service types
        that don't support breaking down by location, setting this
        field will result in an error.
        """
        ...

    @property
    @pulumi.getter
    def methods(self) -> Optional[List[str]]:
        """
        An optional set of RPCs to which this SLI is relevant.
        Telemetry from other methods will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        the Service's methods. For service types that don't support
        breaking down by method, setting this field will result in an
        error.
        """
        ...

    @property
    @pulumi.getter
    def versions(self) -> Optional[List[str]]:
        """
        The set of API versions to which this SLI is relevant.
        Telemetry from other API versions will not be used to
        calculate performance for this SLI. If omitted,
        this SLI applies to all API versions. For service types
        that don't support breaking down by version, setting this
        field will result in an error.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency(dict):
    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        A duration string, e.g. 10s.
        Good service is defined to be the count of requests made to
        this service that return in no more than threshold.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformance(dict):
    @property
    @pulumi.getter(name="distributionCut")
    def distribution_cut(self) -> Optional['outputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut']:
        """
        Used when good_service is defined by a count of values aggregated in a
        Distribution that fall into a good range. The total_service is the
        total count of all values aggregated in the Distribution.
        Defines a distribution TimeSeries filter and thresholds used for
        measuring good service and total service.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="goodTotalRatio")
    def good_total_ratio(self) -> Optional['outputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio']:
        """
        A means to compute a ratio of `good_service` to `total_service`.
        Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
        Must specify exactly two of good, bad, and total service filters.
        The relationship good_service + bad_service = total_service
        will be assumed.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut(dict):
    @property
    @pulumi.getter(name="distributionFilter")
    def distribution_filter(self) -> str:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        aggregating values to quantify the good service provided.
        Must have ValueType = DISTRIBUTION and
        MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    @property
    @pulumi.getter
    def range(self) -> 'outputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange':
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x < range.max. inclusive of min and
        exclusive of max. Open ranges can be defined by setting
        just one of min or max. Summed value `X` should satisfy
        `range.min <= X < range.max` for a good window.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange(dict):
    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        ...

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio(dict):
    @property
    @pulumi.getter(name="badServiceFilter")
    def bad_service_filter(self) -> Optional[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying bad service provided, either demanded service that
        was not provided or demanded service that was of inadequate
        quality. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    @property
    @pulumi.getter(name="goodServiceFilter")
    def good_service_filter(self) -> Optional[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying good service provided. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    @property
    @pulumi.getter(name="totalServiceFilter")
    def total_service_filter(self) -> Optional[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying total demanded service. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliMetricMeanInRange(dict):
    @property
    @pulumi.getter
    def range(self) -> 'outputs.SloWindowsBasedSliMetricMeanInRangeRange':
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x < range.max. inclusive of min and
        exclusive of max. Open ranges can be defined by setting
        just one of min or max. Summed value `X` should satisfy
        `range.min <= X < range.max` for a good window.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="timeSeries")
    def time_series(self) -> str:
        """
        A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        specifying the TimeSeries to use for evaluating window
        quality. The provided TimeSeries must have
        ValueType = INT64 or ValueType = DOUBLE and
        MetricKind = GAUGE.
        Summed value `X` should satisfy
        `range.min <= X < range.max` for a good window.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliMetricMeanInRangeRange(dict):
    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        ...

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliMetricSumInRange(dict):
    @property
    @pulumi.getter
    def range(self) -> 'outputs.SloWindowsBasedSliMetricSumInRangeRange':
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x < range.max. inclusive of min and
        exclusive of max. Open ranges can be defined by setting
        just one of min or max. Summed value `X` should satisfy
        `range.min <= X < range.max` for a good window.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="timeSeries")
    def time_series(self) -> str:
        """
        A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        specifying the TimeSeries to use for evaluating window
        quality. The provided TimeSeries must have
        ValueType = INT64 or ValueType = DOUBLE and
        MetricKind = GAUGE.
        Summed value `X` should satisfy
        `range.min <= X < range.max` for a good window.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SloWindowsBasedSliMetricSumInRangeRange(dict):
    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        ...

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UptimeCheckConfigContentMatcher(dict):
    @property
    @pulumi.getter
    def content(self) -> str:
        """
        String or regex content to match (max 1024 bytes)
        """
        ...

    @property
    @pulumi.getter
    def matcher(self) -> Optional[str]:
        """
        The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
        Default value is `CONTAINS_STRING`.
        Possible values are `CONTAINS_STRING`, `NOT_CONTAINS_STRING`, `MATCHES_REGEX`, and `NON_MATCHES_REGEX`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UptimeCheckConfigHttpCheck(dict):
    @property
    @pulumi.getter(name="authInfo")
    def auth_info(self) -> Optional['outputs.UptimeCheckConfigHttpCheckAuthInfo']:
        """
        The authentication information. Optional when creating an HTTP check; defaults to empty.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The request body associated with the HTTP POST request. If contentType is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the requestMethod is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
        """
        ...

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        The content type to use for the check.
        Possible values are `TYPE_UNSPECIFIED` and `URL_ENCODED`.
        """
        ...

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        """
        The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
        """
        ...

    @property
    @pulumi.getter(name="maskHeaders")
    def mask_headers(self) -> Optional[bool]:
        """
        Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to True then the headers will be obscured with ******.
        """
        ...

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. Optional (defaults to "/").
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
        """
        ...

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[str]:
        """
        The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then requestMethod defaults to GET.
        Default value is `GET`.
        Possible values are `METHOD_UNSPECIFIED`, `GET`, and `POST`.
        """
        ...

    @property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[bool]:
        """
        If true, use HTTPS instead of HTTP to run the check.
        """
        ...

    @property
    @pulumi.getter(name="validateSsl")
    def validate_ssl(self) -> Optional[bool]:
        """
        Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UptimeCheckConfigHttpCheckAuthInfo(dict):
    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to authenticate.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to authenticate.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UptimeCheckConfigMonitoredResource(dict):
    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UptimeCheckConfigResourceGroup(dict):
    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The group of resources being monitored. Should be the `name` of a group
        """
        ...

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The resource type of the group members.
        Possible values are `RESOURCE_TYPE_UNSPECIFIED`, `INSTANCE`, and `AWS_ELB_LOAD_BALANCER`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UptimeCheckConfigTcpCheck(dict):
    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetAppEngineServiceTelemetryResult(dict):
    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        ...


@pulumi.output_type
class GetNotificationChannelSensitiveLabelResult(dict):
    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        ...

    @property
    @pulumi.getter
    def password(self) -> str:
        ...

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        ...


@pulumi.output_type
class GetUptimeCheckIPsUptimeCheckIpResult(dict):
    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address from which the Uptime check originates. This is a fully specified IP address
        (not an IP address range). Most IP addresses, as of this publication, are in IPv4 format; however, one should not
        rely on the IP addresses being in IPv4 format indefinitely, and should support interpreting this field in either
        IPv4 or IPv6 format.
        """
        ...

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        A more specific location within the region that typically encodes a particular city/town/metro
        (and its containing state/province or country) within the broader umbrella region category.
        """
        ...

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        A broad region category in which the IP address is located.
        """
        ...


