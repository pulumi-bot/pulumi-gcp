# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from .. import _utilities, _tables
from . import outputs

__all__ = [
    'NoteAttestationAuthority',
    'NoteAttestationAuthorityHint',
    'NoteRelatedUrl',
    'OccurenceAttestation',
    'OccurenceAttestationSignature',
]

@pulumi.output_type
class NoteAttestationAuthority(dict):
    @property
    @pulumi.getter
    def hint(self) -> 'outputs.NoteAttestationAuthorityHint':
        """
        This submessage provides human-readable hints about the purpose of
        the AttestationAuthority. Because the name of a Note acts as its
        resource reference, it is important to disambiguate the canonical
        name of the Note (which might be a UUID for security purposes)
        from "readable" names more suitable for debug output. Note that
        these hints should NOT be used to look up AttestationAuthorities
        in security sensitive contexts, such as when looking up
        Attestations to verify.  Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NoteAttestationAuthorityHint(dict):
    @property
    @pulumi.getter(name="humanReadableName")
    def human_readable_name(self) -> str:
        """
        The human readable name of this Attestation Authority, for
        example "qa".
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NoteRelatedUrl(dict):
    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Label to describe usage of the URL
        """
        ...

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specific URL associated with the resource.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OccurenceAttestation(dict):
    @property
    @pulumi.getter(name="serializedPayload")
    def serialized_payload(self) -> str:
        """
        The serialized payload that is verified by one or
        more signatures. A base64-encoded string.
        """
        ...

    @property
    @pulumi.getter
    def signatures(self) -> List['outputs.OccurenceAttestationSignature']:
        """
        One or more signatures over serializedPayload.
        Verifier implementations should consider this attestation
        message verified if at least one signature verifies
        serializedPayload. See Signature in common.proto for more
        details on signature structure and verification.  Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OccurenceAttestationSignature(dict):
    @property
    @pulumi.getter(name="publicKeyId")
    def public_key_id(self) -> str:
        """
        The identifier for the public key that verifies this
        signature. MUST be an RFC3986 conformant
        URI. * When possible, the key id should be an
        immutable reference, such as a cryptographic digest.
        Examples of valid values:
        * OpenPGP V4 public key fingerprint. See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr
        for more details on this scheme.
        * `openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA`
        * RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization):
        * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
        """
        ...

    @property
    @pulumi.getter
    def signature(self) -> Optional[str]:
        """
        The content of the signature, an opaque bytestring.
        The payload that this signature verifies MUST be
        unambiguously provided with the Signature during
        verification. A wrapper message might provide the
        payload explicitly. Alternatively, a message might
        have a canonical serialization that can always be
        unambiguously computed to derive the payload.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


