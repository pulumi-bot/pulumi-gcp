# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Optional, Tuple, Union
from .. import _utilities, _tables
from ._inputs import *
from . import outputs

@pulumi.input_type
class AutoscalarAutoscalingPolicyArgs:
    max_replicas: pulumi.Input[float] = pulumi.input_property("maxReplicas")
    """
    The maximum number of instances that the autoscaler can scale up
    to. This is required when creating or updating an autoscaler. The
    maximum number of replicas should not be lower than minimal number
    of replicas.
    """
    min_replicas: pulumi.Input[float] = pulumi.input_property("minReplicas")
    """
    The minimum number of replicas that the autoscaler can scale down
    to. This cannot be less than 0. If not provided, autoscaler will
    choose a default value depending on maximum number of instances
    allowed.
    """
    cooldown_period: Optional[pulumi.Input[float]] = pulumi.input_property("cooldownPeriod")
    """
    The number of seconds that the autoscaler should wait before it
    starts collecting information from a new instance. This prevents
    the autoscaler from collecting information when the instance is
    initializing, during which the collected usage would not be
    reliable. The default time autoscaler waits is 60 seconds.
    Virtual machine initialization times might vary because of
    numerous factors. We recommend that you test how long an
    instance may take to initialize. To do this, create an instance
    and time the startup process.
    """
    cpu_utilization: Optional[pulumi.Input['AutoscalarAutoscalingPolicyCpuUtilizationArgs']] = pulumi.input_property("cpuUtilization")
    """
    Defines the CPU utilization policy that allows the autoscaler to
    scale based on the average CPU utilization of a managed instance
    group.  Structure is documented below.
    """
    load_balancing_utilization: Optional[pulumi.Input['AutoscalarAutoscalingPolicyLoadBalancingUtilizationArgs']] = pulumi.input_property("loadBalancingUtilization")
    """
    Configuration parameters of autoscaling based on a load balancer.  Structure is documented below.
    """
    metrics: Optional[pulumi.Input[List[pulumi.Input['AutoscalarAutoscalingPolicyMetricArgs']]]] = pulumi.input_property("metrics")
    """
    Configuration parameters of autoscaling based on a custom metric.  Structure is documented below.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    Defines operating mode for this policy.
    """
    scale_down_control: Optional[pulumi.Input['AutoscalarAutoscalingPolicyScaleDownControlArgs']] = pulumi.input_property("scaleDownControl")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_replicas: pulumi.Input[float], min_replicas: pulumi.Input[float], cooldown_period: Optional[pulumi.Input[float]] = None, cpu_utilization: Optional[pulumi.Input['AutoscalarAutoscalingPolicyCpuUtilizationArgs']] = None, load_balancing_utilization: Optional[pulumi.Input['AutoscalarAutoscalingPolicyLoadBalancingUtilizationArgs']] = None, metrics: Optional[pulumi.Input[List[pulumi.Input['AutoscalarAutoscalingPolicyMetricArgs']]]] = None, mode: Optional[pulumi.Input[str]] = None, scale_down_control: Optional[pulumi.Input['AutoscalarAutoscalingPolicyScaleDownControlArgs']] = None) -> None:
        """
        :param pulumi.Input[float] max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param pulumi.Input[float] min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param pulumi.Input[float] cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param pulumi.Input['AutoscalarAutoscalingPolicyCpuUtilizationArgs'] cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.  Structure is documented below.
        :param pulumi.Input['AutoscalarAutoscalingPolicyLoadBalancingUtilizationArgs'] load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['AutoscalarAutoscalingPolicyMetricArgs']]] metrics: Configuration parameters of autoscaling based on a custom metric.  Structure is documented below.
        :param pulumi.Input[str] mode: Defines operating mode for this policy.
        """
        __self__.max_replicas = max_replicas
        __self__.min_replicas = min_replicas
        __self__.cooldown_period = cooldown_period
        __self__.cpu_utilization = cpu_utilization
        __self__.load_balancing_utilization = load_balancing_utilization
        __self__.metrics = metrics
        __self__.mode = mode
        __self__.scale_down_control = scale_down_control

@pulumi.input_type
class AutoscalarAutoscalingPolicyCpuUtilizationArgs:
    target: pulumi.Input[float] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, target: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        __self__.target = target

@pulumi.input_type
class AutoscalarAutoscalingPolicyLoadBalancingUtilizationArgs:
    target: pulumi.Input[float] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, target: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        __self__.target = target

@pulumi.input_type
class AutoscalarAutoscalingPolicyMetricArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The identifier (type) of the Stackdriver Monitoring metric.
    The metric cannot have negative values.
    The metric must have a value type of INT64 or DOUBLE.
    """
    filter: Optional[pulumi.Input[str]] = pulumi.input_property("filter")
    """
    A filter string to be used as the filter string for
    a Stackdriver Monitoring TimeSeries.list API call.
    This filter is used to select a specific TimeSeries for
    the purpose of autoscaling and to determine whether the metric
    is exporting per-instance or per-group data.
    You can only use the AND operator for joining selectors.
    You can only use direct equality comparison operator (=) without
    any functions for each selector.
    You can specify the metric in both the filter string and in the
    metric field. However, if specified in both places, the metric must
    be identical.
    The monitored resource type determines what kind of values are
    expected for the metric. If it is a gce_instance, the autoscaler
    expects the metric to include a separate TimeSeries for each
    instance in a group. In such a case, you cannot filter on resource
    labels.
    If the resource type is any other value, the autoscaler expects
    this metric to contain values that apply to the entire autoscaled
    instance group and resource label filtering can be performed to
    point autoscaler at the correct TimeSeries to scale upon.
    This is called a per-group metric for the purpose of autoscaling.
    If not specified, the type defaults to gce_instance.
    You should provide a filter that is selective enough to pick just
    one TimeSeries for the autoscaled group or for each of the instances
    (if you are using gce_instance resource type). If multiple
    TimeSeries are returned upon the query execution, the autoscaler
    will sum their respective values to obtain its scaling value.
    """
    single_instance_assignment: Optional[pulumi.Input[float]] = pulumi.input_property("singleInstanceAssignment")
    """
    If scaling is based on a per-group metric value that represents the
    total amount of work to be done or resource usage, set this value to
    an amount assigned for a single instance of the scaled group.
    The autoscaler will keep the number of instances proportional to the
    value of this metric, the metric itself should not change value due
    to group resizing.
    For example, a good metric to use with the target is
    `pubsub.googleapis.com/subscription/num_undelivered_messages`
    or a custom metric exporting the total number of requests coming to
    your instances.
    A bad example would be a metric exporting an average or median
    latency, since this value can't include a chunk assignable to a
    single instance, it could be better used with utilization_target
    instead.
    """
    target: Optional[pulumi.Input[float]] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """
    type: Optional[pulumi.Input[str]] = pulumi.input_property("type")
    """
    Defines how target utilization value is expressed for a
    Stackdriver Monitoring metric.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], filter: Optional[pulumi.Input[str]] = None, single_instance_assignment: Optional[pulumi.Input[float]] = None, target: Optional[pulumi.Input[float]] = None, type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] name: The identifier (type) of the Stackdriver Monitoring metric.
               The metric cannot have negative values.
               The metric must have a value type of INT64 or DOUBLE.
        :param pulumi.Input[str] filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param pulumi.Input[float] single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param pulumi.Input[str] type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
        """
        __self__.name = name
        __self__.filter = filter
        __self__.single_instance_assignment = single_instance_assignment
        __self__.target = target
        __self__.type = type

@pulumi.input_type
class AutoscalarAutoscalingPolicyScaleDownControlArgs:
    max_scaled_down_replicas: Optional[pulumi.Input['AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs']] = pulumi.input_property("maxScaledDownReplicas")
    """
    A nested object resource  Structure is documented below.
    """
    time_window_sec: Optional[pulumi.Input[float]] = pulumi.input_property("timeWindowSec")
    """
    How long back autoscaling should look when computing recommendations
    to include directives regarding slower scale down, as described above.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_scaled_down_replicas: Optional[pulumi.Input['AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs']] = None, time_window_sec: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs'] max_scaled_down_replicas: A nested object resource  Structure is documented below.
        :param pulumi.Input[float] time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        __self__.max_scaled_down_replicas = max_scaled_down_replicas
        __self__.time_window_sec = time_window_sec

@pulumi.input_type
class AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs:
    fixed: Optional[pulumi.Input[float]] = pulumi.input_property("fixed")
    """
    Specifies a fixed number of VM instances. This must be a positive
    integer.
    """
    percent: Optional[pulumi.Input[float]] = pulumi.input_property("percent")
    """
    Specifies a percentage of instances between 0 to 100%, inclusive.
    For example, specify 80 for 80%.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed: Optional[pulumi.Input[float]] = None, percent: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param pulumi.Input[float] percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        __self__.fixed = fixed
        __self__.percent = percent

@pulumi.input_type
class AutoscalerAutoscalingPolicyArgs:
    max_replicas: pulumi.Input[float] = pulumi.input_property("maxReplicas")
    """
    The maximum number of instances that the autoscaler can scale up
    to. This is required when creating or updating an autoscaler. The
    maximum number of replicas should not be lower than minimal number
    of replicas.
    """
    min_replicas: pulumi.Input[float] = pulumi.input_property("minReplicas")
    """
    The minimum number of replicas that the autoscaler can scale down
    to. This cannot be less than 0. If not provided, autoscaler will
    choose a default value depending on maximum number of instances
    allowed.
    """
    cooldown_period: Optional[pulumi.Input[float]] = pulumi.input_property("cooldownPeriod")
    """
    The number of seconds that the autoscaler should wait before it
    starts collecting information from a new instance. This prevents
    the autoscaler from collecting information when the instance is
    initializing, during which the collected usage would not be
    reliable. The default time autoscaler waits is 60 seconds.
    Virtual machine initialization times might vary because of
    numerous factors. We recommend that you test how long an
    instance may take to initialize. To do this, create an instance
    and time the startup process.
    """
    cpu_utilization: Optional[pulumi.Input['AutoscalerAutoscalingPolicyCpuUtilizationArgs']] = pulumi.input_property("cpuUtilization")
    """
    Defines the CPU utilization policy that allows the autoscaler to
    scale based on the average CPU utilization of a managed instance
    group.  Structure is documented below.
    """
    load_balancing_utilization: Optional[pulumi.Input['AutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs']] = pulumi.input_property("loadBalancingUtilization")
    """
    Configuration parameters of autoscaling based on a load balancer.  Structure is documented below.
    """
    metrics: Optional[pulumi.Input[List[pulumi.Input['AutoscalerAutoscalingPolicyMetricArgs']]]] = pulumi.input_property("metrics")
    """
    Configuration parameters of autoscaling based on a custom metric.  Structure is documented below.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    Defines operating mode for this policy.
    """
    scale_down_control: Optional[pulumi.Input['AutoscalerAutoscalingPolicyScaleDownControlArgs']] = pulumi.input_property("scaleDownControl")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_replicas: pulumi.Input[float], min_replicas: pulumi.Input[float], cooldown_period: Optional[pulumi.Input[float]] = None, cpu_utilization: Optional[pulumi.Input['AutoscalerAutoscalingPolicyCpuUtilizationArgs']] = None, load_balancing_utilization: Optional[pulumi.Input['AutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs']] = None, metrics: Optional[pulumi.Input[List[pulumi.Input['AutoscalerAutoscalingPolicyMetricArgs']]]] = None, mode: Optional[pulumi.Input[str]] = None, scale_down_control: Optional[pulumi.Input['AutoscalerAutoscalingPolicyScaleDownControlArgs']] = None) -> None:
        """
        :param pulumi.Input[float] max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param pulumi.Input[float] min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param pulumi.Input[float] cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param pulumi.Input['AutoscalerAutoscalingPolicyCpuUtilizationArgs'] cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.  Structure is documented below.
        :param pulumi.Input['AutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs'] load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['AutoscalerAutoscalingPolicyMetricArgs']]] metrics: Configuration parameters of autoscaling based on a custom metric.  Structure is documented below.
        :param pulumi.Input[str] mode: Defines operating mode for this policy.
        """
        __self__.max_replicas = max_replicas
        __self__.min_replicas = min_replicas
        __self__.cooldown_period = cooldown_period
        __self__.cpu_utilization = cpu_utilization
        __self__.load_balancing_utilization = load_balancing_utilization
        __self__.metrics = metrics
        __self__.mode = mode
        __self__.scale_down_control = scale_down_control

@pulumi.input_type
class AutoscalerAutoscalingPolicyCpuUtilizationArgs:
    target: pulumi.Input[float] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, target: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        __self__.target = target

@pulumi.input_type
class AutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs:
    target: pulumi.Input[float] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, target: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        __self__.target = target

@pulumi.input_type
class AutoscalerAutoscalingPolicyMetricArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The identifier (type) of the Stackdriver Monitoring metric.
    The metric cannot have negative values.
    The metric must have a value type of INT64 or DOUBLE.
    """
    filter: Optional[pulumi.Input[str]] = pulumi.input_property("filter")
    """
    A filter string to be used as the filter string for
    a Stackdriver Monitoring TimeSeries.list API call.
    This filter is used to select a specific TimeSeries for
    the purpose of autoscaling and to determine whether the metric
    is exporting per-instance or per-group data.
    You can only use the AND operator for joining selectors.
    You can only use direct equality comparison operator (=) without
    any functions for each selector.
    You can specify the metric in both the filter string and in the
    metric field. However, if specified in both places, the metric must
    be identical.
    The monitored resource type determines what kind of values are
    expected for the metric. If it is a gce_instance, the autoscaler
    expects the metric to include a separate TimeSeries for each
    instance in a group. In such a case, you cannot filter on resource
    labels.
    If the resource type is any other value, the autoscaler expects
    this metric to contain values that apply to the entire autoscaled
    instance group and resource label filtering can be performed to
    point autoscaler at the correct TimeSeries to scale upon.
    This is called a per-group metric for the purpose of autoscaling.
    If not specified, the type defaults to gce_instance.
    You should provide a filter that is selective enough to pick just
    one TimeSeries for the autoscaled group or for each of the instances
    (if you are using gce_instance resource type). If multiple
    TimeSeries are returned upon the query execution, the autoscaler
    will sum their respective values to obtain its scaling value.
    """
    single_instance_assignment: Optional[pulumi.Input[float]] = pulumi.input_property("singleInstanceAssignment")
    """
    If scaling is based on a per-group metric value that represents the
    total amount of work to be done or resource usage, set this value to
    an amount assigned for a single instance of the scaled group.
    The autoscaler will keep the number of instances proportional to the
    value of this metric, the metric itself should not change value due
    to group resizing.
    For example, a good metric to use with the target is
    `pubsub.googleapis.com/subscription/num_undelivered_messages`
    or a custom metric exporting the total number of requests coming to
    your instances.
    A bad example would be a metric exporting an average or median
    latency, since this value can't include a chunk assignable to a
    single instance, it could be better used with utilization_target
    instead.
    """
    target: Optional[pulumi.Input[float]] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """
    type: Optional[pulumi.Input[str]] = pulumi.input_property("type")
    """
    Defines how target utilization value is expressed for a
    Stackdriver Monitoring metric.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], filter: Optional[pulumi.Input[str]] = None, single_instance_assignment: Optional[pulumi.Input[float]] = None, target: Optional[pulumi.Input[float]] = None, type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] name: The identifier (type) of the Stackdriver Monitoring metric.
               The metric cannot have negative values.
               The metric must have a value type of INT64 or DOUBLE.
        :param pulumi.Input[str] filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param pulumi.Input[float] single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param pulumi.Input[str] type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
        """
        __self__.name = name
        __self__.filter = filter
        __self__.single_instance_assignment = single_instance_assignment
        __self__.target = target
        __self__.type = type

@pulumi.input_type
class AutoscalerAutoscalingPolicyScaleDownControlArgs:
    max_scaled_down_replicas: Optional[pulumi.Input['AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs']] = pulumi.input_property("maxScaledDownReplicas")
    """
    A nested object resource  Structure is documented below.
    """
    time_window_sec: Optional[pulumi.Input[float]] = pulumi.input_property("timeWindowSec")
    """
    How long back autoscaling should look when computing recommendations
    to include directives regarding slower scale down, as described above.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_scaled_down_replicas: Optional[pulumi.Input['AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs']] = None, time_window_sec: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs'] max_scaled_down_replicas: A nested object resource  Structure is documented below.
        :param pulumi.Input[float] time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        __self__.max_scaled_down_replicas = max_scaled_down_replicas
        __self__.time_window_sec = time_window_sec

@pulumi.input_type
class AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs:
    fixed: Optional[pulumi.Input[float]] = pulumi.input_property("fixed")
    """
    Specifies a fixed number of VM instances. This must be a positive
    integer.
    """
    percent: Optional[pulumi.Input[float]] = pulumi.input_property("percent")
    """
    Specifies a percentage of instances between 0 to 100%, inclusive.
    For example, specify 80 for 80%.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed: Optional[pulumi.Input[float]] = None, percent: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param pulumi.Input[float] percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        __self__.fixed = fixed
        __self__.percent = percent

@pulumi.input_type
class BackendBucketCdnPolicyArgs:
    signed_url_cache_max_age_sec: pulumi.Input[float] = pulumi.input_property("signedUrlCacheMaxAgeSec")
    """
    Maximum number of seconds the response to a signed URL request will
    be considered fresh. After this time period,
    the response will be revalidated before being served.
    When serving responses to signed URL requests,
    Cloud CDN will internally behave as though
    all responses from this backend had a "Cache-Control: public,
    max-age=[TTL]" header, regardless of any existing Cache-Control
    header. The actual headers served in responses will not be altered.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, signed_url_cache_max_age_sec: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request will
               be considered fresh. After this time period,
               the response will be revalidated before being served.
               When serving responses to signed URL requests,
               Cloud CDN will internally behave as though
               all responses from this backend had a "Cache-Control: public,
               max-age=[TTL]" header, regardless of any existing Cache-Control
               header. The actual headers served in responses will not be altered.
        """
        __self__.signed_url_cache_max_age_sec = signed_url_cache_max_age_sec

@pulumi.input_type
class BackendServiceBackendArgs:
    group: pulumi.Input[str] = pulumi.input_property("group")
    """
    The fully-qualified URL of an Instance Group or Network Endpoint
    Group resource. In case of instance group this defines the list
    of instances that serve traffic. Member virtual machine
    instances from each instance group must live in the same zone as
    the instance group itself. No two backends in a backend service
    are allowed to use same Instance Group resource.
    For Network Endpoint Groups this defines list of endpoints. All
    endpoints of Network Endpoint Group must be hosted on instances
    located in the same zone as the Network Endpoint Group.
    Backend services cannot mix Instance Group and
    Network Endpoint Group backends.
    Note that you must specify an Instance Group or Network Endpoint
    Group resource using the fully-qualified URL, rather than a
    partial URL.
    """
    balancing_mode: Optional[pulumi.Input[str]] = pulumi.input_property("balancingMode")
    """
    Specifies the balancing mode for this backend.
    For global HTTP(S) or TCP/SSL load balancing, the default is
    UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
    and CONNECTION (for TCP/SSL).
    """
    capacity_scaler: Optional[pulumi.Input[float]] = pulumi.input_property("capacityScaler")
    """
    A multiplier applied to the group's maximum servicing capacity
    (based on UTILIZATION, RATE or CONNECTION).
    Default value is 1, which means the group will serve up to 100%
    of its configured capacity (depending on balancingMode). A
    setting of 0 means the group is completely drained, offering
    0% of its available Capacity. Valid range is [0.0,1.0].
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    An optional description of this resource.
    Provide this property when you create the resource.
    """
    max_connections: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnections")
    """
    The maximum number of connections to the backend cluster.
    Defaults to 1024.
    """
    max_connections_per_endpoint: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnectionsPerEndpoint")
    """
    The max number of simultaneous connections that a single backend
    network endpoint can handle. This is used to calculate the
    capacity of the group. Can be used in either CONNECTION or
    UTILIZATION balancing modes.
    For CONNECTION mode, either
    maxConnections or maxConnectionsPerEndpoint must be set.
    """
    max_connections_per_instance: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnectionsPerInstance")
    """
    The max number of simultaneous connections that a single
    backend instance can handle. This is used to calculate the
    capacity of the group. Can be used in either CONNECTION or
    UTILIZATION balancing modes.
    For CONNECTION mode, either maxConnections or
    maxConnectionsPerInstance must be set.
    """
    max_rate: Optional[pulumi.Input[float]] = pulumi.input_property("maxRate")
    """
    The max requests per second (RPS) of the group.
    Can be used with either RATE or UTILIZATION balancing modes,
    but required if RATE mode. For RATE mode, either maxRate or one
    of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
    group type, must be set.
    """
    max_rate_per_endpoint: Optional[pulumi.Input[float]] = pulumi.input_property("maxRatePerEndpoint")
    """
    The max requests per second (RPS) that a single backend network
    endpoint can handle. This is used to calculate the capacity of
    the group. Can be used in either balancing mode. For RATE mode,
    either maxRate or maxRatePerEndpoint must be set.
    """
    max_rate_per_instance: Optional[pulumi.Input[float]] = pulumi.input_property("maxRatePerInstance")
    """
    The max requests per second (RPS) that a single backend
    instance can handle. This is used to calculate the capacity of
    the group. Can be used in either balancing mode. For RATE mode,
    either maxRate or maxRatePerInstance must be set.
    """
    max_utilization: Optional[pulumi.Input[float]] = pulumi.input_property("maxUtilization")
    """
    Used when balancingMode is UTILIZATION. This ratio defines the
    CPU utilization target for the group. The default is 0.8. Valid
    range is [0.0, 1.0].
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, group: pulumi.Input[str], balancing_mode: Optional[pulumi.Input[str]] = None, capacity_scaler: Optional[pulumi.Input[float]] = None, description: Optional[pulumi.Input[str]] = None, max_connections: Optional[pulumi.Input[float]] = None, max_connections_per_endpoint: Optional[pulumi.Input[float]] = None, max_connections_per_instance: Optional[pulumi.Input[float]] = None, max_rate: Optional[pulumi.Input[float]] = None, max_rate_per_endpoint: Optional[pulumi.Input[float]] = None, max_rate_per_instance: Optional[pulumi.Input[float]] = None, max_utilization: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param pulumi.Input[str] balancing_mode: Specifies the balancing mode for this backend.
               For global HTTP(S) or TCP/SSL load balancing, the default is
               UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
               and CONNECTION (for TCP/SSL).
        :param pulumi.Input[float] capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               Default value is 1, which means the group will serve up to 100%
               of its configured capacity (depending on balancingMode). A
               setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param pulumi.Input[str] description: An optional description of this resource.
               Provide this property when you create the resource.
        :param pulumi.Input[float] max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               For CONNECTION mode, either
               maxConnections or maxConnectionsPerEndpoint must be set.
        :param pulumi.Input[float] max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param pulumi.Input[float] max_rate: The max requests per second (RPS) of the group.
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. For RATE mode, either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param pulumi.Input[float] max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set.
        :param pulumi.Input[float] max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set.
        :param pulumi.Input[float] max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. The default is 0.8. Valid
               range is [0.0, 1.0].
        """
        __self__.group = group
        __self__.balancing_mode = balancing_mode
        __self__.capacity_scaler = capacity_scaler
        __self__.description = description
        __self__.max_connections = max_connections
        __self__.max_connections_per_endpoint = max_connections_per_endpoint
        __self__.max_connections_per_instance = max_connections_per_instance
        __self__.max_rate = max_rate
        __self__.max_rate_per_endpoint = max_rate_per_endpoint
        __self__.max_rate_per_instance = max_rate_per_instance
        __self__.max_utilization = max_utilization

@pulumi.input_type
class BackendServiceCdnPolicyArgs:
    cache_key_policy: Optional[pulumi.Input['BackendServiceCdnPolicyCacheKeyPolicyArgs']] = pulumi.input_property("cacheKeyPolicy")
    """
    The CacheKeyPolicy for this CdnPolicy.  Structure is documented below.
    """
    signed_url_cache_max_age_sec: Optional[pulumi.Input[float]] = pulumi.input_property("signedUrlCacheMaxAgeSec")
    """
    Maximum number of seconds the response to a signed URL request
    will be considered fresh, defaults to 1hr (3600s). After this
    time period, the response will be revalidated before
    being served.
    When serving responses to signed URL requests, Cloud CDN will
    internally behave as though all responses from this backend had a
    "Cache-Control: public, max-age=[TTL]" header, regardless of any
    existing Cache-Control header. The actual headers served in
    responses will not be altered.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cache_key_policy: Optional[pulumi.Input['BackendServiceCdnPolicyCacheKeyPolicyArgs']] = None, signed_url_cache_max_age_sec: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['BackendServiceCdnPolicyCacheKeyPolicyArgs'] cache_key_policy: The CacheKeyPolicy for this CdnPolicy.  Structure is documented below.
        :param pulumi.Input[float] signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request
               will be considered fresh, defaults to 1hr (3600s). After this
               time period, the response will be revalidated before
               being served.
               When serving responses to signed URL requests, Cloud CDN will
               internally behave as though all responses from this backend had a
               "Cache-Control: public, max-age=[TTL]" header, regardless of any
               existing Cache-Control header. The actual headers served in
               responses will not be altered.
        """
        __self__.cache_key_policy = cache_key_policy
        __self__.signed_url_cache_max_age_sec = signed_url_cache_max_age_sec

@pulumi.input_type
class BackendServiceCdnPolicyCacheKeyPolicyArgs:
    include_host: Optional[pulumi.Input[bool]] = pulumi.input_property("includeHost")
    """
    If true requests to different hosts will be cached separately.
    """
    include_protocol: Optional[pulumi.Input[bool]] = pulumi.input_property("includeProtocol")
    """
    If true, http and https requests will be cached separately.
    """
    include_query_string: Optional[pulumi.Input[bool]] = pulumi.input_property("includeQueryString")
    """
    If true, include query string parameters in the cache key
    according to query_string_whitelist and
    query_string_blacklist. If neither is set, the entire query
    string will be included.
    If false, the query string will be excluded from the cache
    key entirely.
    """
    query_string_blacklists: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("queryStringBlacklists")
    """
    Names of query string parameters to exclude in cache keys.
    All other parameters will be included. Either specify
    query_string_whitelist or query_string_blacklist, not both.
    '&' and '=' will be percent encoded and not treated as
    delimiters.
    """
    query_string_whitelists: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("queryStringWhitelists")
    """
    Names of query string parameters to include in cache keys.
    All other parameters will be excluded. Either specify
    query_string_whitelist or query_string_blacklist, not both.
    '&' and '=' will be percent encoded and not treated as
    delimiters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, include_host: Optional[pulumi.Input[bool]] = None, include_protocol: Optional[pulumi.Input[bool]] = None, include_query_string: Optional[pulumi.Input[bool]] = None, query_string_blacklists: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, query_string_whitelists: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[bool] include_host: If true requests to different hosts will be cached separately.
        :param pulumi.Input[bool] include_protocol: If true, http and https requests will be cached separately.
        :param pulumi.Input[bool] include_query_string: If true, include query string parameters in the cache key
               according to query_string_whitelist and
               query_string_blacklist. If neither is set, the entire query
               string will be included.
               If false, the query string will be excluded from the cache
               key entirely.
        :param pulumi.Input[List[pulumi.Input[str]]] query_string_blacklists: Names of query string parameters to exclude in cache keys.
               All other parameters will be included. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        :param pulumi.Input[List[pulumi.Input[str]]] query_string_whitelists: Names of query string parameters to include in cache keys.
               All other parameters will be excluded. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        """
        __self__.include_host = include_host
        __self__.include_protocol = include_protocol
        __self__.include_query_string = include_query_string
        __self__.query_string_blacklists = query_string_blacklists
        __self__.query_string_whitelists = query_string_whitelists

@pulumi.input_type
class BackendServiceCircuitBreakersArgs:
    connect_timeout: Optional[pulumi.Input['BackendServiceCircuitBreakersConnectTimeoutArgs']] = pulumi.input_property("connectTimeout")
    """
    The timeout for new network connections to hosts.  Structure is documented below.
    """
    max_connections: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnections")
    """
    The maximum number of connections to the backend cluster.
    Defaults to 1024.
    """
    max_pending_requests: Optional[pulumi.Input[float]] = pulumi.input_property("maxPendingRequests")
    """
    The maximum number of pending requests to the backend cluster.
    Defaults to 1024.
    """
    max_requests: Optional[pulumi.Input[float]] = pulumi.input_property("maxRequests")
    """
    The maximum number of parallel requests to the backend cluster.
    Defaults to 1024.
    """
    max_requests_per_connection: Optional[pulumi.Input[float]] = pulumi.input_property("maxRequestsPerConnection")
    """
    Maximum requests for a single backend connection. This parameter
    is respected by both the HTTP/1.1 and HTTP/2 implementations. If
    not specified, there is no limit. Setting this parameter to 1
    will effectively disable keep alive.
    """
    max_retries: Optional[pulumi.Input[float]] = pulumi.input_property("maxRetries")
    """
    The maximum number of parallel retries to the backend cluster.
    Defaults to 3.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, connect_timeout: Optional[pulumi.Input['BackendServiceCircuitBreakersConnectTimeoutArgs']] = None, max_connections: Optional[pulumi.Input[float]] = None, max_pending_requests: Optional[pulumi.Input[float]] = None, max_requests: Optional[pulumi.Input[float]] = None, max_requests_per_connection: Optional[pulumi.Input[float]] = None, max_retries: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['BackendServiceCircuitBreakersConnectTimeoutArgs'] connect_timeout: The timeout for new network connections to hosts.  Structure is documented below.
        :param pulumi.Input[float] max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param pulumi.Input[float] max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        __self__.connect_timeout = connect_timeout
        __self__.max_connections = max_connections
        __self__.max_pending_requests = max_pending_requests
        __self__.max_requests = max_requests
        __self__.max_requests_per_connection = max_requests_per_connection
        __self__.max_retries = max_retries

@pulumi.input_type
class BackendServiceCircuitBreakersConnectTimeoutArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class BackendServiceConsistentHashArgs:
    http_cookie: Optional[pulumi.Input['BackendServiceConsistentHashHttpCookieArgs']] = pulumi.input_property("httpCookie")
    """
    Hash is based on HTTP Cookie. This field describes a HTTP cookie
    that will be used as the hash key for the consistent hash load
    balancer. If the cookie is not present, it will be generated.
    This field is applicable if the sessionAffinity is set to HTTP_COOKIE.  Structure is documented below.
    """
    http_header_name: Optional[pulumi.Input[str]] = pulumi.input_property("httpHeaderName")
    """
    The hash based on the value of the specified header field.
    This field is applicable if the sessionAffinity is set to HEADER_FIELD.
    """
    minimum_ring_size: Optional[pulumi.Input[float]] = pulumi.input_property("minimumRingSize")
    """
    The minimum number of virtual nodes to use for the hash ring.
    Larger ring sizes result in more granular load
    distributions. If the number of hosts in the load balancing pool
    is larger than the ring size, each host will be assigned a single
    virtual node.
    Defaults to 1024.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_cookie: Optional[pulumi.Input['BackendServiceConsistentHashHttpCookieArgs']] = None, http_header_name: Optional[pulumi.Input[str]] = None, minimum_ring_size: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['BackendServiceConsistentHashHttpCookieArgs'] http_cookie: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.  Structure is documented below.
        :param pulumi.Input[str] http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param pulumi.Input[float] minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        __self__.http_cookie = http_cookie
        __self__.http_header_name = http_header_name
        __self__.minimum_ring_size = minimum_ring_size

@pulumi.input_type
class BackendServiceConsistentHashHttpCookieArgs:
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    Name of the cookie.
    """
    path: Optional[pulumi.Input[str]] = pulumi.input_property("path")
    """
    Path to set for the cookie.
    """
    ttl: Optional[pulumi.Input['BackendServiceConsistentHashHttpCookieTtlArgs']] = pulumi.input_property("ttl")
    """
    Lifetime of the cookie.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: Optional[pulumi.Input[str]] = None, path: Optional[pulumi.Input[str]] = None, ttl: Optional[pulumi.Input['BackendServiceConsistentHashHttpCookieTtlArgs']] = None) -> None:
        """
        :param pulumi.Input[str] name: Name of the cookie.
        :param pulumi.Input[str] path: Path to set for the cookie.
        :param pulumi.Input['BackendServiceConsistentHashHttpCookieTtlArgs'] ttl: Lifetime of the cookie.  Structure is documented below.
        """
        __self__.name = name
        __self__.path = path
        __self__.ttl = ttl

@pulumi.input_type
class BackendServiceConsistentHashHttpCookieTtlArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class BackendServiceIapArgs:
    oauth2_client_id: pulumi.Input[str] = pulumi.input_property("oauth2ClientId")
    """
    OAuth2 Client ID for IAP
    """
    oauth2_client_secret: pulumi.Input[str] = pulumi.input_property("oauth2ClientSecret")
    """
    OAuth2 Client Secret for IAP  **Note**: This property is sensitive and will not be displayed in the plan.
    """
    oauth2_client_secret_sha256: Optional[pulumi.Input[str]] = pulumi.input_property("oauth2ClientSecretSha256")
    """
    -
    OAuth2 Client Secret SHA-256 for IAP  **Note**: This property is sensitive and will not be displayed in the plan.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, oauth2_client_id: pulumi.Input[str], oauth2_client_secret: pulumi.Input[str], oauth2_client_secret_sha256: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] oauth2_client_id: OAuth2 Client ID for IAP
        :param pulumi.Input[str] oauth2_client_secret: OAuth2 Client Secret for IAP  **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] oauth2_client_secret_sha256: -
               OAuth2 Client Secret SHA-256 for IAP  **Note**: This property is sensitive and will not be displayed in the plan.
        """
        __self__.oauth2_client_id = oauth2_client_id
        __self__.oauth2_client_secret = oauth2_client_secret
        __self__.oauth2_client_secret_sha256 = oauth2_client_secret_sha256

@pulumi.input_type
class BackendServiceLogConfigArgs:
    enable: Optional[pulumi.Input[bool]] = pulumi.input_property("enable")
    """
    Whether to enable logging for the load balancer traffic served by this backend service.
    """
    sample_rate: Optional[pulumi.Input[float]] = pulumi.input_property("sampleRate")
    """
    This field can only be specified if logging is enabled for this backend service. The value of
    the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
    where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
    The default value is 1.0.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable: Optional[pulumi.Input[bool]] = None, sample_rate: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param pulumi.Input[float] sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        __self__.enable = enable
        __self__.sample_rate = sample_rate

@pulumi.input_type
class BackendServiceOutlierDetectionArgs:
    base_ejection_time: Optional[pulumi.Input['BackendServiceOutlierDetectionBaseEjectionTimeArgs']] = pulumi.input_property("baseEjectionTime")
    """
    The base time that a host is ejected for. The real time is equal to the base
    time multiplied by the number of times the host has been ejected. Defaults to
    30000ms or 30s.  Structure is documented below.
    """
    consecutive_errors: Optional[pulumi.Input[float]] = pulumi.input_property("consecutiveErrors")
    """
    Number of errors before a host is ejected from the connection pool. When the
    backend host is accessed over HTTP, a 5xx return code qualifies as an error.
    Defaults to 5.
    """
    consecutive_gateway_failure: Optional[pulumi.Input[float]] = pulumi.input_property("consecutiveGatewayFailure")
    """
    The number of consecutive gateway failures (502, 503, 504 status or connection
    errors that are mapped to one of those status codes) before a consecutive
    gateway failure ejection occurs. Defaults to 5.
    """
    enforcing_consecutive_errors: Optional[pulumi.Input[float]] = pulumi.input_property("enforcingConsecutiveErrors")
    """
    The percentage chance that a host will be actually ejected when an outlier
    status is detected through consecutive 5xx. This setting can be used to disable
    ejection or to ramp it up slowly. Defaults to 100.
    """
    enforcing_consecutive_gateway_failure: Optional[pulumi.Input[float]] = pulumi.input_property("enforcingConsecutiveGatewayFailure")
    """
    The percentage chance that a host will be actually ejected when an outlier
    status is detected through consecutive gateway failures. This setting can be
    used to disable ejection or to ramp it up slowly. Defaults to 0.
    """
    enforcing_success_rate: Optional[pulumi.Input[float]] = pulumi.input_property("enforcingSuccessRate")
    """
    The percentage chance that a host will be actually ejected when an outlier
    status is detected through success rate statistics. This setting can be used to
    disable ejection or to ramp it up slowly. Defaults to 100.
    """
    interval: Optional[pulumi.Input['BackendServiceOutlierDetectionIntervalArgs']] = pulumi.input_property("interval")
    """
    Time interval between ejection sweep analysis. This can result in both new
    ejections as well as hosts being returned to service. Defaults to 10 seconds.  Structure is documented below.
    """
    max_ejection_percent: Optional[pulumi.Input[float]] = pulumi.input_property("maxEjectionPercent")
    """
    Maximum percentage of hosts in the load balancing pool for the backend service
    that can be ejected. Defaults to 10%.
    """
    success_rate_minimum_hosts: Optional[pulumi.Input[float]] = pulumi.input_property("successRateMinimumHosts")
    """
    The number of hosts in a cluster that must have enough request volume to detect
    success rate outliers. If the number of hosts is less than this setting, outlier
    detection via success rate statistics is not performed for any host in the
    cluster. Defaults to 5.
    """
    success_rate_request_volume: Optional[pulumi.Input[float]] = pulumi.input_property("successRateRequestVolume")
    """
    The minimum number of total requests that must be collected in one interval (as
    defined by the interval duration above) to include this host in success rate
    based outlier detection. If the volume is lower than this setting, outlier
    detection via success rate statistics is not performed for that host. Defaults
    to 100.
    """
    success_rate_stdev_factor: Optional[pulumi.Input[float]] = pulumi.input_property("successRateStdevFactor")
    """
    This factor is used to determine the ejection threshold for success rate outlier
    ejection. The ejection threshold is the difference between the mean success
    rate, and the product of this factor and the standard deviation of the mean
    success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
    by a thousand to get a double. That is, if the desired factor is 1.9, the
    runtime value should be 1900. Defaults to 1900.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, base_ejection_time: Optional[pulumi.Input['BackendServiceOutlierDetectionBaseEjectionTimeArgs']] = None, consecutive_errors: Optional[pulumi.Input[float]] = None, consecutive_gateway_failure: Optional[pulumi.Input[float]] = None, enforcing_consecutive_errors: Optional[pulumi.Input[float]] = None, enforcing_consecutive_gateway_failure: Optional[pulumi.Input[float]] = None, enforcing_success_rate: Optional[pulumi.Input[float]] = None, interval: Optional[pulumi.Input['BackendServiceOutlierDetectionIntervalArgs']] = None, max_ejection_percent: Optional[pulumi.Input[float]] = None, success_rate_minimum_hosts: Optional[pulumi.Input[float]] = None, success_rate_request_volume: Optional[pulumi.Input[float]] = None, success_rate_stdev_factor: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['BackendServiceOutlierDetectionBaseEjectionTimeArgs'] base_ejection_time: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.  Structure is documented below.
        :param pulumi.Input[float] consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param pulumi.Input[float] consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param pulumi.Input[float] enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param pulumi.Input[float] enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param pulumi.Input[float] enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param pulumi.Input['BackendServiceOutlierDetectionIntervalArgs'] interval: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.  Structure is documented below.
        :param pulumi.Input[float] max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param pulumi.Input[float] success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param pulumi.Input[float] success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param pulumi.Input[float] success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        __self__.base_ejection_time = base_ejection_time
        __self__.consecutive_errors = consecutive_errors
        __self__.consecutive_gateway_failure = consecutive_gateway_failure
        __self__.enforcing_consecutive_errors = enforcing_consecutive_errors
        __self__.enforcing_consecutive_gateway_failure = enforcing_consecutive_gateway_failure
        __self__.enforcing_success_rate = enforcing_success_rate
        __self__.interval = interval
        __self__.max_ejection_percent = max_ejection_percent
        __self__.success_rate_minimum_hosts = success_rate_minimum_hosts
        __self__.success_rate_request_volume = success_rate_request_volume
        __self__.success_rate_stdev_factor = success_rate_stdev_factor

@pulumi.input_type
class BackendServiceOutlierDetectionBaseEjectionTimeArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class BackendServiceOutlierDetectionIntervalArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class DiskDiskEncryptionKeyArgs:
    kms_key_self_link: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeySelfLink")
    """
    The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
    in the cloud console. Your project's Compute Engine System service account
    (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
    `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
    See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
    """
    raw_key: Optional[pulumi.Input[str]] = pulumi.input_property("rawKey")
    """
    Specifies a 256-bit customer-supplied encryption key, encoded in
    RFC 4648 base64 to either encrypt or decrypt this resource.
    """
    sha256: Optional[pulumi.Input[str]] = pulumi.input_property("sha256")
    """
    -
    The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
    encryption key that protects this resource.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, kms_key_self_link: Optional[pulumi.Input[str]] = None, raw_key: Optional[pulumi.Input[str]] = None, sha256: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param pulumi.Input[str] raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param pulumi.Input[str] sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        __self__.kms_key_self_link = kms_key_self_link
        __self__.raw_key = raw_key
        __self__.sha256 = sha256

@pulumi.input_type
class DiskSourceImageEncryptionKeyArgs:
    kms_key_self_link: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeySelfLink")
    """
    The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
    in the cloud console. Your project's Compute Engine System service account
    (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
    `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
    See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
    """
    raw_key: Optional[pulumi.Input[str]] = pulumi.input_property("rawKey")
    """
    Specifies a 256-bit customer-supplied encryption key, encoded in
    RFC 4648 base64 to either encrypt or decrypt this resource.
    """
    sha256: Optional[pulumi.Input[str]] = pulumi.input_property("sha256")
    """
    -
    The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
    encryption key that protects this resource.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, kms_key_self_link: Optional[pulumi.Input[str]] = None, raw_key: Optional[pulumi.Input[str]] = None, sha256: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param pulumi.Input[str] raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param pulumi.Input[str] sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        __self__.kms_key_self_link = kms_key_self_link
        __self__.raw_key = raw_key
        __self__.sha256 = sha256

@pulumi.input_type
class DiskSourceSnapshotEncryptionKeyArgs:
    kms_key_self_link: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeySelfLink")
    """
    The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
    in the cloud console. Your project's Compute Engine System service account
    (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
    `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
    See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
    """
    raw_key: Optional[pulumi.Input[str]] = pulumi.input_property("rawKey")
    """
    Specifies a 256-bit customer-supplied encryption key, encoded in
    RFC 4648 base64 to either encrypt or decrypt this resource.
    """
    sha256: Optional[pulumi.Input[str]] = pulumi.input_property("sha256")
    """
    -
    The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
    encryption key that protects this resource.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, kms_key_self_link: Optional[pulumi.Input[str]] = None, raw_key: Optional[pulumi.Input[str]] = None, sha256: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param pulumi.Input[str] raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param pulumi.Input[str] sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        __self__.kms_key_self_link = kms_key_self_link
        __self__.raw_key = raw_key
        __self__.sha256 = sha256

@pulumi.input_type
class ExternalVpnGatewayInterfaceArgs:
    id: Optional[pulumi.Input[float]] = pulumi.input_property("id")
    """
    The numberic ID for this interface. Allowed values are based on the redundancy type
    of this external VPN gateway
    * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
    * `0, 1 - TWO_IPS_REDUNDANCY`
    * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
    """
    ip_address: Optional[pulumi.Input[str]] = pulumi.input_property("ipAddress")
    """
    IP address of the interface in the external VPN gateway.
    Only IPv4 is supported. This IP address can be either from
    your on-premise gateway or another Cloud providers VPN gateway,
    it cannot be an IP address from Google Compute Engine.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, id: Optional[pulumi.Input[float]] = None, ip_address: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] id: The numberic ID for this interface. Allowed values are based on the redundancy type
               of this external VPN gateway
               * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
               * `0, 1 - TWO_IPS_REDUNDANCY`
               * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
        :param pulumi.Input[str] ip_address: IP address of the interface in the external VPN gateway.
               Only IPv4 is supported. This IP address can be either from
               your on-premise gateway or another Cloud providers VPN gateway,
               it cannot be an IP address from Google Compute Engine.
        """
        __self__.id = id
        __self__.ip_address = ip_address

@pulumi.input_type
class FirewallAllowArgs:
    protocol: pulumi.Input[str] = pulumi.input_property("protocol")
    """
    The IP protocol to which this rule applies. The protocol type is
    required when creating a firewall rule. This value can either be
    one of the following well known protocol strings (tcp, udp,
    icmp, esp, ah, sctp, ipip), or the IP protocol number.
    """
    ports: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("ports")
    """
    An optional list of ports to which this rule applies. This field
    is only applicable for UDP or TCP protocol. Each entry must be
    either an integer or a range. If not specified, this rule
    applies to connections through any port.
    Example inputs include: ["22"], ["80","443"], and
    ["12345-12349"].
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, protocol: pulumi.Input[str], ports: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[str] protocol: The IP protocol to which this rule applies. The protocol type is
               required when creating a firewall rule. This value can either be
               one of the following well known protocol strings (tcp, udp,
               icmp, esp, ah, sctp, ipip), or the IP protocol number.
        :param pulumi.Input[List[pulumi.Input[str]]] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        __self__.protocol = protocol
        __self__.ports = ports

@pulumi.input_type
class FirewallDenyArgs:
    protocol: pulumi.Input[str] = pulumi.input_property("protocol")
    """
    The IP protocol to which this rule applies. The protocol type is
    required when creating a firewall rule. This value can either be
    one of the following well known protocol strings (tcp, udp,
    icmp, esp, ah, sctp, ipip), or the IP protocol number.
    """
    ports: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("ports")
    """
    An optional list of ports to which this rule applies. This field
    is only applicable for UDP or TCP protocol. Each entry must be
    either an integer or a range. If not specified, this rule
    applies to connections through any port.
    Example inputs include: ["22"], ["80","443"], and
    ["12345-12349"].
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, protocol: pulumi.Input[str], ports: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[str] protocol: The IP protocol to which this rule applies. The protocol type is
               required when creating a firewall rule. This value can either be
               one of the following well known protocol strings (tcp, udp,
               icmp, esp, ah, sctp, ipip), or the IP protocol number.
        :param pulumi.Input[List[pulumi.Input[str]]] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        __self__.protocol = protocol
        __self__.ports = ports

@pulumi.input_type
class GlobalForwardingRuleMetadataFilterArgs:
    filter_labels: pulumi.Input[List[pulumi.Input['GlobalForwardingRuleMetadataFilterFilterLabelArgs']]] = pulumi.input_property("filterLabels")
    """
    The list of label value pairs that must match labels in the
    provided metadata based on filterMatchCriteria
    This list must not be empty and can have at the most 64 entries.  Structure is documented below.
    """
    filter_match_criteria: pulumi.Input[str] = pulumi.input_property("filterMatchCriteria")
    """
    Specifies how individual filterLabel matches within the list of
    filterLabels contribute towards the overall metadataFilter match.
    MATCH_ANY - At least one of the filterLabels must have a matching
    label in the provided metadata.
    MATCH_ALL - All filterLabels must have matching labels in the
    provided metadata.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, filter_labels: pulumi.Input[List[pulumi.Input['GlobalForwardingRuleMetadataFilterFilterLabelArgs']]], filter_match_criteria: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['GlobalForwardingRuleMetadataFilterFilterLabelArgs']]] filter_labels: The list of label value pairs that must match labels in the
               provided metadata based on filterMatchCriteria
               This list must not be empty and can have at the most 64 entries.  Structure is documented below.
        :param pulumi.Input[str] filter_match_criteria: Specifies how individual filterLabel matches within the list of
               filterLabels contribute towards the overall metadataFilter match.
               MATCH_ANY - At least one of the filterLabels must have a matching
               label in the provided metadata.
               MATCH_ALL - All filterLabels must have matching labels in the
               provided metadata.
        """
        __self__.filter_labels = filter_labels
        __self__.filter_match_criteria = filter_match_criteria

@pulumi.input_type
class GlobalForwardingRuleMetadataFilterFilterLabelArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    Name of the metadata label. The length must be between
    1 and 1024 characters, inclusive.
    """
    value: pulumi.Input[str] = pulumi.input_property("value")
    """
    The value that the label must match. The value has a maximum
    length of 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], value: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] name: Name of the metadata label. The length must be between
               1 and 1024 characters, inclusive.
        :param pulumi.Input[str] value: The value that the label must match. The value has a maximum
               length of 1024 characters.
        """
        __self__.name = name
        __self__.value = value

@pulumi.input_type
class HaVpnGatewayVpnInterfaceArgs:
    id: Optional[pulumi.Input[float]] = pulumi.input_property("id")
    """
    an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
    """
    ip_address: Optional[pulumi.Input[str]] = pulumi.input_property("ipAddress")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, id: Optional[pulumi.Input[float]] = None, ip_address: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] id: an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
        """
        __self__.id = id
        __self__.ip_address = ip_address

@pulumi.input_type
class HealthCheckHttp2HealthCheckArgs:
    host: Optional[pulumi.Input[str]] = pulumi.input_property("host")
    """
    The value of the host header in the HTTP2 health check request.
    If left empty (default value), the public IP on behalf of which this health
    check is performed will be used.
    """
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request_path: Optional[pulumi.Input[str]] = pulumi.input_property("requestPath")
    """
    The request path of the HTTP2 health check request.
    The default value is /.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: Optional[pulumi.Input[str]] = None, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request_path: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.host = host
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request_path = request_path
        __self__.response = response

@pulumi.input_type
class HealthCheckHttpHealthCheckArgs:
    host: Optional[pulumi.Input[str]] = pulumi.input_property("host")
    """
    The value of the host header in the HTTP2 health check request.
    If left empty (default value), the public IP on behalf of which this health
    check is performed will be used.
    """
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request_path: Optional[pulumi.Input[str]] = pulumi.input_property("requestPath")
    """
    The request path of the HTTP2 health check request.
    The default value is /.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: Optional[pulumi.Input[str]] = None, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request_path: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.host = host
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request_path = request_path
        __self__.response = response

@pulumi.input_type
class HealthCheckHttpsHealthCheckArgs:
    host: Optional[pulumi.Input[str]] = pulumi.input_property("host")
    """
    The value of the host header in the HTTP2 health check request.
    If left empty (default value), the public IP on behalf of which this health
    check is performed will be used.
    """
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request_path: Optional[pulumi.Input[str]] = pulumi.input_property("requestPath")
    """
    The request path of the HTTP2 health check request.
    The default value is /.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: Optional[pulumi.Input[str]] = None, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request_path: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.host = host
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request_path = request_path
        __self__.response = response

@pulumi.input_type
class HealthCheckLogConfigArgs:
    enable: Optional[pulumi.Input[bool]] = pulumi.input_property("enable")
    """
    Indicates whether or not to export logs. This is false by default,
    which means no health check logging will be done.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[bool] enable: Indicates whether or not to export logs. This is false by default,
               which means no health check logging will be done.
        """
        __self__.enable = enable

@pulumi.input_type
class HealthCheckSslHealthCheckArgs:
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request: Optional[pulumi.Input[str]] = pulumi.input_property("request")
    """
    The application data to send once the SSL connection has been
    established (default value is empty). If both request and response are
    empty, the connection establishment alone will indicate health. The request
    data can only be ASCII.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request = request
        __self__.response = response

@pulumi.input_type
class HealthCheckTcpHealthCheckArgs:
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request: Optional[pulumi.Input[str]] = pulumi.input_property("request")
    """
    The application data to send once the SSL connection has been
    established (default value is empty). If both request and response are
    empty, the connection establishment alone will indicate health. The request
    data can only be ASCII.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request = request
        __self__.response = response

@pulumi.input_type
class ImageGuestOsFeatureArgs:
    type: pulumi.Input[str] = pulumi.input_property("type")
    """
    The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, type: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] type: The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        """
        __self__.type = type

@pulumi.input_type
class ImageRawDiskArgs:
    source: pulumi.Input[str] = pulumi.input_property("source")
    """
    The full Google Cloud Storage URL where disk storage is stored
    You must provide either this property or the sourceDisk property
    but not both.
    """
    container_type: Optional[pulumi.Input[str]] = pulumi.input_property("containerType")
    """
    The format used to encode and transmit the block device, which
    should be TAR. This is just a container and transmission format
    and not a runtime format. Provided by the client when the disk
    image is created.
    """
    sha1: Optional[pulumi.Input[str]] = pulumi.input_property("sha1")
    """
    An optional SHA1 checksum of the disk image before unpackaging.
    This is provided by the client when the disk image is created.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, source: pulumi.Input[str], container_type: Optional[pulumi.Input[str]] = None, sha1: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] source: The full Google Cloud Storage URL where disk storage is stored
               You must provide either this property or the sourceDisk property
               but not both.
        :param pulumi.Input[str] container_type: The format used to encode and transmit the block device, which
               should be TAR. This is just a container and transmission format
               and not a runtime format. Provided by the client when the disk
               image is created.
        :param pulumi.Input[str] sha1: An optional SHA1 checksum of the disk image before unpackaging.
               This is provided by the client when the disk image is created.
        """
        __self__.source = source
        __self__.container_type = container_type
        __self__.sha1 = sha1

@pulumi.input_type
class InstanceAttachedDiskArgs:
    source: pulumi.Input[str] = pulumi.input_property("source")
    """
    The name or self_link of the disk to attach to this instance.
    """
    device_name: Optional[pulumi.Input[str]] = pulumi.input_property("deviceName")
    """
    Name with which the attached disk will be accessible
    under `/dev/disk/by-id/google-*`
    """
    disk_encryption_key_raw: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeyRaw")
    """
    A 256-bit [customer-supplied encryption key]
    (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
    encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
    to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
    """
    disk_encryption_key_sha256: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeySha256")
    kms_key_self_link: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeySelfLink")
    """
    The self_link of the encryption key that is
    stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
    and `disk_encryption_key_raw` may be set.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
    If you have a persistent disk with data that you want to share
    between multiple instances, detach it from any read-write instances and
    attach it to one or more instances in read-only mode.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, source: pulumi.Input[str], device_name: Optional[pulumi.Input[str]] = None, disk_encryption_key_raw: Optional[pulumi.Input[str]] = None, disk_encryption_key_sha256: Optional[pulumi.Input[str]] = None, kms_key_self_link: Optional[pulumi.Input[str]] = None, mode: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] source: The name or self_link of the disk to attach to this instance.
        :param pulumi.Input[str] device_name: Name with which the attached disk will be accessible
               under `/dev/disk/by-id/google-*`
        :param pulumi.Input[str] disk_encryption_key_raw: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        :param pulumi.Input[str] kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
               and `disk_encryption_key_raw` may be set.
        :param pulumi.Input[str] mode: Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
               If you have a persistent disk with data that you want to share
               between multiple instances, detach it from any read-write instances and
               attach it to one or more instances in read-only mode.
        """
        __self__.source = source
        __self__.device_name = device_name
        __self__.disk_encryption_key_raw = disk_encryption_key_raw
        __self__.disk_encryption_key_sha256 = disk_encryption_key_sha256
        __self__.kms_key_self_link = kms_key_self_link
        __self__.mode = mode

@pulumi.input_type
class InstanceBootDiskArgs:
    auto_delete: Optional[pulumi.Input[bool]] = pulumi.input_property("autoDelete")
    """
    Whether the disk will be auto-deleted when the instance
    is deleted. Defaults to true.
    """
    device_name: Optional[pulumi.Input[str]] = pulumi.input_property("deviceName")
    """
    Name with which the attached disk will be accessible
    under `/dev/disk/by-id/google-*`
    """
    disk_encryption_key_raw: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeyRaw")
    """
    A 256-bit [customer-supplied encryption key]
    (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
    encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
    to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
    """
    disk_encryption_key_sha256: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeySha256")
    initialize_params: Optional[pulumi.Input['InstanceBootDiskInitializeParamsArgs']] = pulumi.input_property("initializeParams")
    """
    Parameters for a new disk that will be created
    alongside the new instance. Either `initialize_params` or `source` must be set.
    Structure is documented below.
    """
    kms_key_self_link: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeySelfLink")
    """
    The self_link of the encryption key that is
    stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
    and `disk_encryption_key_raw` may be set.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
    If you have a persistent disk with data that you want to share
    between multiple instances, detach it from any read-write instances and
    attach it to one or more instances in read-only mode.
    """
    source: Optional[pulumi.Input[str]] = pulumi.input_property("source")
    """
    The name or self_link of the disk to attach to this instance.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, auto_delete: Optional[pulumi.Input[bool]] = None, device_name: Optional[pulumi.Input[str]] = None, disk_encryption_key_raw: Optional[pulumi.Input[str]] = None, disk_encryption_key_sha256: Optional[pulumi.Input[str]] = None, initialize_params: Optional[pulumi.Input['InstanceBootDiskInitializeParamsArgs']] = None, kms_key_self_link: Optional[pulumi.Input[str]] = None, mode: Optional[pulumi.Input[str]] = None, source: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] auto_delete: Whether the disk will be auto-deleted when the instance
               is deleted. Defaults to true.
        :param pulumi.Input[str] device_name: Name with which the attached disk will be accessible
               under `/dev/disk/by-id/google-*`
        :param pulumi.Input[str] disk_encryption_key_raw: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        :param pulumi.Input['InstanceBootDiskInitializeParamsArgs'] initialize_params: Parameters for a new disk that will be created
               alongside the new instance. Either `initialize_params` or `source` must be set.
               Structure is documented below.
        :param pulumi.Input[str] kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
               and `disk_encryption_key_raw` may be set.
        :param pulumi.Input[str] mode: Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
               If you have a persistent disk with data that you want to share
               between multiple instances, detach it from any read-write instances and
               attach it to one or more instances in read-only mode.
        :param pulumi.Input[str] source: The name or self_link of the disk to attach to this instance.
        """
        __self__.auto_delete = auto_delete
        __self__.device_name = device_name
        __self__.disk_encryption_key_raw = disk_encryption_key_raw
        __self__.disk_encryption_key_sha256 = disk_encryption_key_sha256
        __self__.initialize_params = initialize_params
        __self__.kms_key_self_link = kms_key_self_link
        __self__.mode = mode
        __self__.source = source

@pulumi.input_type
class InstanceBootDiskInitializeParamsArgs:
    image: Optional[pulumi.Input[str]] = pulumi.input_property("image")
    """
    The image from which to initialize this disk. This can be
    one of: the image's `self_link`, `projects/{project}/global/images/{image}`,
    `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
    `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
    `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
    images names must include the family name. If they don't, use the
    [compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
    For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
    These images can be referred by family name here.
    """
    labels: Optional[pulumi.Input[Dict[str, Any]]] = pulumi.input_property("labels")
    """
    A map of key/value label pairs to assign to the instance.
    """
    size: Optional[pulumi.Input[float]] = pulumi.input_property("size")
    """
    The size of the image in gigabytes. If not specified, it
    will inherit the size of its base image.
    """
    type: Optional[pulumi.Input[str]] = pulumi.input_property("type")
    """
    The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, image: Optional[pulumi.Input[str]] = None, labels: Optional[pulumi.Input[Dict[str, Any]]] = None, size: Optional[pulumi.Input[float]] = None, type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] image: The image from which to initialize this disk. This can be
               one of: the image's `self_link`, `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
               images names must include the family name. If they don't, use the
               [compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
               For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
               These images can be referred by family name here.
        :param pulumi.Input[Dict[str, Any]] labels: A map of key/value label pairs to assign to the instance.
        :param pulumi.Input[float] size: The size of the image in gigabytes. If not specified, it
               will inherit the size of its base image.
        :param pulumi.Input[str] type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        __self__.image = image
        __self__.labels = labels
        __self__.size = size
        __self__.type = type

@pulumi.input_type
class InstanceFromTemplateAttachedDiskArgs:
    source: pulumi.Input[str] = pulumi.input_property("source")
    device_name: Optional[pulumi.Input[str]] = pulumi.input_property("deviceName")
    disk_encryption_key_raw: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeyRaw")
    disk_encryption_key_sha256: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeySha256")
    kms_key_self_link: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeySelfLink")
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, source: pulumi.Input[str], device_name: Optional[pulumi.Input[str]] = None, disk_encryption_key_raw: Optional[pulumi.Input[str]] = None, disk_encryption_key_sha256: Optional[pulumi.Input[str]] = None, kms_key_self_link: Optional[pulumi.Input[str]] = None, mode: Optional[pulumi.Input[str]] = None) -> None:
        __self__.source = source
        __self__.device_name = device_name
        __self__.disk_encryption_key_raw = disk_encryption_key_raw
        __self__.disk_encryption_key_sha256 = disk_encryption_key_sha256
        __self__.kms_key_self_link = kms_key_self_link
        __self__.mode = mode

@pulumi.input_type
class InstanceFromTemplateBootDiskArgs:
    auto_delete: Optional[pulumi.Input[bool]] = pulumi.input_property("autoDelete")
    device_name: Optional[pulumi.Input[str]] = pulumi.input_property("deviceName")
    disk_encryption_key_raw: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeyRaw")
    disk_encryption_key_sha256: Optional[pulumi.Input[str]] = pulumi.input_property("diskEncryptionKeySha256")
    initialize_params: Optional[pulumi.Input['InstanceFromTemplateBootDiskInitializeParamsArgs']] = pulumi.input_property("initializeParams")
    kms_key_self_link: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeySelfLink")
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    source: Optional[pulumi.Input[str]] = pulumi.input_property("source")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, auto_delete: Optional[pulumi.Input[bool]] = None, device_name: Optional[pulumi.Input[str]] = None, disk_encryption_key_raw: Optional[pulumi.Input[str]] = None, disk_encryption_key_sha256: Optional[pulumi.Input[str]] = None, initialize_params: Optional[pulumi.Input['InstanceFromTemplateBootDiskInitializeParamsArgs']] = None, kms_key_self_link: Optional[pulumi.Input[str]] = None, mode: Optional[pulumi.Input[str]] = None, source: Optional[pulumi.Input[str]] = None) -> None:
        __self__.auto_delete = auto_delete
        __self__.device_name = device_name
        __self__.disk_encryption_key_raw = disk_encryption_key_raw
        __self__.disk_encryption_key_sha256 = disk_encryption_key_sha256
        __self__.initialize_params = initialize_params
        __self__.kms_key_self_link = kms_key_self_link
        __self__.mode = mode
        __self__.source = source

@pulumi.input_type
class InstanceFromTemplateBootDiskInitializeParamsArgs:
    image: Optional[pulumi.Input[str]] = pulumi.input_property("image")
    labels: Optional[pulumi.Input[Dict[str, Any]]] = pulumi.input_property("labels")
    size: Optional[pulumi.Input[float]] = pulumi.input_property("size")
    type: Optional[pulumi.Input[str]] = pulumi.input_property("type")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, image: Optional[pulumi.Input[str]] = None, labels: Optional[pulumi.Input[Dict[str, Any]]] = None, size: Optional[pulumi.Input[float]] = None, type: Optional[pulumi.Input[str]] = None) -> None:
        __self__.image = image
        __self__.labels = labels
        __self__.size = size
        __self__.type = type

@pulumi.input_type
class InstanceFromTemplateGuestAcceleratorArgs:
    count: pulumi.Input[float] = pulumi.input_property("count")
    type: pulumi.Input[str] = pulumi.input_property("type")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, count: pulumi.Input[float], type: pulumi.Input[str]) -> None:
        __self__.count = count
        __self__.type = type

@pulumi.input_type
class InstanceFromTemplateNetworkInterfaceArgs:
    access_configs: Optional[pulumi.Input[List[pulumi.Input['InstanceFromTemplateNetworkInterfaceAccessConfigArgs']]]] = pulumi.input_property("accessConfigs")
    alias_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['InstanceFromTemplateNetworkInterfaceAliasIpRangeArgs']]]] = pulumi.input_property("aliasIpRanges")
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    A unique name for the resource, required by GCE.
    Changing this forces a new resource to be created.
    """
    network: Optional[pulumi.Input[str]] = pulumi.input_property("network")
    network_ip: Optional[pulumi.Input[str]] = pulumi.input_property("networkIp")
    subnetwork: Optional[pulumi.Input[str]] = pulumi.input_property("subnetwork")
    subnetwork_project: Optional[pulumi.Input[str]] = pulumi.input_property("subnetworkProject")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, access_configs: Optional[pulumi.Input[List[pulumi.Input['InstanceFromTemplateNetworkInterfaceAccessConfigArgs']]]] = None, alias_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['InstanceFromTemplateNetworkInterfaceAliasIpRangeArgs']]]] = None, name: Optional[pulumi.Input[str]] = None, network: Optional[pulumi.Input[str]] = None, network_ip: Optional[pulumi.Input[str]] = None, subnetwork: Optional[pulumi.Input[str]] = None, subnetwork_project: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        """
        __self__.access_configs = access_configs
        __self__.alias_ip_ranges = alias_ip_ranges
        __self__.name = name
        __self__.network = network
        __self__.network_ip = network_ip
        __self__.subnetwork = subnetwork
        __self__.subnetwork_project = subnetwork_project

@pulumi.input_type
class InstanceFromTemplateNetworkInterfaceAccessConfigArgs:
    nat_ip: Optional[pulumi.Input[str]] = pulumi.input_property("natIp")
    network_tier: Optional[pulumi.Input[str]] = pulumi.input_property("networkTier")
    public_ptr_domain_name: Optional[pulumi.Input[str]] = pulumi.input_property("publicPtrDomainName")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nat_ip: Optional[pulumi.Input[str]] = None, network_tier: Optional[pulumi.Input[str]] = None, public_ptr_domain_name: Optional[pulumi.Input[str]] = None) -> None:
        __self__.nat_ip = nat_ip
        __self__.network_tier = network_tier
        __self__.public_ptr_domain_name = public_ptr_domain_name

@pulumi.input_type
class InstanceFromTemplateNetworkInterfaceAliasIpRangeArgs:
    ip_cidr_range: pulumi.Input[str] = pulumi.input_property("ipCidrRange")
    subnetwork_range_name: Optional[pulumi.Input[str]] = pulumi.input_property("subnetworkRangeName")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, ip_cidr_range: pulumi.Input[str], subnetwork_range_name: Optional[pulumi.Input[str]] = None) -> None:
        __self__.ip_cidr_range = ip_cidr_range
        __self__.subnetwork_range_name = subnetwork_range_name

@pulumi.input_type
class InstanceFromTemplateSchedulingArgs:
    automatic_restart: Optional[pulumi.Input[bool]] = pulumi.input_property("automaticRestart")
    min_node_cpus: Optional[pulumi.Input[float]] = pulumi.input_property("minNodeCpus")
    node_affinities: Optional[pulumi.Input[List[pulumi.Input['InstanceFromTemplateSchedulingNodeAffinityArgs']]]] = pulumi.input_property("nodeAffinities")
    on_host_maintenance: Optional[pulumi.Input[str]] = pulumi.input_property("onHostMaintenance")
    preemptible: Optional[pulumi.Input[bool]] = pulumi.input_property("preemptible")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, automatic_restart: Optional[pulumi.Input[bool]] = None, min_node_cpus: Optional[pulumi.Input[float]] = None, node_affinities: Optional[pulumi.Input[List[pulumi.Input['InstanceFromTemplateSchedulingNodeAffinityArgs']]]] = None, on_host_maintenance: Optional[pulumi.Input[str]] = None, preemptible: Optional[pulumi.Input[bool]] = None) -> None:
        __self__.automatic_restart = automatic_restart
        __self__.min_node_cpus = min_node_cpus
        __self__.node_affinities = node_affinities
        __self__.on_host_maintenance = on_host_maintenance
        __self__.preemptible = preemptible

@pulumi.input_type
class InstanceFromTemplateSchedulingNodeAffinityArgs:
    key: pulumi.Input[str] = pulumi.input_property("key")
    operator: pulumi.Input[str] = pulumi.input_property("operator")
    values: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("values")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, key: pulumi.Input[str], operator: pulumi.Input[str], values: pulumi.Input[List[pulumi.Input[str]]]) -> None:
        __self__.key = key
        __self__.operator = operator
        __self__.values = values

@pulumi.input_type
class InstanceFromTemplateScratchDiskArgs:
    interface: pulumi.Input[str] = pulumi.input_property("interface")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, interface: pulumi.Input[str]) -> None:
        __self__.interface = interface

@pulumi.input_type
class InstanceFromTemplateServiceAccountArgs:
    scopes: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("scopes")
    email: Optional[pulumi.Input[str]] = pulumi.input_property("email")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, scopes: pulumi.Input[List[pulumi.Input[str]]], email: Optional[pulumi.Input[str]] = None) -> None:
        __self__.scopes = scopes
        __self__.email = email

@pulumi.input_type
class InstanceFromTemplateShieldedInstanceConfigArgs:
    enable_integrity_monitoring: Optional[pulumi.Input[bool]] = pulumi.input_property("enableIntegrityMonitoring")
    enable_secure_boot: Optional[pulumi.Input[bool]] = pulumi.input_property("enableSecureBoot")
    enable_vtpm: Optional[pulumi.Input[bool]] = pulumi.input_property("enableVtpm")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None, enable_secure_boot: Optional[pulumi.Input[bool]] = None, enable_vtpm: Optional[pulumi.Input[bool]] = None) -> None:
        __self__.enable_integrity_monitoring = enable_integrity_monitoring
        __self__.enable_secure_boot = enable_secure_boot
        __self__.enable_vtpm = enable_vtpm

@pulumi.input_type
class InstanceGroupManagerAutoHealingPoliciesArgs:
    health_check: pulumi.Input[str] = pulumi.input_property("healthCheck")
    """
    The health check resource that signals autohealing.
    """
    initial_delay_sec: pulumi.Input[float] = pulumi.input_property("initialDelaySec")
    """
    The number of seconds that the managed instance group waits before
    it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, health_check: pulumi.Input[str], initial_delay_sec: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[str] health_check: The health check resource that signals autohealing.
        :param pulumi.Input[float] initial_delay_sec: The number of seconds that the managed instance group waits before
               it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        __self__.health_check = health_check
        __self__.initial_delay_sec = initial_delay_sec

@pulumi.input_type
class InstanceGroupManagerNamedPortArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    - Version name.
    """
    port: pulumi.Input[float] = pulumi.input_property("port")
    """
    The port number.
    - - -
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], port: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[str] name: - Version name.
        :param pulumi.Input[float] port: The port number.
               - - -
        """
        __self__.name = name
        __self__.port = port

@pulumi.input_type
class InstanceGroupManagerStatefulDiskArgs:
    device_name: pulumi.Input[str] = pulumi.input_property("deviceName")
    """
    , The device name of the disk to be attached.
    """
    delete_rule: Optional[pulumi.Input[str]] = pulumi.input_property("deleteRule")
    """
    , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` detatch the disk when the VM is deleted, but not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, device_name: pulumi.Input[str], delete_rule: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] device_name: , The device name of the disk to be attached.
        :param pulumi.Input[str] delete_rule: , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` detatch the disk when the VM is deleted, but not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        __self__.device_name = device_name
        __self__.delete_rule = delete_rule

@pulumi.input_type
class InstanceGroupManagerUpdatePolicyArgs:
    minimal_action: pulumi.Input[str] = pulumi.input_property("minimalAction")
    """
    - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    """
    type: pulumi.Input[str] = pulumi.input_property("type")
    """
    - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    """
    max_surge_fixed: Optional[pulumi.Input[float]] = pulumi.input_property("maxSurgeFixed")
    """
    , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. If neither is set, defaults to 1
    """
    max_surge_percent: Optional[pulumi.Input[float]] = pulumi.input_property("maxSurgePercent")
    """
    , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`.
    """
    max_unavailable_fixed: Optional[pulumi.Input[float]] = pulumi.input_property("maxUnavailableFixed")
    """
    , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. If neither is set, defaults to 1
    """
    max_unavailable_percent: Optional[pulumi.Input[float]] = pulumi.input_property("maxUnavailablePercent")
    """
    , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`.
    """
    min_ready_sec: Optional[pulumi.Input[float]] = pulumi.input_property("minReadySec")
    """
    , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
    - - -
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, minimal_action: pulumi.Input[str], type: pulumi.Input[str], max_surge_fixed: Optional[pulumi.Input[float]] = None, max_surge_percent: Optional[pulumi.Input[float]] = None, max_unavailable_fixed: Optional[pulumi.Input[float]] = None, max_unavailable_percent: Optional[pulumi.Input[float]] = None, min_ready_sec: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] minimal_action: - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param pulumi.Input[str] type: - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        :param pulumi.Input[float] max_surge_fixed: , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. If neither is set, defaults to 1
        :param pulumi.Input[float] max_surge_percent: , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`.
        :param pulumi.Input[float] max_unavailable_fixed: , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. If neither is set, defaults to 1
        :param pulumi.Input[float] max_unavailable_percent: , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`.
        :param pulumi.Input[float] min_ready_sec: , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
               - - -
        """
        __self__.minimal_action = minimal_action
        __self__.type = type
        __self__.max_surge_fixed = max_surge_fixed
        __self__.max_surge_percent = max_surge_percent
        __self__.max_unavailable_fixed = max_unavailable_fixed
        __self__.max_unavailable_percent = max_unavailable_percent
        __self__.min_ready_sec = min_ready_sec

@pulumi.input_type
class InstanceGroupManagerVersionArgs:
    instance_template: pulumi.Input[str] = pulumi.input_property("instanceTemplate")
    """
    - The full URL to an instance template from which all new instances of this version will be created.
    """
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    - Version name.
    """
    target_size: Optional[pulumi.Input['InstanceGroupManagerVersionTargetSizeArgs']] = pulumi.input_property("targetSize")
    """
    - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, instance_template: pulumi.Input[str], name: Optional[pulumi.Input[str]] = None, target_size: Optional[pulumi.Input['InstanceGroupManagerVersionTargetSizeArgs']] = None) -> None:
        """
        :param pulumi.Input[str] instance_template: - The full URL to an instance template from which all new instances of this version will be created.
        :param pulumi.Input[str] name: - Version name.
        :param pulumi.Input['InstanceGroupManagerVersionTargetSizeArgs'] target_size: - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        __self__.instance_template = instance_template
        __self__.name = name
        __self__.target_size = target_size

@pulumi.input_type
class InstanceGroupManagerVersionTargetSizeArgs:
    fixed: Optional[pulumi.Input[float]] = pulumi.input_property("fixed")
    """
    , The number of instances which are managed for this version. Conflicts with `percent`.
    """
    percent: Optional[pulumi.Input[float]] = pulumi.input_property("percent")
    """
    , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
    Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
    one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed: Optional[pulumi.Input[float]] = None, percent: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] fixed: , The number of instances which are managed for this version. Conflicts with `percent`.
        :param pulumi.Input[float] percent: , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
               Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
               one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        __self__.fixed = fixed
        __self__.percent = percent

@pulumi.input_type
class InstanceGroupNamedPortArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The name which the port will be mapped to.
    """
    port: pulumi.Input[float] = pulumi.input_property("port")
    """
    The port number to map the name to.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], port: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[str] name: The name which the port will be mapped to.
        :param pulumi.Input[float] port: The port number to map the name to.
        """
        __self__.name = name
        __self__.port = port

@pulumi.input_type
class InstanceGuestAcceleratorArgs:
    count: pulumi.Input[float] = pulumi.input_property("count")
    """
    The number of the guest accelerator cards exposed to this instance.
    """
    type: pulumi.Input[str] = pulumi.input_property("type")
    """
    The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, count: pulumi.Input[float], type: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[float] count: The number of the guest accelerator cards exposed to this instance.
        :param pulumi.Input[str] type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        __self__.count = count
        __self__.type = type

@pulumi.input_type
class InstanceIAMBindingConditionArgs:
    expression: pulumi.Input[str] = pulumi.input_property("expression")
    """
    Textual representation of an expression in Common Expression Language syntax.
    """
    title: pulumi.Input[str] = pulumi.input_property("title")
    """
    A title for the expression, i.e. a short string describing its purpose.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, expression: pulumi.Input[str], title: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        __self__.expression = expression
        __self__.title = title
        __self__.description = description

@pulumi.input_type
class InstanceIAMMemberConditionArgs:
    expression: pulumi.Input[str] = pulumi.input_property("expression")
    """
    Textual representation of an expression in Common Expression Language syntax.
    """
    title: pulumi.Input[str] = pulumi.input_property("title")
    """
    A title for the expression, i.e. a short string describing its purpose.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, expression: pulumi.Input[str], title: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        __self__.expression = expression
        __self__.title = title
        __self__.description = description

@pulumi.input_type
class InstanceNetworkInterfaceArgs:
    access_configs: Optional[pulumi.Input[List[pulumi.Input['InstanceNetworkInterfaceAccessConfigArgs']]]] = pulumi.input_property("accessConfigs")
    """
    Access configurations, i.e. IPs via which this
    instance can be accessed via the Internet. Omit to ensure that the instance
    is not accessible from the Internet. If omitted, ssh will not
    work unless this provider can send traffic to the instance's network (e.g. via
    tunnel or because it is running on another cloud instance on that network).
    This block can be repeated multiple times. Structure documented below.
    """
    alias_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['InstanceNetworkInterfaceAliasIpRangeArgs']]]] = pulumi.input_property("aliasIpRanges")
    """
    An
    array of alias IP ranges for this network interface. Can only be specified for network
    interfaces on subnet-mode networks. Structure documented below.
    """
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    A unique name for the resource, required by GCE.
    Changing this forces a new resource to be created.
    """
    network: Optional[pulumi.Input[str]] = pulumi.input_property("network")
    """
    The name or self_link of the network to attach this interface to.
    Either `network` or `subnetwork` must be provided.
    """
    network_ip: Optional[pulumi.Input[str]] = pulumi.input_property("networkIp")
    """
    The private IP address to assign to the instance. If
    empty, the address will be automatically assigned.
    """
    subnetwork: Optional[pulumi.Input[str]] = pulumi.input_property("subnetwork")
    """
    The name or self_link of the subnetwork to attach this
    interface to. The subnetwork must exist in the same region this instance will be
    created in. Either `network` or `subnetwork` must be provided.
    """
    subnetwork_project: Optional[pulumi.Input[str]] = pulumi.input_property("subnetworkProject")
    """
    The project in which the subnetwork belongs.
    If the `subnetwork` is a self_link, this field is ignored in favor of the project
    defined in the subnetwork self_link. If the `subnetwork` is a name and this
    field is not provided, the provider project is used.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, access_configs: Optional[pulumi.Input[List[pulumi.Input['InstanceNetworkInterfaceAccessConfigArgs']]]] = None, alias_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['InstanceNetworkInterfaceAliasIpRangeArgs']]]] = None, name: Optional[pulumi.Input[str]] = None, network: Optional[pulumi.Input[str]] = None, network_ip: Optional[pulumi.Input[str]] = None, subnetwork: Optional[pulumi.Input[str]] = None, subnetwork_project: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['InstanceNetworkInterfaceAccessConfigArgs']]] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Omit to ensure that the instance
               is not accessible from the Internet. If omitted, ssh will not
               work unless this provider can send traffic to the instance's network (e.g. via
               tunnel or because it is running on another cloud instance on that network).
               This block can be repeated multiple times. Structure documented below.
        :param pulumi.Input[List[pulumi.Input['InstanceNetworkInterfaceAliasIpRangeArgs']]] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param pulumi.Input[str] name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param pulumi.Input[str] network: The name or self_link of the network to attach this interface to.
               Either `network` or `subnetwork` must be provided.
        :param pulumi.Input[str] network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param pulumi.Input[str] subnetwork: The name or self_link of the subnetwork to attach this
               interface to. The subnetwork must exist in the same region this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param pulumi.Input[str] subnetwork_project: The project in which the subnetwork belongs.
               If the `subnetwork` is a self_link, this field is ignored in favor of the project
               defined in the subnetwork self_link. If the `subnetwork` is a name and this
               field is not provided, the provider project is used.
        """
        __self__.access_configs = access_configs
        __self__.alias_ip_ranges = alias_ip_ranges
        __self__.name = name
        __self__.network = network
        __self__.network_ip = network_ip
        __self__.subnetwork = subnetwork
        __self__.subnetwork_project = subnetwork_project

@pulumi.input_type
class InstanceNetworkInterfaceAccessConfigArgs:
    nat_ip: Optional[pulumi.Input[str]] = pulumi.input_property("natIp")
    """
    The IP address that will be 1:1 mapped to the instance's
    network ip. If not given, one will be generated.
    """
    network_tier: Optional[pulumi.Input[str]] = pulumi.input_property("networkTier")
    """
    The [networking tier][network-tier] used for configuring this instance.
    This field can take the following values: PREMIUM or STANDARD. If this field is
    not specified, it is assumed to be PREMIUM.
    """
    public_ptr_domain_name: Optional[pulumi.Input[str]] = pulumi.input_property("publicPtrDomainName")
    """
    The DNS domain name for the public PTR record.
    To set this field on an instance, you must be verified as the owner of the domain.
    See [the docs](https://cloud.google.com/compute/docs/instances/create-ptr-record) for how
    to become verified as a domain owner.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nat_ip: Optional[pulumi.Input[str]] = None, network_tier: Optional[pulumi.Input[str]] = None, public_ptr_domain_name: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param pulumi.Input[str] network_tier: The [networking tier][network-tier] used for configuring this instance.
               This field can take the following values: PREMIUM or STANDARD. If this field is
               not specified, it is assumed to be PREMIUM.
        :param pulumi.Input[str] public_ptr_domain_name: The DNS domain name for the public PTR record.
               To set this field on an instance, you must be verified as the owner of the domain.
               See [the docs](https://cloud.google.com/compute/docs/instances/create-ptr-record) for how
               to become verified as a domain owner.
        """
        __self__.nat_ip = nat_ip
        __self__.network_tier = network_tier
        __self__.public_ptr_domain_name = public_ptr_domain_name

@pulumi.input_type
class InstanceNetworkInterfaceAliasIpRangeArgs:
    ip_cidr_range: pulumi.Input[str] = pulumi.input_property("ipCidrRange")
    """
    The IP CIDR range represented by this alias IP range. This IP CIDR range
    must belong to the specified subnetwork and cannot contain IP addresses reserved by
    system or used by other network interfaces. This range may be a single IP address
    (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
    """
    subnetwork_range_name: Optional[pulumi.Input[str]] = pulumi.input_property("subnetworkRangeName")
    """
    The subnetwork secondary range name specifying
    the secondary range from which to allocate the IP CIDR range for this alias IP
    range. If left unspecified, the primary range of the subnetwork will be used.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, ip_cidr_range: pulumi.Input[str], subnetwork_range_name: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. This range may be a single IP address
               (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
        :param pulumi.Input[str] subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        __self__.ip_cidr_range = ip_cidr_range
        __self__.subnetwork_range_name = subnetwork_range_name

@pulumi.input_type
class InstanceSchedulingArgs:
    automatic_restart: Optional[pulumi.Input[bool]] = pulumi.input_property("automaticRestart")
    """
    Specifies if the instance should be
    restarted if it was terminated by Compute Engine (not a user).
    Defaults to true.
    """
    min_node_cpus: Optional[pulumi.Input[float]] = pulumi.input_property("minNodeCpus")
    node_affinities: Optional[pulumi.Input[List[pulumi.Input['InstanceSchedulingNodeAffinityArgs']]]] = pulumi.input_property("nodeAffinities")
    """
    Specifies node affinities or anti-affinities
    to determine which sole-tenant nodes your instances and managed instance
    groups will use as host systems. Read more on sole-tenant node creation
    [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
    Structure documented below.
    """
    on_host_maintenance: Optional[pulumi.Input[str]] = pulumi.input_property("onHostMaintenance")
    """
    Describes maintenance behavior for the
    instance. Can be MIGRATE or TERMINATE, for more info, read
    [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
    """
    preemptible: Optional[pulumi.Input[bool]] = pulumi.input_property("preemptible")
    """
    Specifies if the instance is preemptible.
    If this field is set to true, then `automatic_restart` must be
    set to false.  Defaults to false.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, automatic_restart: Optional[pulumi.Input[bool]] = None, min_node_cpus: Optional[pulumi.Input[float]] = None, node_affinities: Optional[pulumi.Input[List[pulumi.Input['InstanceSchedulingNodeAffinityArgs']]]] = None, on_host_maintenance: Optional[pulumi.Input[str]] = None, preemptible: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[bool] automatic_restart: Specifies if the instance should be
               restarted if it was terminated by Compute Engine (not a user).
               Defaults to true.
        :param pulumi.Input[List[pulumi.Input['InstanceSchedulingNodeAffinityArgs']]] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param pulumi.Input[str] on_host_maintenance: Describes maintenance behavior for the
               instance. Can be MIGRATE or TERMINATE, for more info, read
               [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
        :param pulumi.Input[bool] preemptible: Specifies if the instance is preemptible.
               If this field is set to true, then `automatic_restart` must be
               set to false.  Defaults to false.
        """
        __self__.automatic_restart = automatic_restart
        __self__.min_node_cpus = min_node_cpus
        __self__.node_affinities = node_affinities
        __self__.on_host_maintenance = on_host_maintenance
        __self__.preemptible = preemptible

@pulumi.input_type
class InstanceSchedulingNodeAffinityArgs:
    key: pulumi.Input[str] = pulumi.input_property("key")
    """
    The key for the node affinity label.
    """
    operator: pulumi.Input[str] = pulumi.input_property("operator")
    """
    The operator. Can be `IN` for node-affinities
    or `NOT_IN` for anti-affinities.
    """
    values: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("values")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, key: pulumi.Input[str], operator: pulumi.Input[str], values: pulumi.Input[List[pulumi.Input[str]]]) -> None:
        """
        :param pulumi.Input[str] key: The key for the node affinity label.
        :param pulumi.Input[str] operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        """
        __self__.key = key
        __self__.operator = operator
        __self__.values = values

@pulumi.input_type
class InstanceScratchDiskArgs:
    interface: pulumi.Input[str] = pulumi.input_property("interface")
    """
    The disk interface to use for attaching this disk; either SCSI or NVME.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, interface: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] interface: The disk interface to use for attaching this disk; either SCSI or NVME.
        """
        __self__.interface = interface

@pulumi.input_type
class InstanceServiceAccountArgs:
    scopes: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("scopes")
    """
    A list of service scopes. Both OAuth2 URLs and gcloud
    short names are supported. To allow full access to all Cloud APIs, use the
    `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
    **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
    """
    email: Optional[pulumi.Input[str]] = pulumi.input_property("email")
    """
    The service account e-mail address. If not given, the
    default Google Compute Engine service account is used.
    **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, scopes: pulumi.Input[List[pulumi.Input[str]]], email: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        :param pulumi.Input[str] email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        __self__.scopes = scopes
        __self__.email = email

@pulumi.input_type
class InstanceShieldedInstanceConfigArgs:
    enable_integrity_monitoring: Optional[pulumi.Input[bool]] = pulumi.input_property("enableIntegrityMonitoring")
    """
    -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    """
    enable_secure_boot: Optional[pulumi.Input[bool]] = pulumi.input_property("enableSecureBoot")
    """
    -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    """
    enable_vtpm: Optional[pulumi.Input[bool]] = pulumi.input_property("enableVtpm")
    """
    -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None, enable_secure_boot: Optional[pulumi.Input[bool]] = None, enable_vtpm: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[bool] enable_integrity_monitoring: -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        :param pulumi.Input[bool] enable_secure_boot: -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        :param pulumi.Input[bool] enable_vtpm: -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        __self__.enable_integrity_monitoring = enable_integrity_monitoring
        __self__.enable_secure_boot = enable_secure_boot
        __self__.enable_vtpm = enable_vtpm

@pulumi.input_type
class InstanceTemplateDiskArgs:
    auto_delete: Optional[pulumi.Input[bool]] = pulumi.input_property("autoDelete")
    """
    Whether or not the disk should be auto-deleted.
    This defaults to true.
    """
    boot: Optional[pulumi.Input[bool]] = pulumi.input_property("boot")
    """
    Indicates that this is a boot disk.
    """
    device_name: Optional[pulumi.Input[str]] = pulumi.input_property("deviceName")
    """
    A unique device name that is reflected into the
    /dev/  tree of a Linux operating system running within the instance. If not
    specified, the server chooses a default device name to apply to this disk.
    """
    disk_encryption_key: Optional[pulumi.Input['InstanceTemplateDiskDiskEncryptionKeyArgs']] = pulumi.input_property("diskEncryptionKey")
    """
    Encrypts or decrypts a disk using a customer-supplied encryption key.
    """
    disk_name: Optional[pulumi.Input[str]] = pulumi.input_property("diskName")
    """
    Name of the disk. When not provided, this defaults
    to the name of the instance.
    """
    disk_size_gb: Optional[pulumi.Input[float]] = pulumi.input_property("diskSizeGb")
    """
    The size of the image in gigabytes. If not
    specified, it will inherit the size of its base image. For SCRATCH disks,
    the size must be exactly 375GB.
    """
    disk_type: Optional[pulumi.Input[str]] = pulumi.input_property("diskType")
    """
    The GCE disk type. Can be either `"pd-ssd"`,
    `"local-ssd"`, or `"pd-standard"`.
    """
    interface: Optional[pulumi.Input[str]] = pulumi.input_property("interface")
    """
    Specifies the disk interface to use for attaching
    this disk.
    """
    labels: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = pulumi.input_property("labels")
    """
    A set of key/value label pairs to assign to instances
    created from this template,
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    The mode in which to attach this disk, either READ_WRITE
    or READ_ONLY. If you are attaching or creating a boot disk, this must
    read-write mode.
    """
    source: Optional[pulumi.Input[str]] = pulumi.input_property("source")
    """
    The name (**not self_link**)
    of the disk (such as those managed by `compute.Disk`) to attach.
    > **Note:** Either `source` or `source_image` is **required** when creating a new instance except for when creating a local SSD. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
    """
    source_image: Optional[pulumi.Input[str]] = pulumi.input_property("sourceImage")
    """
    The image from which to
    initialize this disk. This can be one of: the image's `self_link`,
    `projects/{project}/global/images/{image}`,
    `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
    `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
    `{project}/{image}`, `{family}`, or `{image}`.
    > **Note:** Either `source` or `source_image` is **required** when creating a new instance except for when creating a local SSD. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
    """
    type: Optional[pulumi.Input[str]] = pulumi.input_property("type")
    """
    The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, auto_delete: Optional[pulumi.Input[bool]] = None, boot: Optional[pulumi.Input[bool]] = None, device_name: Optional[pulumi.Input[str]] = None, disk_encryption_key: Optional[pulumi.Input['InstanceTemplateDiskDiskEncryptionKeyArgs']] = None, disk_name: Optional[pulumi.Input[str]] = None, disk_size_gb: Optional[pulumi.Input[float]] = None, disk_type: Optional[pulumi.Input[str]] = None, interface: Optional[pulumi.Input[str]] = None, labels: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = None, mode: Optional[pulumi.Input[str]] = None, source: Optional[pulumi.Input[str]] = None, source_image: Optional[pulumi.Input[str]] = None, type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] auto_delete: Whether or not the disk should be auto-deleted.
               This defaults to true.
        :param pulumi.Input[bool] boot: Indicates that this is a boot disk.
        :param pulumi.Input[str] device_name: A unique device name that is reflected into the
               /dev/  tree of a Linux operating system running within the instance. If not
               specified, the server chooses a default device name to apply to this disk.
        :param pulumi.Input['InstanceTemplateDiskDiskEncryptionKeyArgs'] disk_encryption_key: Encrypts or decrypts a disk using a customer-supplied encryption key.
        :param pulumi.Input[str] disk_name: Name of the disk. When not provided, this defaults
               to the name of the instance.
        :param pulumi.Input[float] disk_size_gb: The size of the image in gigabytes. If not
               specified, it will inherit the size of its base image. For SCRATCH disks,
               the size must be exactly 375GB.
        :param pulumi.Input[str] disk_type: The GCE disk type. Can be either `"pd-ssd"`,
               `"local-ssd"`, or `"pd-standard"`.
        :param pulumi.Input[str] interface: Specifies the disk interface to use for attaching
               this disk.
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] labels: A set of key/value label pairs to assign to instances
               created from this template,
        :param pulumi.Input[str] mode: The mode in which to attach this disk, either READ_WRITE
               or READ_ONLY. If you are attaching or creating a boot disk, this must
               read-write mode.
        :param pulumi.Input[str] source: The name (**not self_link**)
               of the disk (such as those managed by `compute.Disk`) to attach.
               > **Note:** Either `source` or `source_image` is **required** when creating a new instance except for when creating a local SSD. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param pulumi.Input[str] source_image: The image from which to
               initialize this disk. This can be one of: the image's `self_link`,
               `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`.
               > **Note:** Either `source` or `source_image` is **required** when creating a new instance except for when creating a local SSD. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param pulumi.Input[str] type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        __self__.auto_delete = auto_delete
        __self__.boot = boot
        __self__.device_name = device_name
        __self__.disk_encryption_key = disk_encryption_key
        __self__.disk_name = disk_name
        __self__.disk_size_gb = disk_size_gb
        __self__.disk_type = disk_type
        __self__.interface = interface
        __self__.labels = labels
        __self__.mode = mode
        __self__.source = source
        __self__.source_image = source_image
        __self__.type = type

@pulumi.input_type
class InstanceTemplateDiskDiskEncryptionKeyArgs:
    kms_key_self_link: pulumi.Input[str] = pulumi.input_property("kmsKeySelfLink")
    """
    The self link of the encryption key that is stored in Google Cloud KMS
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, kms_key_self_link: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        """
        __self__.kms_key_self_link = kms_key_self_link

@pulumi.input_type
class InstanceTemplateGuestAcceleratorArgs:
    count: pulumi.Input[float] = pulumi.input_property("count")
    """
    The number of the guest accelerator cards exposed to this instance.
    """
    type: pulumi.Input[str] = pulumi.input_property("type")
    """
    The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, count: pulumi.Input[float], type: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[float] count: The number of the guest accelerator cards exposed to this instance.
        :param pulumi.Input[str] type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        __self__.count = count
        __self__.type = type

@pulumi.input_type
class InstanceTemplateNetworkInterfaceArgs:
    access_configs: Optional[pulumi.Input[List[pulumi.Input['InstanceTemplateNetworkInterfaceAccessConfigArgs']]]] = pulumi.input_property("accessConfigs")
    """
    Access configurations, i.e. IPs via which this
    instance can be accessed via the Internet. Omit to ensure that the instance
    is not accessible from the Internet (this means that ssh provisioners will
    not work unless you can send traffic to the instance's
    network (e.g. via tunnel or because it is running on another cloud instance
    on that network). This block can be repeated multiple times. Structure documented below.
    """
    alias_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['InstanceTemplateNetworkInterfaceAliasIpRangeArgs']]]] = pulumi.input_property("aliasIpRanges")
    """
    An
    array of alias IP ranges for this network interface. Can only be specified for network
    interfaces on subnet-mode networks. Structure documented below.
    """
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    The name of the instance template. If you leave
    this blank, the provider will auto-generate a unique name.
    """
    network: Optional[pulumi.Input[str]] = pulumi.input_property("network")
    """
    The name or self_link of the network to attach this interface to.
    Use `network` attribute for Legacy or Auto subnetted networks and
    `subnetwork` for custom subnetted networks.
    """
    network_ip: Optional[pulumi.Input[str]] = pulumi.input_property("networkIp")
    """
    The private IP address to assign to the instance. If
    empty, the address will be automatically assigned.
    """
    subnetwork: Optional[pulumi.Input[str]] = pulumi.input_property("subnetwork")
    """
    the name of the subnetwork to attach this interface
    to. The subnetwork must exist in the same `region` this instance will be
    created in. Either `network` or `subnetwork` must be provided.
    """
    subnetwork_project: Optional[pulumi.Input[str]] = pulumi.input_property("subnetworkProject")
    """
    The ID of the project in which the subnetwork belongs.
    If it is not provided, the provider project is used.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, access_configs: Optional[pulumi.Input[List[pulumi.Input['InstanceTemplateNetworkInterfaceAccessConfigArgs']]]] = None, alias_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['InstanceTemplateNetworkInterfaceAliasIpRangeArgs']]]] = None, name: Optional[pulumi.Input[str]] = None, network: Optional[pulumi.Input[str]] = None, network_ip: Optional[pulumi.Input[str]] = None, subnetwork: Optional[pulumi.Input[str]] = None, subnetwork_project: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['InstanceTemplateNetworkInterfaceAccessConfigArgs']]] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Omit to ensure that the instance
               is not accessible from the Internet (this means that ssh provisioners will
               not work unless you can send traffic to the instance's
               network (e.g. via tunnel or because it is running on another cloud instance
               on that network). This block can be repeated multiple times. Structure documented below.
        :param pulumi.Input[List[pulumi.Input['InstanceTemplateNetworkInterfaceAliasIpRangeArgs']]] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param pulumi.Input[str] name: The name of the instance template. If you leave
               this blank, the provider will auto-generate a unique name.
        :param pulumi.Input[str] network: The name or self_link of the network to attach this interface to.
               Use `network` attribute for Legacy or Auto subnetted networks and
               `subnetwork` for custom subnetted networks.
        :param pulumi.Input[str] network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param pulumi.Input[str] subnetwork: the name of the subnetwork to attach this interface
               to. The subnetwork must exist in the same `region` this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param pulumi.Input[str] subnetwork_project: The ID of the project in which the subnetwork belongs.
               If it is not provided, the provider project is used.
        """
        __self__.access_configs = access_configs
        __self__.alias_ip_ranges = alias_ip_ranges
        __self__.name = name
        __self__.network = network
        __self__.network_ip = network_ip
        __self__.subnetwork = subnetwork
        __self__.subnetwork_project = subnetwork_project

@pulumi.input_type
class InstanceTemplateNetworkInterfaceAccessConfigArgs:
    nat_ip: Optional[pulumi.Input[str]] = pulumi.input_property("natIp")
    """
    The IP address that will be 1:1 mapped to the instance's
    network ip. If not given, one will be generated.
    """
    network_tier: Optional[pulumi.Input[str]] = pulumi.input_property("networkTier")
    """
    The [networking tier][network-tier] used for configuring
    this instance template. This field can take the following values: PREMIUM or
    STANDARD. If this field is not specified, it is assumed to be PREMIUM.
    """
    public_ptr_domain_name: Optional[pulumi.Input[str]] = pulumi.input_property("publicPtrDomainName")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nat_ip: Optional[pulumi.Input[str]] = None, network_tier: Optional[pulumi.Input[str]] = None, public_ptr_domain_name: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param pulumi.Input[str] network_tier: The [networking tier][network-tier] used for configuring
               this instance template. This field can take the following values: PREMIUM or
               STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        __self__.nat_ip = nat_ip
        __self__.network_tier = network_tier
        __self__.public_ptr_domain_name = public_ptr_domain_name

@pulumi.input_type
class InstanceTemplateNetworkInterfaceAliasIpRangeArgs:
    ip_cidr_range: pulumi.Input[str] = pulumi.input_property("ipCidrRange")
    """
    The IP CIDR range represented by this alias IP range. This IP CIDR range
    must belong to the specified subnetwork and cannot contain IP addresses reserved by
    system or used by other network interfaces. At the time of writing only a
    netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
    error.
    """
    subnetwork_range_name: Optional[pulumi.Input[str]] = pulumi.input_property("subnetworkRangeName")
    """
    The subnetwork secondary range name specifying
    the secondary range from which to allocate the IP CIDR range for this alias IP
    range. If left unspecified, the primary range of the subnetwork will be used.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, ip_cidr_range: pulumi.Input[str], subnetwork_range_name: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. At the time of writing only a
               netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
               error.
        :param pulumi.Input[str] subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        __self__.ip_cidr_range = ip_cidr_range
        __self__.subnetwork_range_name = subnetwork_range_name

@pulumi.input_type
class InstanceTemplateSchedulingArgs:
    automatic_restart: Optional[pulumi.Input[bool]] = pulumi.input_property("automaticRestart")
    """
    Specifies whether the instance should be
    automatically restarted if it is terminated by Compute Engine (not
    terminated by a user). This defaults to true.
    """
    min_node_cpus: Optional[pulumi.Input[float]] = pulumi.input_property("minNodeCpus")
    node_affinities: Optional[pulumi.Input[List[pulumi.Input['InstanceTemplateSchedulingNodeAffinityArgs']]]] = pulumi.input_property("nodeAffinities")
    """
    Specifies node affinities or anti-affinities
    to determine which sole-tenant nodes your instances and managed instance
    groups will use as host systems. Read more on sole-tenant node creation
    [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
    Structure documented below.
    """
    on_host_maintenance: Optional[pulumi.Input[str]] = pulumi.input_property("onHostMaintenance")
    """
    Defines the maintenance behavior for this
    instance.
    """
    preemptible: Optional[pulumi.Input[bool]] = pulumi.input_property("preemptible")
    """
    Allows instance to be preempted. This defaults to
    false. Read more on this
    [here](https://cloud.google.com/compute/docs/instances/preemptible).
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, automatic_restart: Optional[pulumi.Input[bool]] = None, min_node_cpus: Optional[pulumi.Input[float]] = None, node_affinities: Optional[pulumi.Input[List[pulumi.Input['InstanceTemplateSchedulingNodeAffinityArgs']]]] = None, on_host_maintenance: Optional[pulumi.Input[str]] = None, preemptible: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[bool] automatic_restart: Specifies whether the instance should be
               automatically restarted if it is terminated by Compute Engine (not
               terminated by a user). This defaults to true.
        :param pulumi.Input[List[pulumi.Input['InstanceTemplateSchedulingNodeAffinityArgs']]] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param pulumi.Input[str] on_host_maintenance: Defines the maintenance behavior for this
               instance.
        :param pulumi.Input[bool] preemptible: Allows instance to be preempted. This defaults to
               false. Read more on this
               [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        __self__.automatic_restart = automatic_restart
        __self__.min_node_cpus = min_node_cpus
        __self__.node_affinities = node_affinities
        __self__.on_host_maintenance = on_host_maintenance
        __self__.preemptible = preemptible

@pulumi.input_type
class InstanceTemplateSchedulingNodeAffinityArgs:
    key: pulumi.Input[str] = pulumi.input_property("key")
    """
    The key for the node affinity label.
    """
    operator: pulumi.Input[str] = pulumi.input_property("operator")
    """
    The operator. Can be `IN` for node-affinities
    or `NOT_IN` for anti-affinities.
    """
    values: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("values")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, key: pulumi.Input[str], operator: pulumi.Input[str], values: pulumi.Input[List[pulumi.Input[str]]]) -> None:
        """
        :param pulumi.Input[str] key: The key for the node affinity label.
        :param pulumi.Input[str] operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        """
        __self__.key = key
        __self__.operator = operator
        __self__.values = values

@pulumi.input_type
class InstanceTemplateServiceAccountArgs:
    scopes: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("scopes")
    """
    A list of service scopes. Both OAuth2 URLs and gcloud
    short names are supported. To allow full access to all Cloud APIs, use the
    `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
    """
    email: Optional[pulumi.Input[str]] = pulumi.input_property("email")
    """
    The service account e-mail address. If not given, the
    default Google Compute Engine service account is used.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, scopes: pulumi.Input[List[pulumi.Input[str]]], email: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        :param pulumi.Input[str] email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
        """
        __self__.scopes = scopes
        __self__.email = email

@pulumi.input_type
class InstanceTemplateShieldedInstanceConfigArgs:
    enable_integrity_monitoring: Optional[pulumi.Input[bool]] = pulumi.input_property("enableIntegrityMonitoring")
    """
    -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    """
    enable_secure_boot: Optional[pulumi.Input[bool]] = pulumi.input_property("enableSecureBoot")
    """
    -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    """
    enable_vtpm: Optional[pulumi.Input[bool]] = pulumi.input_property("enableVtpm")
    """
    -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None, enable_secure_boot: Optional[pulumi.Input[bool]] = None, enable_vtpm: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[bool] enable_integrity_monitoring: -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        :param pulumi.Input[bool] enable_secure_boot: -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        :param pulumi.Input[bool] enable_vtpm: -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        __self__.enable_integrity_monitoring = enable_integrity_monitoring
        __self__.enable_secure_boot = enable_secure_boot
        __self__.enable_vtpm = enable_vtpm

@pulumi.input_type
class InterconnectAttachmentPrivateInterconnectInfoArgs:
    tag8021q: Optional[pulumi.Input[float]] = pulumi.input_property("tag8021q")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, tag8021q: Optional[pulumi.Input[float]] = None) -> None:
        __self__.tag8021q = tag8021q

@pulumi.input_type
class ManagedSslCertificateManagedArgs:
    domains: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("domains")
    """
    Domains for which a managed SSL certificate will be valid.  Currently,
    there can be up to 100 domains in this list.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, domains: pulumi.Input[List[pulumi.Input[str]]]) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] domains: Domains for which a managed SSL certificate will be valid.  Currently,
               there can be up to 100 domains in this list.
        """
        __self__.domains = domains

@pulumi.input_type
class MangedSslCertificateManagedArgs:
    domains: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("domains")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, domains: pulumi.Input[List[pulumi.Input[str]]]) -> None:
        __self__.domains = domains

@pulumi.input_type
class NodeGroupAutoscalingPolicyArgs:
    max_nodes: Optional[pulumi.Input[float]] = pulumi.input_property("maxNodes")
    """
    Maximum size of the node group. Set to a value less than or equal
    to 100 and greater than or equal to min-nodes.
    """
    min_nodes: Optional[pulumi.Input[float]] = pulumi.input_property("minNodes")
    """
    Minimum size of the node group. Must be less
    than or equal to max-nodes. The default value is 0.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    The autoscaling mode. Set to one of the following:
    - OFF: Disables the autoscaler.
    - ON: Enables scaling in and scaling out.
    - ONLY_SCALE_OUT: Enables only scaling out.
    You must use this mode if your node groups are configured to
    restart their hosted VMs on minimal servers.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_nodes: Optional[pulumi.Input[float]] = None, min_nodes: Optional[pulumi.Input[float]] = None, mode: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] max_nodes: Maximum size of the node group. Set to a value less than or equal
               to 100 and greater than or equal to min-nodes.
        :param pulumi.Input[float] min_nodes: Minimum size of the node group. Must be less
               than or equal to max-nodes. The default value is 0.
        :param pulumi.Input[str] mode: The autoscaling mode. Set to one of the following:
               - OFF: Disables the autoscaler.
               - ON: Enables scaling in and scaling out.
               - ONLY_SCALE_OUT: Enables only scaling out.
               You must use this mode if your node groups are configured to
               restart their hosted VMs on minimal servers.
        """
        __self__.max_nodes = max_nodes
        __self__.min_nodes = min_nodes
        __self__.mode = mode

@pulumi.input_type
class NodeTemplateNodeTypeFlexibilityArgs:
    cpus: Optional[pulumi.Input[str]] = pulumi.input_property("cpus")
    """
    Number of virtual CPUs to use.
    """
    local_ssd: Optional[pulumi.Input[str]] = pulumi.input_property("localSsd")
    """
    -
    Use local SSD
    """
    memory: Optional[pulumi.Input[str]] = pulumi.input_property("memory")
    """
    Physical memory available to the node, defined in MB.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cpus: Optional[pulumi.Input[str]] = None, local_ssd: Optional[pulumi.Input[str]] = None, memory: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] cpus: Number of virtual CPUs to use.
        :param pulumi.Input[str] local_ssd: -
               Use local SSD
        :param pulumi.Input[str] memory: Physical memory available to the node, defined in MB.
        """
        __self__.cpus = cpus
        __self__.local_ssd = local_ssd
        __self__.memory = memory

@pulumi.input_type
class NodeTemplateServerBindingArgs:
    type: pulumi.Input[str] = pulumi.input_property("type")
    """
    Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
    nodes using this template will restart on any physical server
    following a maintenance event.
    If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
    will restart on the same physical server following a maintenance
    event, instead of being live migrated to or restarted on a new
    physical server. This option may be useful if you are using
    software licenses tied to the underlying server characteristics
    such as physical sockets or cores, to avoid the need for
    additional licenses when maintenance occurs. However, VMs on such
    nodes will experience outages while maintenance is applied.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, type: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] type: Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
               nodes using this template will restart on any physical server
               following a maintenance event.
               If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
               will restart on the same physical server following a maintenance
               event, instead of being live migrated to or restarted on a new
               physical server. This option may be useful if you are using
               software licenses tied to the underlying server characteristics
               such as physical sockets or cores, to avoid the need for
               additional licenses when maintenance occurs. However, VMs on such
               nodes will experience outages while maintenance is applied.
        """
        __self__.type = type

@pulumi.input_type
class PacketMirroringCollectorIlbArgs:
    url: pulumi.Input[str] = pulumi.input_property("url")
    """
    The URL of the instances where this rule should be active.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, url: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] url: The URL of the instances where this rule should be active.
        """
        __self__.url = url

@pulumi.input_type
class PacketMirroringFilterArgs:
    cidr_ranges: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("cidrRanges")
    """
    IP CIDR ranges that apply as a filter on the source (ingress) or
    destination (egress) IP in the IP header. Only IPv4 is supported.
    """
    ip_protocols: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("ipProtocols")
    """
    Protocols that apply as a filter on mirrored traffic.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cidr_ranges: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, ip_protocols: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] cidr_ranges: IP CIDR ranges that apply as a filter on the source (ingress) or
               destination (egress) IP in the IP header. Only IPv4 is supported.
        :param pulumi.Input[List[pulumi.Input[str]]] ip_protocols: Protocols that apply as a filter on mirrored traffic.
        """
        __self__.cidr_ranges = cidr_ranges
        __self__.ip_protocols = ip_protocols

@pulumi.input_type
class PacketMirroringMirroredResourcesArgs:
    instances: Optional[pulumi.Input[List[pulumi.Input['PacketMirroringMirroredResourcesInstanceArgs']]]] = pulumi.input_property("instances")
    """
    All the listed instances will be mirrored.  Specify at most 50.  Structure is documented below.
    """
    subnetworks: Optional[pulumi.Input[List[pulumi.Input['PacketMirroringMirroredResourcesSubnetworkArgs']]]] = pulumi.input_property("subnetworks")
    """
    All instances in one of these subnetworks will be mirrored.  Structure is documented below.
    """
    tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("tags")
    """
    All instances with these tags will be mirrored.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, instances: Optional[pulumi.Input[List[pulumi.Input['PacketMirroringMirroredResourcesInstanceArgs']]]] = None, subnetworks: Optional[pulumi.Input[List[pulumi.Input['PacketMirroringMirroredResourcesSubnetworkArgs']]]] = None, tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['PacketMirroringMirroredResourcesInstanceArgs']]] instances: All the listed instances will be mirrored.  Specify at most 50.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['PacketMirroringMirroredResourcesSubnetworkArgs']]] subnetworks: All instances in one of these subnetworks will be mirrored.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] tags: All instances with these tags will be mirrored.
        """
        __self__.instances = instances
        __self__.subnetworks = subnetworks
        __self__.tags = tags

@pulumi.input_type
class PacketMirroringMirroredResourcesInstanceArgs:
    url: pulumi.Input[str] = pulumi.input_property("url")
    """
    The URL of the instances where this rule should be active.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, url: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] url: The URL of the instances where this rule should be active.
        """
        __self__.url = url

@pulumi.input_type
class PacketMirroringMirroredResourcesSubnetworkArgs:
    url: pulumi.Input[str] = pulumi.input_property("url")
    """
    The URL of the instances where this rule should be active.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, url: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] url: The URL of the instances where this rule should be active.
        """
        __self__.url = url

@pulumi.input_type
class PacketMirroringNetworkArgs:
    url: pulumi.Input[str] = pulumi.input_property("url")
    """
    The URL of the instances where this rule should be active.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, url: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] url: The URL of the instances where this rule should be active.
        """
        __self__.url = url

@pulumi.input_type
class PerInstanceConfigPreservedStateArgs:
    disks: Optional[pulumi.Input[List[pulumi.Input['PerInstanceConfigPreservedStateDiskArgs']]]] = pulumi.input_property("disks")
    """
    Stateful disks for the instance.  Structure is documented below.
    """
    metadata: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = pulumi.input_property("metadata")
    """
    Preserved metadata defined for this instance. This is a list of key->value pairs.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, disks: Optional[pulumi.Input[List[pulumi.Input['PerInstanceConfigPreservedStateDiskArgs']]]] = None, metadata: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['PerInstanceConfigPreservedStateDiskArgs']]] disks: Stateful disks for the instance.  Structure is documented below.
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] metadata: Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        __self__.disks = disks
        __self__.metadata = metadata

@pulumi.input_type
class PerInstanceConfigPreservedStateDiskArgs:
    device_name: pulumi.Input[str] = pulumi.input_property("deviceName")
    """
    A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    """
    source: pulumi.Input[str] = pulumi.input_property("source")
    """
    The URI of an existing persistent disk to attach under the specified device-name in the format
    `projects/project-id/zones/zone/disks/disk-name`.
    """
    delete_rule: Optional[pulumi.Input[str]] = pulumi.input_property("deleteRule")
    """
    A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
    `NEVER` detatch the disk when the VM is deleted, but not delete the disk.
    `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
    deleted from the instance group.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    The mode of the disk.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, device_name: pulumi.Input[str], source: pulumi.Input[str], delete_rule: Optional[pulumi.Input[str]] = None, mode: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] device_name: A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        :param pulumi.Input[str] source: The URI of an existing persistent disk to attach under the specified device-name in the format
               `projects/project-id/zones/zone/disks/disk-name`.
        :param pulumi.Input[str] delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
               The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
               `NEVER` detatch the disk when the VM is deleted, but not delete the disk.
               `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
               deleted from the instance group.
        :param pulumi.Input[str] mode: The mode of the disk.
        """
        __self__.device_name = device_name
        __self__.source = source
        __self__.delete_rule = delete_rule
        __self__.mode = mode

@pulumi.input_type
class RegionAutoscalerAutoscalingPolicyArgs:
    max_replicas: pulumi.Input[float] = pulumi.input_property("maxReplicas")
    """
    The maximum number of instances that the autoscaler can scale up
    to. This is required when creating or updating an autoscaler. The
    maximum number of replicas should not be lower than minimal number
    of replicas.
    """
    min_replicas: pulumi.Input[float] = pulumi.input_property("minReplicas")
    """
    The minimum number of replicas that the autoscaler can scale down
    to. This cannot be less than 0. If not provided, autoscaler will
    choose a default value depending on maximum number of instances
    allowed.
    """
    cooldown_period: Optional[pulumi.Input[float]] = pulumi.input_property("cooldownPeriod")
    """
    The number of seconds that the autoscaler should wait before it
    starts collecting information from a new instance. This prevents
    the autoscaler from collecting information when the instance is
    initializing, during which the collected usage would not be
    reliable. The default time autoscaler waits is 60 seconds.
    Virtual machine initialization times might vary because of
    numerous factors. We recommend that you test how long an
    instance may take to initialize. To do this, create an instance
    and time the startup process.
    """
    cpu_utilization: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyCpuUtilizationArgs']] = pulumi.input_property("cpuUtilization")
    """
    Defines the CPU utilization policy that allows the autoscaler to
    scale based on the average CPU utilization of a managed instance
    group.  Structure is documented below.
    """
    load_balancing_utilization: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs']] = pulumi.input_property("loadBalancingUtilization")
    """
    Configuration parameters of autoscaling based on a load balancer.  Structure is documented below.
    """
    metrics: Optional[pulumi.Input[List[pulumi.Input['RegionAutoscalerAutoscalingPolicyMetricArgs']]]] = pulumi.input_property("metrics")
    """
    Configuration parameters of autoscaling based on a custom metric.  Structure is documented below.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    Defines operating mode for this policy.
    """
    scale_down_control: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyScaleDownControlArgs']] = pulumi.input_property("scaleDownControl")

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_replicas: pulumi.Input[float], min_replicas: pulumi.Input[float], cooldown_period: Optional[pulumi.Input[float]] = None, cpu_utilization: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyCpuUtilizationArgs']] = None, load_balancing_utilization: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs']] = None, metrics: Optional[pulumi.Input[List[pulumi.Input['RegionAutoscalerAutoscalingPolicyMetricArgs']]]] = None, mode: Optional[pulumi.Input[str]] = None, scale_down_control: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyScaleDownControlArgs']] = None) -> None:
        """
        :param pulumi.Input[float] max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param pulumi.Input[float] min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param pulumi.Input[float] cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param pulumi.Input['RegionAutoscalerAutoscalingPolicyCpuUtilizationArgs'] cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.  Structure is documented below.
        :param pulumi.Input['RegionAutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs'] load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['RegionAutoscalerAutoscalingPolicyMetricArgs']]] metrics: Configuration parameters of autoscaling based on a custom metric.  Structure is documented below.
        :param pulumi.Input[str] mode: Defines operating mode for this policy.
        """
        __self__.max_replicas = max_replicas
        __self__.min_replicas = min_replicas
        __self__.cooldown_period = cooldown_period
        __self__.cpu_utilization = cpu_utilization
        __self__.load_balancing_utilization = load_balancing_utilization
        __self__.metrics = metrics
        __self__.mode = mode
        __self__.scale_down_control = scale_down_control

@pulumi.input_type
class RegionAutoscalerAutoscalingPolicyCpuUtilizationArgs:
    target: pulumi.Input[float] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, target: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        __self__.target = target

@pulumi.input_type
class RegionAutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs:
    target: pulumi.Input[float] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, target: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        __self__.target = target

@pulumi.input_type
class RegionAutoscalerAutoscalingPolicyMetricArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The identifier (type) of the Stackdriver Monitoring metric.
    The metric cannot have negative values.
    The metric must have a value type of INT64 or DOUBLE.
    """
    filter: Optional[pulumi.Input[str]] = pulumi.input_property("filter")
    """
    A filter string to be used as the filter string for
    a Stackdriver Monitoring TimeSeries.list API call.
    This filter is used to select a specific TimeSeries for
    the purpose of autoscaling and to determine whether the metric
    is exporting per-instance or per-group data.
    You can only use the AND operator for joining selectors.
    You can only use direct equality comparison operator (=) without
    any functions for each selector.
    You can specify the metric in both the filter string and in the
    metric field. However, if specified in both places, the metric must
    be identical.
    The monitored resource type determines what kind of values are
    expected for the metric. If it is a gce_instance, the autoscaler
    expects the metric to include a separate TimeSeries for each
    instance in a group. In such a case, you cannot filter on resource
    labels.
    If the resource type is any other value, the autoscaler expects
    this metric to contain values that apply to the entire autoscaled
    instance group and resource label filtering can be performed to
    point autoscaler at the correct TimeSeries to scale upon.
    This is called a per-group metric for the purpose of autoscaling.
    If not specified, the type defaults to gce_instance.
    You should provide a filter that is selective enough to pick just
    one TimeSeries for the autoscaled group or for each of the instances
    (if you are using gce_instance resource type). If multiple
    TimeSeries are returned upon the query execution, the autoscaler
    will sum their respective values to obtain its scaling value.
    """
    single_instance_assignment: Optional[pulumi.Input[float]] = pulumi.input_property("singleInstanceAssignment")
    """
    If scaling is based on a per-group metric value that represents the
    total amount of work to be done or resource usage, set this value to
    an amount assigned for a single instance of the scaled group.
    The autoscaler will keep the number of instances proportional to the
    value of this metric, the metric itself should not change value due
    to group resizing.
    For example, a good metric to use with the target is
    `pubsub.googleapis.com/subscription/num_undelivered_messages`
    or a custom metric exporting the total number of requests coming to
    your instances.
    A bad example would be a metric exporting an average or median
    latency, since this value can't include a chunk assignable to a
    single instance, it could be better used with utilization_target
    instead.
    """
    target: Optional[pulumi.Input[float]] = pulumi.input_property("target")
    """
    Fraction of backend capacity utilization (set in HTTP(s) load
    balancing configuration) that autoscaler should maintain. Must
    be a positive float value. If not defined, the default is 0.8.
    """
    type: Optional[pulumi.Input[str]] = pulumi.input_property("type")
    """
    Defines how target utilization value is expressed for a
    Stackdriver Monitoring metric.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], filter: Optional[pulumi.Input[str]] = None, single_instance_assignment: Optional[pulumi.Input[float]] = None, target: Optional[pulumi.Input[float]] = None, type: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] name: The identifier (type) of the Stackdriver Monitoring metric.
               The metric cannot have negative values.
               The metric must have a value type of INT64 or DOUBLE.
        :param pulumi.Input[str] filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param pulumi.Input[float] single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param pulumi.Input[float] target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param pulumi.Input[str] type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
        """
        __self__.name = name
        __self__.filter = filter
        __self__.single_instance_assignment = single_instance_assignment
        __self__.target = target
        __self__.type = type

@pulumi.input_type
class RegionAutoscalerAutoscalingPolicyScaleDownControlArgs:
    max_scaled_down_replicas: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs']] = pulumi.input_property("maxScaledDownReplicas")
    """
    A nested object resource  Structure is documented below.
    """
    time_window_sec: Optional[pulumi.Input[float]] = pulumi.input_property("timeWindowSec")
    """
    How long back autoscaling should look when computing recommendations
    to include directives regarding slower scale down, as described above.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_scaled_down_replicas: Optional[pulumi.Input['RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs']] = None, time_window_sec: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs'] max_scaled_down_replicas: A nested object resource  Structure is documented below.
        :param pulumi.Input[float] time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        __self__.max_scaled_down_replicas = max_scaled_down_replicas
        __self__.time_window_sec = time_window_sec

@pulumi.input_type
class RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs:
    fixed: Optional[pulumi.Input[float]] = pulumi.input_property("fixed")
    """
    Specifies a fixed number of VM instances. This must be a positive
    integer.
    """
    percent: Optional[pulumi.Input[float]] = pulumi.input_property("percent")
    """
    Specifies a percentage of instances between 0 to 100%, inclusive.
    For example, specify 80 for 80%.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed: Optional[pulumi.Input[float]] = None, percent: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param pulumi.Input[float] percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        __self__.fixed = fixed
        __self__.percent = percent

@pulumi.input_type
class RegionBackendServiceBackendArgs:
    group: pulumi.Input[str] = pulumi.input_property("group")
    """
    The fully-qualified URL of an Instance Group or Network Endpoint
    Group resource. In case of instance group this defines the list
    of instances that serve traffic. Member virtual machine
    instances from each instance group must live in the same zone as
    the instance group itself. No two backends in a backend service
    are allowed to use same Instance Group resource.
    For Network Endpoint Groups this defines list of endpoints. All
    endpoints of Network Endpoint Group must be hosted on instances
    located in the same zone as the Network Endpoint Group.
    Backend services cannot mix Instance Group and
    Network Endpoint Group backends.
    When the `load_balancing_scheme` is INTERNAL, only instance groups
    are supported.
    Note that you must specify an Instance Group or Network Endpoint
    Group resource using the fully-qualified URL, rather than a
    partial URL.
    """
    balancing_mode: Optional[pulumi.Input[str]] = pulumi.input_property("balancingMode")
    """
    Specifies the balancing mode for this backend.
    """
    capacity_scaler: Optional[pulumi.Input[float]] = pulumi.input_property("capacityScaler")
    """
    A multiplier applied to the group's maximum servicing capacity
    (based on UTILIZATION, RATE or CONNECTION).
    ~>**NOTE**: This field cannot be set for
    INTERNAL region backend services (default loadBalancingScheme),
    but is required for non-INTERNAL backend service. The total
    capacity_scaler for all backends must be non-zero.
    A setting of 0 means the group is completely drained, offering
    0% of its available Capacity. Valid range is [0.0,1.0].
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    An optional description of this resource.
    Provide this property when you create the resource.
    """
    failover: Optional[pulumi.Input[bool]] = pulumi.input_property("failover")
    """
    This field designates whether this is a failover backend. More
    than one failover backend can be configured for a given RegionBackendService.
    """
    max_connections: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnections")
    """
    The maximum number of connections to the backend cluster.
    Defaults to 1024.
    """
    max_connections_per_endpoint: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnectionsPerEndpoint")
    """
    The max number of simultaneous connections that a single backend
    network endpoint can handle. Cannot be set
    for INTERNAL backend services.
    This is used to calculate the capacity of the group. Can be
    used in either CONNECTION or UTILIZATION balancing modes. For
    CONNECTION mode, either maxConnections or
    maxConnectionsPerEndpoint must be set.
    """
    max_connections_per_instance: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnectionsPerInstance")
    """
    The max number of simultaneous connections that a single
    backend instance can handle. Cannot be set for INTERNAL backend
    services.
    This is used to calculate the capacity of the group.
    Can be used in either CONNECTION or UTILIZATION balancing modes.
    For CONNECTION mode, either maxConnections or
    maxConnectionsPerInstance must be set.
    """
    max_rate: Optional[pulumi.Input[float]] = pulumi.input_property("maxRate")
    """
    The max requests per second (RPS) of the group. Cannot be set
    for INTERNAL backend services.
    Can be used with either RATE or UTILIZATION balancing modes,
    but required if RATE mode. Either maxRate or one
    of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
    group type, must be set.
    """
    max_rate_per_endpoint: Optional[pulumi.Input[float]] = pulumi.input_property("maxRatePerEndpoint")
    """
    The max requests per second (RPS) that a single backend network
    endpoint can handle. This is used to calculate the capacity of
    the group. Can be used in either balancing mode. For RATE mode,
    either maxRate or maxRatePerEndpoint must be set. Cannot be set
    for INTERNAL backend services.
    """
    max_rate_per_instance: Optional[pulumi.Input[float]] = pulumi.input_property("maxRatePerInstance")
    """
    The max requests per second (RPS) that a single backend
    instance can handle. This is used to calculate the capacity of
    the group. Can be used in either balancing mode. For RATE mode,
    either maxRate or maxRatePerInstance must be set. Cannot be set
    for INTERNAL backend services.
    """
    max_utilization: Optional[pulumi.Input[float]] = pulumi.input_property("maxUtilization")
    """
    Used when balancingMode is UTILIZATION. This ratio defines the
    CPU utilization target for the group. Valid range is [0.0, 1.0].
    Cannot be set for INTERNAL backend services.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, group: pulumi.Input[str], balancing_mode: Optional[pulumi.Input[str]] = None, capacity_scaler: Optional[pulumi.Input[float]] = None, description: Optional[pulumi.Input[str]] = None, failover: Optional[pulumi.Input[bool]] = None, max_connections: Optional[pulumi.Input[float]] = None, max_connections_per_endpoint: Optional[pulumi.Input[float]] = None, max_connections_per_instance: Optional[pulumi.Input[float]] = None, max_rate: Optional[pulumi.Input[float]] = None, max_rate_per_endpoint: Optional[pulumi.Input[float]] = None, max_rate_per_instance: Optional[pulumi.Input[float]] = None, max_utilization: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               When the `load_balancing_scheme` is INTERNAL, only instance groups
               are supported.
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param pulumi.Input[str] balancing_mode: Specifies the balancing mode for this backend.
        :param pulumi.Input[float] capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               ~>**NOTE**: This field cannot be set for
               INTERNAL region backend services (default loadBalancingScheme),
               but is required for non-INTERNAL backend service. The total
               capacity_scaler for all backends must be non-zero.
               A setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param pulumi.Input[str] description: An optional description of this resource.
               Provide this property when you create the resource.
        :param pulumi.Input[bool] failover: This field designates whether this is a failover backend. More
               than one failover backend can be configured for a given RegionBackendService.
        :param pulumi.Input[float] max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. Cannot be set
               for INTERNAL backend services.
               This is used to calculate the capacity of the group. Can be
               used in either CONNECTION or UTILIZATION balancing modes. For
               CONNECTION mode, either maxConnections or
               maxConnectionsPerEndpoint must be set.
        :param pulumi.Input[float] max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. Cannot be set for INTERNAL backend
               services.
               This is used to calculate the capacity of the group.
               Can be used in either CONNECTION or UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param pulumi.Input[float] max_rate: The max requests per second (RPS) of the group. Cannot be set
               for INTERNAL backend services.
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. Either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param pulumi.Input[float] max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set. Cannot be set
               for INTERNAL backend services.
        :param pulumi.Input[float] max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set. Cannot be set
               for INTERNAL backend services.
        :param pulumi.Input[float] max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. Valid range is [0.0, 1.0].
               Cannot be set for INTERNAL backend services.
        """
        __self__.group = group
        __self__.balancing_mode = balancing_mode
        __self__.capacity_scaler = capacity_scaler
        __self__.description = description
        __self__.failover = failover
        __self__.max_connections = max_connections
        __self__.max_connections_per_endpoint = max_connections_per_endpoint
        __self__.max_connections_per_instance = max_connections_per_instance
        __self__.max_rate = max_rate
        __self__.max_rate_per_endpoint = max_rate_per_endpoint
        __self__.max_rate_per_instance = max_rate_per_instance
        __self__.max_utilization = max_utilization

@pulumi.input_type
class RegionBackendServiceCircuitBreakersArgs:
    connect_timeout: Optional[pulumi.Input['RegionBackendServiceCircuitBreakersConnectTimeoutArgs']] = pulumi.input_property("connectTimeout")
    """
    The timeout for new network connections to hosts.  Structure is documented below.
    """
    max_connections: Optional[pulumi.Input[float]] = pulumi.input_property("maxConnections")
    """
    The maximum number of connections to the backend cluster.
    Defaults to 1024.
    """
    max_pending_requests: Optional[pulumi.Input[float]] = pulumi.input_property("maxPendingRequests")
    """
    The maximum number of pending requests to the backend cluster.
    Defaults to 1024.
    """
    max_requests: Optional[pulumi.Input[float]] = pulumi.input_property("maxRequests")
    """
    The maximum number of parallel requests to the backend cluster.
    Defaults to 1024.
    """
    max_requests_per_connection: Optional[pulumi.Input[float]] = pulumi.input_property("maxRequestsPerConnection")
    """
    Maximum requests for a single backend connection. This parameter
    is respected by both the HTTP/1.1 and HTTP/2 implementations. If
    not specified, there is no limit. Setting this parameter to 1
    will effectively disable keep alive.
    """
    max_retries: Optional[pulumi.Input[float]] = pulumi.input_property("maxRetries")
    """
    The maximum number of parallel retries to the backend cluster.
    Defaults to 3.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, connect_timeout: Optional[pulumi.Input['RegionBackendServiceCircuitBreakersConnectTimeoutArgs']] = None, max_connections: Optional[pulumi.Input[float]] = None, max_pending_requests: Optional[pulumi.Input[float]] = None, max_requests: Optional[pulumi.Input[float]] = None, max_requests_per_connection: Optional[pulumi.Input[float]] = None, max_retries: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['RegionBackendServiceCircuitBreakersConnectTimeoutArgs'] connect_timeout: The timeout for new network connections to hosts.  Structure is documented below.
        :param pulumi.Input[float] max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param pulumi.Input[float] max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param pulumi.Input[float] max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        __self__.connect_timeout = connect_timeout
        __self__.max_connections = max_connections
        __self__.max_pending_requests = max_pending_requests
        __self__.max_requests = max_requests
        __self__.max_requests_per_connection = max_requests_per_connection
        __self__.max_retries = max_retries

@pulumi.input_type
class RegionBackendServiceCircuitBreakersConnectTimeoutArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionBackendServiceConsistentHashArgs:
    http_cookie: Optional[pulumi.Input['RegionBackendServiceConsistentHashHttpCookieArgs']] = pulumi.input_property("httpCookie")
    """
    Hash is based on HTTP Cookie. This field describes a HTTP cookie
    that will be used as the hash key for the consistent hash load
    balancer. If the cookie is not present, it will be generated.
    This field is applicable if the sessionAffinity is set to HTTP_COOKIE.  Structure is documented below.
    """
    http_header_name: Optional[pulumi.Input[str]] = pulumi.input_property("httpHeaderName")
    """
    The hash based on the value of the specified header field.
    This field is applicable if the sessionAffinity is set to HEADER_FIELD.
    """
    minimum_ring_size: Optional[pulumi.Input[float]] = pulumi.input_property("minimumRingSize")
    """
    The minimum number of virtual nodes to use for the hash ring.
    Larger ring sizes result in more granular load
    distributions. If the number of hosts in the load balancing pool
    is larger than the ring size, each host will be assigned a single
    virtual node.
    Defaults to 1024.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_cookie: Optional[pulumi.Input['RegionBackendServiceConsistentHashHttpCookieArgs']] = None, http_header_name: Optional[pulumi.Input[str]] = None, minimum_ring_size: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['RegionBackendServiceConsistentHashHttpCookieArgs'] http_cookie: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.  Structure is documented below.
        :param pulumi.Input[str] http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param pulumi.Input[float] minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        __self__.http_cookie = http_cookie
        __self__.http_header_name = http_header_name
        __self__.minimum_ring_size = minimum_ring_size

@pulumi.input_type
class RegionBackendServiceConsistentHashHttpCookieArgs:
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    Name of the cookie.
    """
    path: Optional[pulumi.Input[str]] = pulumi.input_property("path")
    """
    Path to set for the cookie.
    """
    ttl: Optional[pulumi.Input['RegionBackendServiceConsistentHashHttpCookieTtlArgs']] = pulumi.input_property("ttl")
    """
    Lifetime of the cookie.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: Optional[pulumi.Input[str]] = None, path: Optional[pulumi.Input[str]] = None, ttl: Optional[pulumi.Input['RegionBackendServiceConsistentHashHttpCookieTtlArgs']] = None) -> None:
        """
        :param pulumi.Input[str] name: Name of the cookie.
        :param pulumi.Input[str] path: Path to set for the cookie.
        :param pulumi.Input['RegionBackendServiceConsistentHashHttpCookieTtlArgs'] ttl: Lifetime of the cookie.  Structure is documented below.
        """
        __self__.name = name
        __self__.path = path
        __self__.ttl = ttl

@pulumi.input_type
class RegionBackendServiceConsistentHashHttpCookieTtlArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionBackendServiceFailoverPolicyArgs:
    disable_connection_drain_on_failover: Optional[pulumi.Input[bool]] = pulumi.input_property("disableConnectionDrainOnFailover")
    """
    On failover or failback, this field indicates whether connection drain
    will be honored. Setting this to true has the following effect: connections
    to the old active pool are not drained. Connections to the new active pool
    use the timeout of 10 min (currently fixed). Setting to false has the
    following effect: both old and new connections will have a drain timeout
    of 10 min.
    This can be set to true only if the protocol is TCP.
    The default is false.
    """
    drop_traffic_if_unhealthy: Optional[pulumi.Input[bool]] = pulumi.input_property("dropTrafficIfUnhealthy")
    """
    This option is used only when no healthy VMs are detected in the primary
    and backup instance groups. When set to true, traffic is dropped. When
    set to false, new connections are sent across all VMs in the primary group.
    The default is false.
    """
    failover_ratio: Optional[pulumi.Input[float]] = pulumi.input_property("failoverRatio")
    """
    The value of the field must be in [0, 1]. If the ratio of the healthy
    VMs in the primary backend is at or below this number, traffic arriving
    at the load-balanced IP will be directed to the failover backend.
    In case where 'failoverRatio' is not set or all the VMs in the backup
    backend are unhealthy, the traffic will be directed back to the primary
    backend in the "force" mode, where traffic will be spread to the healthy
    VMs with the best effort, or to all VMs when no VM is healthy.
    This field is only used with l4 load balancing.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, disable_connection_drain_on_failover: Optional[pulumi.Input[bool]] = None, drop_traffic_if_unhealthy: Optional[pulumi.Input[bool]] = None, failover_ratio: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] disable_connection_drain_on_failover: On failover or failback, this field indicates whether connection drain
               will be honored. Setting this to true has the following effect: connections
               to the old active pool are not drained. Connections to the new active pool
               use the timeout of 10 min (currently fixed). Setting to false has the
               following effect: both old and new connections will have a drain timeout
               of 10 min.
               This can be set to true only if the protocol is TCP.
               The default is false.
        :param pulumi.Input[bool] drop_traffic_if_unhealthy: This option is used only when no healthy VMs are detected in the primary
               and backup instance groups. When set to true, traffic is dropped. When
               set to false, new connections are sent across all VMs in the primary group.
               The default is false.
        :param pulumi.Input[float] failover_ratio: The value of the field must be in [0, 1]. If the ratio of the healthy
               VMs in the primary backend is at or below this number, traffic arriving
               at the load-balanced IP will be directed to the failover backend.
               In case where 'failoverRatio' is not set or all the VMs in the backup
               backend are unhealthy, the traffic will be directed back to the primary
               backend in the "force" mode, where traffic will be spread to the healthy
               VMs with the best effort, or to all VMs when no VM is healthy.
               This field is only used with l4 load balancing.
        """
        __self__.disable_connection_drain_on_failover = disable_connection_drain_on_failover
        __self__.drop_traffic_if_unhealthy = drop_traffic_if_unhealthy
        __self__.failover_ratio = failover_ratio

@pulumi.input_type
class RegionBackendServiceLogConfigArgs:
    enable: Optional[pulumi.Input[bool]] = pulumi.input_property("enable")
    """
    Whether to enable logging for the load balancer traffic served by this backend service.
    """
    sample_rate: Optional[pulumi.Input[float]] = pulumi.input_property("sampleRate")
    """
    This field can only be specified if logging is enabled for this backend service. The value of
    the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
    where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
    The default value is 1.0.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable: Optional[pulumi.Input[bool]] = None, sample_rate: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param pulumi.Input[float] sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        __self__.enable = enable
        __self__.sample_rate = sample_rate

@pulumi.input_type
class RegionBackendServiceOutlierDetectionArgs:
    base_ejection_time: Optional[pulumi.Input['RegionBackendServiceOutlierDetectionBaseEjectionTimeArgs']] = pulumi.input_property("baseEjectionTime")
    """
    The base time that a host is ejected for. The real time is equal to the base
    time multiplied by the number of times the host has been ejected. Defaults to
    30000ms or 30s.  Structure is documented below.
    """
    consecutive_errors: Optional[pulumi.Input[float]] = pulumi.input_property("consecutiveErrors")
    """
    Number of errors before a host is ejected from the connection pool. When the
    backend host is accessed over HTTP, a 5xx return code qualifies as an error.
    Defaults to 5.
    """
    consecutive_gateway_failure: Optional[pulumi.Input[float]] = pulumi.input_property("consecutiveGatewayFailure")
    """
    The number of consecutive gateway failures (502, 503, 504 status or connection
    errors that are mapped to one of those status codes) before a consecutive
    gateway failure ejection occurs. Defaults to 5.
    """
    enforcing_consecutive_errors: Optional[pulumi.Input[float]] = pulumi.input_property("enforcingConsecutiveErrors")
    """
    The percentage chance that a host will be actually ejected when an outlier
    status is detected through consecutive 5xx. This setting can be used to disable
    ejection or to ramp it up slowly. Defaults to 100.
    """
    enforcing_consecutive_gateway_failure: Optional[pulumi.Input[float]] = pulumi.input_property("enforcingConsecutiveGatewayFailure")
    """
    The percentage chance that a host will be actually ejected when an outlier
    status is detected through consecutive gateway failures. This setting can be
    used to disable ejection or to ramp it up slowly. Defaults to 0.
    """
    enforcing_success_rate: Optional[pulumi.Input[float]] = pulumi.input_property("enforcingSuccessRate")
    """
    The percentage chance that a host will be actually ejected when an outlier
    status is detected through success rate statistics. This setting can be used to
    disable ejection or to ramp it up slowly. Defaults to 100.
    """
    interval: Optional[pulumi.Input['RegionBackendServiceOutlierDetectionIntervalArgs']] = pulumi.input_property("interval")
    """
    Time interval between ejection sweep analysis. This can result in both new
    ejections as well as hosts being returned to service. Defaults to 10 seconds.  Structure is documented below.
    """
    max_ejection_percent: Optional[pulumi.Input[float]] = pulumi.input_property("maxEjectionPercent")
    """
    Maximum percentage of hosts in the load balancing pool for the backend service
    that can be ejected. Defaults to 10%.
    """
    success_rate_minimum_hosts: Optional[pulumi.Input[float]] = pulumi.input_property("successRateMinimumHosts")
    """
    The number of hosts in a cluster that must have enough request volume to detect
    success rate outliers. If the number of hosts is less than this setting, outlier
    detection via success rate statistics is not performed for any host in the
    cluster. Defaults to 5.
    """
    success_rate_request_volume: Optional[pulumi.Input[float]] = pulumi.input_property("successRateRequestVolume")
    """
    The minimum number of total requests that must be collected in one interval (as
    defined by the interval duration above) to include this host in success rate
    based outlier detection. If the volume is lower than this setting, outlier
    detection via success rate statistics is not performed for that host. Defaults
    to 100.
    """
    success_rate_stdev_factor: Optional[pulumi.Input[float]] = pulumi.input_property("successRateStdevFactor")
    """
    This factor is used to determine the ejection threshold for success rate outlier
    ejection. The ejection threshold is the difference between the mean success
    rate, and the product of this factor and the standard deviation of the mean
    success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
    by a thousand to get a double. That is, if the desired factor is 1.9, the
    runtime value should be 1900. Defaults to 1900.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, base_ejection_time: Optional[pulumi.Input['RegionBackendServiceOutlierDetectionBaseEjectionTimeArgs']] = None, consecutive_errors: Optional[pulumi.Input[float]] = None, consecutive_gateway_failure: Optional[pulumi.Input[float]] = None, enforcing_consecutive_errors: Optional[pulumi.Input[float]] = None, enforcing_consecutive_gateway_failure: Optional[pulumi.Input[float]] = None, enforcing_success_rate: Optional[pulumi.Input[float]] = None, interval: Optional[pulumi.Input['RegionBackendServiceOutlierDetectionIntervalArgs']] = None, max_ejection_percent: Optional[pulumi.Input[float]] = None, success_rate_minimum_hosts: Optional[pulumi.Input[float]] = None, success_rate_request_volume: Optional[pulumi.Input[float]] = None, success_rate_stdev_factor: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['RegionBackendServiceOutlierDetectionBaseEjectionTimeArgs'] base_ejection_time: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.  Structure is documented below.
        :param pulumi.Input[float] consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param pulumi.Input[float] consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param pulumi.Input[float] enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param pulumi.Input[float] enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param pulumi.Input[float] enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param pulumi.Input['RegionBackendServiceOutlierDetectionIntervalArgs'] interval: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.  Structure is documented below.
        :param pulumi.Input[float] max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param pulumi.Input[float] success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param pulumi.Input[float] success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param pulumi.Input[float] success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        __self__.base_ejection_time = base_ejection_time
        __self__.consecutive_errors = consecutive_errors
        __self__.consecutive_gateway_failure = consecutive_gateway_failure
        __self__.enforcing_consecutive_errors = enforcing_consecutive_errors
        __self__.enforcing_consecutive_gateway_failure = enforcing_consecutive_gateway_failure
        __self__.enforcing_success_rate = enforcing_success_rate
        __self__.interval = interval
        __self__.max_ejection_percent = max_ejection_percent
        __self__.success_rate_minimum_hosts = success_rate_minimum_hosts
        __self__.success_rate_request_volume = success_rate_request_volume
        __self__.success_rate_stdev_factor = success_rate_stdev_factor

@pulumi.input_type
class RegionBackendServiceOutlierDetectionBaseEjectionTimeArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionBackendServiceOutlierDetectionIntervalArgs:
    seconds: pulumi.Input[float] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[float], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionDiskDiskEncryptionKeyArgs:
    kms_key_name: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeyName")
    """
    The name of the encryption key that is stored in Google Cloud KMS.
    """
    raw_key: Optional[pulumi.Input[str]] = pulumi.input_property("rawKey")
    """
    Specifies a 256-bit customer-supplied encryption key, encoded in
    RFC 4648 base64 to either encrypt or decrypt this resource.
    """
    sha256: Optional[pulumi.Input[str]] = pulumi.input_property("sha256")
    """
    -
    The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
    encryption key that protects this resource.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, kms_key_name: Optional[pulumi.Input[str]] = None, raw_key: Optional[pulumi.Input[str]] = None, sha256: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param pulumi.Input[str] raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param pulumi.Input[str] sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        __self__.kms_key_name = kms_key_name
        __self__.raw_key = raw_key
        __self__.sha256 = sha256

@pulumi.input_type
class RegionDiskSourceSnapshotEncryptionKeyArgs:
    kms_key_name: Optional[pulumi.Input[str]] = pulumi.input_property("kmsKeyName")
    """
    The name of the encryption key that is stored in Google Cloud KMS.
    """
    raw_key: Optional[pulumi.Input[str]] = pulumi.input_property("rawKey")
    """
    Specifies a 256-bit customer-supplied encryption key, encoded in
    RFC 4648 base64 to either encrypt or decrypt this resource.
    """
    sha256: Optional[pulumi.Input[str]] = pulumi.input_property("sha256")
    """
    -
    The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
    encryption key that protects this resource.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, kms_key_name: Optional[pulumi.Input[str]] = None, raw_key: Optional[pulumi.Input[str]] = None, sha256: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param pulumi.Input[str] raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param pulumi.Input[str] sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        __self__.kms_key_name = kms_key_name
        __self__.raw_key = raw_key
        __self__.sha256 = sha256

@pulumi.input_type
class RegionHealthCheckHttp2HealthCheckArgs:
    host: Optional[pulumi.Input[str]] = pulumi.input_property("host")
    """
    The value of the host header in the HTTP2 health check request.
    If left empty (default value), the public IP on behalf of which this health
    check is performed will be used.
    """
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request_path: Optional[pulumi.Input[str]] = pulumi.input_property("requestPath")
    """
    The request path of the HTTP2 health check request.
    The default value is /.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: Optional[pulumi.Input[str]] = None, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request_path: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.host = host
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request_path = request_path
        __self__.response = response

@pulumi.input_type
class RegionHealthCheckHttpHealthCheckArgs:
    host: Optional[pulumi.Input[str]] = pulumi.input_property("host")
    """
    The value of the host header in the HTTP2 health check request.
    If left empty (default value), the public IP on behalf of which this health
    check is performed will be used.
    """
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request_path: Optional[pulumi.Input[str]] = pulumi.input_property("requestPath")
    """
    The request path of the HTTP2 health check request.
    The default value is /.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: Optional[pulumi.Input[str]] = None, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request_path: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.host = host
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request_path = request_path
        __self__.response = response

@pulumi.input_type
class RegionHealthCheckHttpsHealthCheckArgs:
    host: Optional[pulumi.Input[str]] = pulumi.input_property("host")
    """
    The value of the host header in the HTTP2 health check request.
    If left empty (default value), the public IP on behalf of which this health
    check is performed will be used.
    """
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request_path: Optional[pulumi.Input[str]] = pulumi.input_property("requestPath")
    """
    The request path of the HTTP2 health check request.
    The default value is /.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: Optional[pulumi.Input[str]] = None, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request_path: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.host = host
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request_path = request_path
        __self__.response = response

@pulumi.input_type
class RegionHealthCheckLogConfigArgs:
    enable: Optional[pulumi.Input[bool]] = pulumi.input_property("enable")
    """
    Indicates whether or not to export logs. This is false by default,
    which means no health check logging will be done.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[bool] enable: Indicates whether or not to export logs. This is false by default,
               which means no health check logging will be done.
        """
        __self__.enable = enable

@pulumi.input_type
class RegionHealthCheckSslHealthCheckArgs:
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request: Optional[pulumi.Input[str]] = pulumi.input_property("request")
    """
    The application data to send once the SSL connection has been
    established (default value is empty). If both request and response are
    empty, the connection establishment alone will indicate health. The request
    data can only be ASCII.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request = request
        __self__.response = response

@pulumi.input_type
class RegionHealthCheckTcpHealthCheckArgs:
    port: Optional[pulumi.Input[float]] = pulumi.input_property("port")
    """
    The TCP port number for the HTTP2 health check request.
    The default value is 443.
    """
    port_name: Optional[pulumi.Input[str]] = pulumi.input_property("portName")
    """
    Port name as defined in InstanceGroup#NamedPort#name. If both port and
    port_name are defined, port takes precedence.
    """
    port_specification: Optional[pulumi.Input[str]] = pulumi.input_property("portSpecification")
    """
    Specifies how port is selected for health checking, can be one of the
    following values:
    * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
    * `USE_NAMED_PORT`: The `portName` is used for health checking.
    * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
    network endpoint is used for health checking. For other backends, the
    port or named port specified in the Backend Service is used for health
    checking.
    If not specified, HTTP2 health check follows behavior specified in `port` and
    `portName` fields.
    """
    proxy_header: Optional[pulumi.Input[str]] = pulumi.input_property("proxyHeader")
    """
    Specifies the type of proxy header to append before sending data to the
    backend.
    """
    request: Optional[pulumi.Input[str]] = pulumi.input_property("request")
    """
    The application data to send once the SSL connection has been
    established (default value is empty). If both request and response are
    empty, the connection establishment alone will indicate health. The request
    data can only be ASCII.
    """
    response: Optional[pulumi.Input[str]] = pulumi.input_property("response")
    """
    The bytes to match against the beginning of the response data. If left empty
    (the default value), any response will indicate health. The response data
    can only be ASCII.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, port: Optional[pulumi.Input[float]] = None, port_name: Optional[pulumi.Input[str]] = None, port_specification: Optional[pulumi.Input[str]] = None, proxy_header: Optional[pulumi.Input[str]] = None, request: Optional[pulumi.Input[str]] = None, response: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param pulumi.Input[str] port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param pulumi.Input[str] port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
        :param pulumi.Input[str] proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
        :param pulumi.Input[str] request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param pulumi.Input[str] response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        __self__.port = port
        __self__.port_name = port_name
        __self__.port_specification = port_specification
        __self__.proxy_header = proxy_header
        __self__.request = request
        __self__.response = response

@pulumi.input_type
class RegionInstanceGroupManagerAutoHealingPoliciesArgs:
    health_check: pulumi.Input[str] = pulumi.input_property("healthCheck")
    """
    The health check resource that signals autohealing.
    """
    initial_delay_sec: pulumi.Input[float] = pulumi.input_property("initialDelaySec")
    """
    The number of seconds that the managed instance group waits before
    it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, health_check: pulumi.Input[str], initial_delay_sec: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[str] health_check: The health check resource that signals autohealing.
        :param pulumi.Input[float] initial_delay_sec: The number of seconds that the managed instance group waits before
               it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        __self__.health_check = health_check
        __self__.initial_delay_sec = initial_delay_sec

@pulumi.input_type
class RegionInstanceGroupManagerNamedPortArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    - Version name.
    """
    port: pulumi.Input[float] = pulumi.input_property("port")
    """
    The port number.
    - - -
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], port: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[str] name: - Version name.
        :param pulumi.Input[float] port: The port number.
               - - -
        """
        __self__.name = name
        __self__.port = port

@pulumi.input_type
class RegionInstanceGroupManagerStatefulDiskArgs:
    device_name: pulumi.Input[str] = pulumi.input_property("deviceName")
    """
    , The device name of the disk to be attached.
    """
    delete_rule: Optional[pulumi.Input[str]] = pulumi.input_property("deleteRule")
    """
    , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` detatch the disk when the VM is deleted, but not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, device_name: pulumi.Input[str], delete_rule: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] device_name: , The device name of the disk to be attached.
        :param pulumi.Input[str] delete_rule: , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` detatch the disk when the VM is deleted, but not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        __self__.device_name = device_name
        __self__.delete_rule = delete_rule

@pulumi.input_type
class RegionInstanceGroupManagerUpdatePolicyArgs:
    minimal_action: pulumi.Input[str] = pulumi.input_property("minimalAction")
    """
    - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    """
    type: pulumi.Input[str] = pulumi.input_property("type")
    """
    - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    """
    instance_redistribution_type: Optional[pulumi.Input[str]] = pulumi.input_property("instanceRedistributionType")
    """
    - The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
    """
    max_surge_fixed: Optional[pulumi.Input[float]] = pulumi.input_property("maxSurgeFixed")
    """
    , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. It has to be either 0 or at least equal to the number of zones.  If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
    """
    max_surge_percent: Optional[pulumi.Input[float]] = pulumi.input_property("maxSurgePercent")
    """
    , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
    """
    max_unavailable_fixed: Optional[pulumi.Input[float]] = pulumi.input_property("maxUnavailableFixed")
    """
    , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. It has to be either 0 or at least equal to the number of zones. If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
    """
    max_unavailable_percent: Optional[pulumi.Input[float]] = pulumi.input_property("maxUnavailablePercent")
    """
    , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
    """
    min_ready_sec: Optional[pulumi.Input[float]] = pulumi.input_property("minReadySec")
    """
    , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
    - - -
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, minimal_action: pulumi.Input[str], type: pulumi.Input[str], instance_redistribution_type: Optional[pulumi.Input[str]] = None, max_surge_fixed: Optional[pulumi.Input[float]] = None, max_surge_percent: Optional[pulumi.Input[float]] = None, max_unavailable_fixed: Optional[pulumi.Input[float]] = None, max_unavailable_percent: Optional[pulumi.Input[float]] = None, min_ready_sec: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] minimal_action: - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param pulumi.Input[str] type: - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        :param pulumi.Input[str] instance_redistribution_type: - The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
        :param pulumi.Input[float] max_surge_fixed: , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. It has to be either 0 or at least equal to the number of zones.  If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        :param pulumi.Input[float] max_surge_percent: , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        :param pulumi.Input[float] max_unavailable_fixed: , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. It has to be either 0 or at least equal to the number of zones. If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        :param pulumi.Input[float] max_unavailable_percent: , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        :param pulumi.Input[float] min_ready_sec: , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
               - - -
        """
        __self__.minimal_action = minimal_action
        __self__.type = type
        __self__.instance_redistribution_type = instance_redistribution_type
        __self__.max_surge_fixed = max_surge_fixed
        __self__.max_surge_percent = max_surge_percent
        __self__.max_unavailable_fixed = max_unavailable_fixed
        __self__.max_unavailable_percent = max_unavailable_percent
        __self__.min_ready_sec = min_ready_sec

@pulumi.input_type
class RegionInstanceGroupManagerVersionArgs:
    instance_template: pulumi.Input[str] = pulumi.input_property("instanceTemplate")
    """
    - The full URL to an instance template from which all new instances of this version will be created.
    """
    name: Optional[pulumi.Input[str]] = pulumi.input_property("name")
    """
    - Version name.
    """
    target_size: Optional[pulumi.Input['RegionInstanceGroupManagerVersionTargetSizeArgs']] = pulumi.input_property("targetSize")
    """
    - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, instance_template: pulumi.Input[str], name: Optional[pulumi.Input[str]] = None, target_size: Optional[pulumi.Input['RegionInstanceGroupManagerVersionTargetSizeArgs']] = None) -> None:
        """
        :param pulumi.Input[str] instance_template: - The full URL to an instance template from which all new instances of this version will be created.
        :param pulumi.Input[str] name: - Version name.
        :param pulumi.Input['RegionInstanceGroupManagerVersionTargetSizeArgs'] target_size: - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        __self__.instance_template = instance_template
        __self__.name = name
        __self__.target_size = target_size

@pulumi.input_type
class RegionInstanceGroupManagerVersionTargetSizeArgs:
    fixed: Optional[pulumi.Input[float]] = pulumi.input_property("fixed")
    """
    , The number of instances which are managed for this version. Conflicts with `percent`.
    """
    percent: Optional[pulumi.Input[float]] = pulumi.input_property("percent")
    """
    , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
    Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
    one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed: Optional[pulumi.Input[float]] = None, percent: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] fixed: , The number of instances which are managed for this version. Conflicts with `percent`.
        :param pulumi.Input[float] percent: , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
               Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
               one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        __self__.fixed = fixed
        __self__.percent = percent

@pulumi.input_type
class RegionPerInstanceConfigPreservedStateArgs:
    disks: Optional[pulumi.Input[List[pulumi.Input['RegionPerInstanceConfigPreservedStateDiskArgs']]]] = pulumi.input_property("disks")
    """
    Stateful disks for the instance.  Structure is documented below.
    """
    metadata: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = pulumi.input_property("metadata")
    """
    Preserved metadata defined for this instance. This is a list of key->value pairs.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, disks: Optional[pulumi.Input[List[pulumi.Input['RegionPerInstanceConfigPreservedStateDiskArgs']]]] = None, metadata: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['RegionPerInstanceConfigPreservedStateDiskArgs']]] disks: Stateful disks for the instance.  Structure is documented below.
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] metadata: Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        __self__.disks = disks
        __self__.metadata = metadata

@pulumi.input_type
class RegionPerInstanceConfigPreservedStateDiskArgs:
    device_name: pulumi.Input[str] = pulumi.input_property("deviceName")
    """
    A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    """
    source: pulumi.Input[str] = pulumi.input_property("source")
    """
    The URI of an existing persistent disk to attach under the specified device-name in the format
    `projects/project-id/zones/zone/disks/disk-name`.
    """
    delete_rule: Optional[pulumi.Input[str]] = pulumi.input_property("deleteRule")
    """
    A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
    `NEVER` detatch the disk when the VM is deleted, but not delete the disk.
    `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
    deleted from the instance group.
    """
    mode: Optional[pulumi.Input[str]] = pulumi.input_property("mode")
    """
    The mode of the disk.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, device_name: pulumi.Input[str], source: pulumi.Input[str], delete_rule: Optional[pulumi.Input[str]] = None, mode: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] device_name: A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        :param pulumi.Input[str] source: The URI of an existing persistent disk to attach under the specified device-name in the format
               `projects/project-id/zones/zone/disks/disk-name`.
        :param pulumi.Input[str] delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
               The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
               `NEVER` detatch the disk when the VM is deleted, but not delete the disk.
               `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
               deleted from the instance group.
        :param pulumi.Input[str] mode: The mode of the disk.
        """
        __self__.device_name = device_name
        __self__.source = source
        __self__.delete_rule = delete_rule
        __self__.mode = mode

@pulumi.input_type
class RegionUrlMapDefaultUrlRedirectArgs:
    strip_query: pulumi.Input[bool] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, strip_query: pulumi.Input[bool], host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        __self__.strip_query = strip_query
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code

@pulumi.input_type
class RegionUrlMapHostRuleArgs:
    hosts: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("hosts")
    """
    The list of host patterns to match. They must be valid
    hostnames, except * will match any string of ([a-z0-9-.]*). In
    that case, * must be the first character and must be followed in
    the pattern by either - or ..
    """
    path_matcher: pulumi.Input[str] = pulumi.input_property("pathMatcher")
    """
    The name of the PathMatcher to use to match the path portion of
    the URL if the hostRule matches the URL's host portion.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    Description of this test case.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, hosts: pulumi.Input[List[pulumi.Input[str]]], path_matcher: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] hosts: The list of host patterns to match. They must be valid
               hostnames, except * will match any string of ([a-z0-9-.]*). In
               that case, * must be the first character and must be followed in
               the pattern by either - or ..
        :param pulumi.Input[str] path_matcher: The name of the PathMatcher to use to match the path portion of
               the URL if the hostRule matches the URL's host portion.
        :param pulumi.Input[str] description: Description of this test case.
        """
        __self__.hosts = hosts
        __self__.path_matcher = path_matcher
        __self__.description = description

@pulumi.input_type
class RegionUrlMapPathMatcherArgs:
    default_service: pulumi.Input[str] = pulumi.input_property("defaultService")
    """
    A reference to a RegionBackendService resource. This will be used if
    none of the pathRules defined by this PathMatcher is matched by
    the URL's path portion.
    """
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The name of the query parameter to match. The query parameter must exist in the
    request, in the absence of which the request match fails.
    """
    default_url_redirect: Optional[pulumi.Input['RegionUrlMapPathMatcherDefaultUrlRedirectArgs']] = pulumi.input_property("defaultUrlRedirect")
    """
    When none of the specified hostRules match, the request is redirected to a URL specified
    by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    defaultRouteAction must not be set.  Structure is documented below.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    Description of this test case.
    """
    path_rules: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleArgs']]]] = pulumi.input_property("pathRules")
    """
    The list of path rules. Use this list instead of routeRules when routing based
    on simple path matching is all that's required. The order by which path rules
    are specified does not matter. Matches are always done on the longest-path-first
    basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    irrespective of the order in which those paths appear in this list. Within a
    given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
    """
    route_rules: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleArgs']]]] = pulumi.input_property("routeRules")
    """
    The list of ordered HTTP route rules. Use this list instead of pathRules when
    advanced route matching and routing actions are desired. The order of specifying
    routeRules matters: the first rule that matches will cause its specified routing
    action to take effect. Within a given pathMatcher, only one of pathRules or
    routeRules must be set. routeRules are not supported in UrlMaps intended for
    External load balancers.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, default_service: pulumi.Input[str], name: pulumi.Input[str], default_url_redirect: Optional[pulumi.Input['RegionUrlMapPathMatcherDefaultUrlRedirectArgs']] = None, description: Optional[pulumi.Input[str]] = None, path_rules: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleArgs']]]] = None, route_rules: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleArgs']]]] = None) -> None:
        """
        :param pulumi.Input[str] default_service: A reference to a RegionBackendService resource. This will be used if
               none of the pathRules defined by this PathMatcher is matched by
               the URL's path portion.
        :param pulumi.Input[str] name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param pulumi.Input['RegionUrlMapPathMatcherDefaultUrlRedirectArgs'] default_url_redirect: When none of the specified hostRules match, the request is redirected to a URL specified
               by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
               defaultRouteAction must not be set.  Structure is documented below.
        :param pulumi.Input[str] description: Description of this test case.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleArgs']]] path_rules: The list of path rules. Use this list instead of routeRules when routing based
               on simple path matching is all that's required. The order by which path rules
               are specified does not matter. Matches are always done on the longest-path-first
               basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
               irrespective of the order in which those paths appear in this list. Within a
               given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleArgs']]] route_rules: The list of ordered HTTP route rules. Use this list instead of pathRules when
               advanced route matching and routing actions are desired. The order of specifying
               routeRules matters: the first rule that matches will cause its specified routing
               action to take effect. Within a given pathMatcher, only one of pathRules or
               routeRules must be set. routeRules are not supported in UrlMaps intended for
               External load balancers.  Structure is documented below.
        """
        __self__.default_service = default_service
        __self__.name = name
        __self__.default_url_redirect = default_url_redirect
        __self__.description = description
        __self__.path_rules = path_rules
        __self__.route_rules = route_rules

@pulumi.input_type
class RegionUrlMapPathMatcherDefaultUrlRedirectArgs:
    strip_query: pulumi.Input[bool] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, strip_query: pulumi.Input[bool], host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        __self__.strip_query = strip_query
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleArgs:
    paths: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("paths")
    """
    The list of path patterns to match. Each must start with / and the only place a
    * is allowed is at the end following a /. The string fed to the path matcher
    does not include any text after the first ? or #, and those chars are not
    allowed here.
    """
    route_action: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionArgs']] = pulumi.input_property("routeAction")
    """
    In response to a matching path, the load balancer performs advanced routing
    actions like URL rewrites, header transformations, etc. prior to forwarding the
    request to the selected backend. If routeAction specifies any
    weightedBackendServices, service must not be set. Conversely if service is set,
    routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    or urlRedirect must be set.  Structure is documented below.
    """
    service: Optional[pulumi.Input[str]] = pulumi.input_property("service")
    """
    A reference to expected RegionBackendService resource the given URL should be mapped to.
    """
    url_redirect: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleUrlRedirectArgs']] = pulumi.input_property("urlRedirect")
    """
    When a path pattern is matched, the request is redirected to a URL specified
    by urlRedirect. If urlRedirect is specified, service or routeAction must not
    be set.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, paths: pulumi.Input[List[pulumi.Input[str]]], route_action: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionArgs']] = None, service: Optional[pulumi.Input[str]] = None, url_redirect: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleUrlRedirectArgs']] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] paths: The list of path patterns to match. Each must start with / and the only place a
               * is allowed is at the end following a /. The string fed to the path matcher
               does not include any text after the first ? or #, and those chars are not
               allowed here.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionArgs'] route_action: In response to a matching path, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.  Structure is documented below.
        :param pulumi.Input[str] service: A reference to expected RegionBackendService resource the given URL should be mapped to.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleUrlRedirectArgs'] url_redirect: When a path pattern is matched, the request is redirected to a URL specified
               by urlRedirect. If urlRedirect is specified, service or routeAction must not
               be set.  Structure is documented below.
        """
        __self__.paths = paths
        __self__.route_action = route_action
        __self__.service = service
        __self__.url_redirect = url_redirect

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionArgs:
    cors_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicyArgs']] = pulumi.input_property("corsPolicy")
    """
    The specification for allowing client side cross-origin requests. Please see W3C
    Recommendation for Cross Origin Resource Sharing  Structure is documented below.
    """
    fault_injection_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs']] = pulumi.input_property("faultInjectionPolicy")
    """
    The specification for fault injection introduced into traffic to test the
    resiliency of clients to backend service failure. As part of fault injection,
    when clients send requests to a backend service, delays can be introduced by
    Loadbalancer on a percentage of requests before sending those request to the
    backend service. Similarly requests from clients can be aborted by the
    Loadbalancer for a percentage of requests. timeout and retry_policy will be
    ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
    """
    request_mirror_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs']] = pulumi.input_property("requestMirrorPolicy")
    """
    Specifies the policy on how requests intended for the route's backends are
    shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    responses from the shadow service. Prior to sending traffic to the shadow
    service, the host / authority header is suffixed with -shadow.  Structure is documented below.
    """
    retry_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyArgs']] = pulumi.input_property("retryPolicy")
    """
    Specifies the retry policy associated with this route.  Structure is documented below.
    """
    timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionTimeoutArgs']] = pulumi.input_property("timeout")
    """
    Specifies the timeout for the selected route. Timeout is computed from the time
    the request is has been fully processed (i.e. end-of-stream) up until the
    response has been completely processed. Timeout includes all retries. If not
    specified, the default value is 15 seconds.  Structure is documented below.
    """
    url_rewrite: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionUrlRewriteArgs']] = pulumi.input_property("urlRewrite")
    """
    The spec to modify the URL of the request, prior to forwarding the request to
    the matched service  Structure is documented below.
    """
    weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs']]]] = pulumi.input_property("weightedBackendServices")
    """
    A list of weighted backend services to send traffic to when a route match
    occurs. The weights determine the fraction of traffic that flows to their
    corresponding backend service. If all traffic needs to go to a single backend
    service, there must be one  weightedBackendService with weight set to a non 0
    number. Once a backendService is identified and before forwarding the request to
    the backend service, advanced routing actions like Url rewrites and header
    transformations are applied depending on additional settings specified in this
    HttpRouteAction.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cors_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicyArgs']] = None, fault_injection_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs']] = None, request_mirror_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs']] = None, retry_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyArgs']] = None, timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionTimeoutArgs']] = None, url_rewrite: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionUrlRewriteArgs']] = None, weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs']]]] = None) -> None:
        """
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicyArgs'] cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs'] fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs'] request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyArgs'] retry_policy: Specifies the retry policy associated with this route.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionTimeoutArgs'] timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionUrlRewriteArgs'] url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs']]] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.  Structure is documented below.
        """
        __self__.cors_policy = cors_policy
        __self__.fault_injection_policy = fault_injection_policy
        __self__.request_mirror_policy = request_mirror_policy
        __self__.retry_policy = retry_policy
        __self__.timeout = timeout
        __self__.url_rewrite = url_rewrite
        __self__.weighted_backend_services = weighted_backend_services

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicyArgs:
    disabled: pulumi.Input[bool] = pulumi.input_property("disabled")
    """
    If true, specifies the CORS policy is disabled.
    """
    allow_credentials: Optional[pulumi.Input[bool]] = pulumi.input_property("allowCredentials")
    """
    In response to a preflight request, setting this to true indicates that the
    actual request can include user credentials. This translates to the Access-
    Control-Allow-Credentials header. Defaults to false.
    """
    allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowHeaders")
    """
    Specifies the content for the Access-Control-Allow-Headers header.
    """
    allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowMethods")
    """
    Specifies the content for the Access-Control-Allow-Methods header.
    """
    allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOriginRegexes")
    """
    Specifies the regualar expression patterns that match allowed origins. For
    regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    An origin is allowed if it matches either allow_origins or allow_origin_regex.
    """
    allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOrigins")
    """
    Specifies the list of origins that will be allowed to do CORS requests. An
    origin is allowed if it matches either allow_origins or allow_origin_regex.
    """
    expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("exposeHeaders")
    """
    Specifies the content for the Access-Control-Expose-Headers header.
    """
    max_age: Optional[pulumi.Input[float]] = pulumi.input_property("maxAge")
    """
    Specifies how long the results of a preflight request can be cached. This
    translates to the content for the Access-Control-Max-Age header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, disabled: pulumi.Input[bool], allow_credentials: Optional[pulumi.Input[bool]] = None, allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, max_age: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] disabled: If true, specifies the CORS policy is disabled.
        :param pulumi.Input[bool] allow_credentials: In response to a preflight request, setting this to true indicates that the
               actual request can include user credentials. This translates to the Access-
               Control-Allow-Credentials header. Defaults to false.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For
               regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origins: Specifies the list of origins that will be allowed to do CORS requests. An
               origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param pulumi.Input[List[pulumi.Input[str]]] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param pulumi.Input[float] max_age: Specifies how long the results of a preflight request can be cached. This
               translates to the content for the Access-Control-Max-Age header.
        """
        __self__.disabled = disabled
        __self__.allow_credentials = allow_credentials
        __self__.allow_headers = allow_headers
        __self__.allow_methods = allow_methods
        __self__.allow_origin_regexes = allow_origin_regexes
        __self__.allow_origins = allow_origins
        __self__.expose_headers = expose_headers
        __self__.max_age = max_age

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs:
    abort: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs']] = pulumi.input_property("abort")
    """
    The specification for how client requests are aborted as part of fault
    injection.  Structure is documented below.
    """
    delay: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs']] = pulumi.input_property("delay")
    """
    The specification for how client requests are delayed as part of fault
    injection, before being sent to a backend service.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, abort: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs']] = None, delay: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs']] = None) -> None:
        """
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs'] abort: The specification for how client requests are aborted as part of fault
               injection.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs'] delay: The specification for how client requests are delayed as part of fault
               injection, before being sent to a backend service.  Structure is documented below.
        """
        __self__.abort = abort
        __self__.delay = delay

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs:
    http_status: pulumi.Input[float] = pulumi.input_property("httpStatus")
    """
    The HTTP status code used to abort the request. The value must be between 200
    and 599 inclusive.
    """
    percentage: pulumi.Input[float] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) on which delay will
    be introduced as part of fault injection. The value must be between 0.0 and
    100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_status: pulumi.Input[float], percentage: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] http_status: The HTTP status code used to abort the request. The value must be between 200
               and 599 inclusive.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        __self__.http_status = http_status
        __self__.percentage = percentage

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs:
    fixed_delay: pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] = pulumi.input_property("fixedDelay")
    """
    Specifies the value of the fixed delay interval.  Structure is documented below.
    """
    percentage: pulumi.Input[float] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) on which delay will
    be introduced as part of fault injection. The value must be between 0.0 and
    100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed_delay: pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'], percentage: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] fixed_delay: Specifies the value of the fixed delay interval.  Structure is documented below.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        __self__.fixed_delay = fixed_delay
        __self__.percentage = percentage

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The default RegionBackendService resource. Before
    forwarding the request to backendService, the loadbalancer applies any relevant
    headerActions specified as part of this backendServiceWeight.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        """
        __self__.backend_service = backend_service

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyArgs:
    num_retries: Optional[pulumi.Input[float]] = pulumi.input_property("numRetries")
    """
    Specifies the allowed number retries. This number must be > 0.
    """
    per_try_timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = pulumi.input_property("perTryTimeout")
    """
    Specifies a non-zero timeout per retry attempt.  Structure is documented below.
    """
    retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("retryConditions")
    """
    Specifies one or more conditions when this retry rule applies. Valid values are:
    - 5xx: Loadbalancer will attempt a retry if the backend service responds with
    any 5xx response code, or if the backend service does not respond at all,
    example: disconnects, reset, read timeout, connection failure, and refused
    streams.
    - gateway-error: Similar to 5xx, but only applies to response codes
    502, 503 or 504.
    - connect-failure: Loadbalancer will retry on failures
    connecting to backend services, for example due to connection timeouts.
    - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
    Currently the only retriable error supported is 409.
    - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
    REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
    - cancelled: Loadbalancer will retry if the gRPC status code in the response
    header is set to cancelled
    - deadline-exceeded: Loadbalancer will retry if the
    gRPC status code in the response header is set to deadline-exceeded
    - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
    header is set to resource-exhausted
    - unavailable: Loadbalancer will retry if
    the gRPC status code in the response header is set to unavailable
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, num_retries: Optional[pulumi.Input[float]] = None, per_try_timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = None, retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[float] num_retries: Specifies the allowed number retries. This number must be > 0.
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs'] per_try_timeout: Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] retry_conditions: Specifies one or more conditions when this retry rule applies. Valid values are:
               - 5xx: Loadbalancer will attempt a retry if the backend service responds with
               any 5xx response code, or if the backend service does not respond at all,
               example: disconnects, reset, read timeout, connection failure, and refused
               streams.
               - gateway-error: Similar to 5xx, but only applies to response codes
               502, 503 or 504.
               - connect-failure: Loadbalancer will retry on failures
               connecting to backend services, for example due to connection timeouts.
               - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
               REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled: Loadbalancer will retry if the gRPC status code in the response
               header is set to cancelled
               - deadline-exceeded: Loadbalancer will retry if the
               gRPC status code in the response header is set to deadline-exceeded
               - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
               header is set to resource-exhausted
               - unavailable: Loadbalancer will retry if
               the gRPC status code in the response header is set to unavailable
        """
        __self__.num_retries = num_retries
        __self__.per_try_timeout = per_try_timeout
        __self__.retry_conditions = retry_conditions

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionUrlRewriteArgs:
    host_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("hostRewrite")
    """
    Prior to forwarding the request to the selected service, the request's host
    header is replaced with contents of hostRewrite. The value must be between 1 and
    255 characters.
    """
    path_prefix_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("pathPrefixRewrite")
    """
    Prior to forwarding the request to the selected backend service, the matching
    portion of the request's path is replaced by pathPrefixRewrite. The value must
    be between 1 and 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_rewrite: Optional[pulumi.Input[str]] = None, path_prefix_rewrite: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host_rewrite: Prior to forwarding the request to the selected service, the request's host
               header is replaced with contents of hostRewrite. The value must be between 1 and
               255 characters.
        :param pulumi.Input[str] path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching
               portion of the request's path is replaced by pathPrefixRewrite. The value must
               be between 1 and 1024 characters.
        """
        __self__.host_rewrite = host_rewrite
        __self__.path_prefix_rewrite = path_prefix_rewrite

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The default RegionBackendService resource. Before
    forwarding the request to backendService, the loadbalancer applies any relevant
    headerActions specified as part of this backendServiceWeight.
    """
    weight: pulumi.Input[float] = pulumi.input_property("weight")
    """
    Specifies the fraction of traffic sent to backendService, computed as weight /
    (sum of all weightedBackendService weights in routeAction) . The selection of a
    backend service is determined only for new traffic. Once a user's request has
    been directed to a backendService, subsequent requests will be sent to the same
    backendService as determined by the BackendService's session affinity policy.
    The value must be between 0 and 1000
    """
    header_action: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService. headerAction specified here take effect before
    headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str], weight: pulumi.Input[float], header_action: Optional[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = None) -> None:
        """
        :param pulumi.Input[str] backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        :param pulumi.Input[float] weight: Specifies the fraction of traffic sent to backendService, computed as weight /
               (sum of all weightedBackendService weights in routeAction) . The selection of a
               backend service is determined only for new traffic. Once a user's request has
               been directed to a backendService, subsequent requests will be sent to the same
               backendService as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. headerAction specified here take effect before
               headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        """
        __self__.backend_service = backend_service
        __self__.weight = weight
        __self__.header_action = header_action

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the
    backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request
    prior to forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response
    prior to sending the response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the
               backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request
               prior to forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response
               prior to sending the response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the
    header. If true, headerValue is set for the header, discarding any values that
    were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the
    header. If true, headerValue is set for the header, discarding any values that
    were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class RegionUrlMapPathMatcherPathRuleUrlRedirectArgs:
    strip_query: pulumi.Input[bool] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, strip_query: pulumi.Input[bool], host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        __self__.strip_query = strip_query
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleArgs:
    priority: pulumi.Input[float] = pulumi.input_property("priority")
    """
    For routeRules within a given pathMatcher, priority determines the order
    in which load balancer will interpret routeRules. RouteRules are evaluated
    in order of priority, from the lowest to highest number. The priority of
    a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    that matches the request is applied.
    You cannot configure two or more routeRules with the same priority.
    Priority for each rule must be set to a number between 0 and
    2147483647 inclusive.
    Priority numbers can have gaps, which enable you to add or remove rules
    in the future without affecting the rest of the rules. For example,
    1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    future without any impact on existing rules.
    """
    header_action: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService. headerAction specified here take effect before
    headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """
    match_rules: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleArgs']]]] = pulumi.input_property("matchRules")
    """
    The rules for determining a match.  Structure is documented below.
    """
    route_action: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionArgs']] = pulumi.input_property("routeAction")
    """
    In response to a matching path, the load balancer performs advanced routing
    actions like URL rewrites, header transformations, etc. prior to forwarding the
    request to the selected backend. If routeAction specifies any
    weightedBackendServices, service must not be set. Conversely if service is set,
    routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    or urlRedirect must be set.  Structure is documented below.
    """
    service: Optional[pulumi.Input[str]] = pulumi.input_property("service")
    """
    A reference to expected RegionBackendService resource the given URL should be mapped to.
    """
    url_redirect: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleUrlRedirectArgs']] = pulumi.input_property("urlRedirect")
    """
    When a path pattern is matched, the request is redirected to a URL specified
    by urlRedirect. If urlRedirect is specified, service or routeAction must not
    be set.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, priority: pulumi.Input[float], header_action: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionArgs']] = None, match_rules: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleArgs']]]] = None, route_action: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionArgs']] = None, service: Optional[pulumi.Input[str]] = None, url_redirect: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleUrlRedirectArgs']] = None) -> None:
        """
        :param pulumi.Input[float] priority: For routeRules within a given pathMatcher, priority determines the order
               in which load balancer will interpret routeRules. RouteRules are evaluated
               in order of priority, from the lowest to highest number. The priority of
               a rule decreases as its number increases (1, 2, 3, N+1). The first rule
               that matches the request is applied.
               You cannot configure two or more routeRules with the same priority.
               Priority for each rule must be set to a number between 0 and
               2147483647 inclusive.
               Priority numbers can have gaps, which enable you to add or remove rules
               in the future without affecting the rest of the rules. For example,
               1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
               you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
               future without any impact on existing rules.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. headerAction specified here take effect before
               headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleArgs']]] match_rules: The rules for determining a match.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionArgs'] route_action: In response to a matching path, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.  Structure is documented below.
        :param pulumi.Input[str] service: A reference to expected RegionBackendService resource the given URL should be mapped to.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleUrlRedirectArgs'] url_redirect: When a path pattern is matched, the request is redirected to a URL specified
               by urlRedirect. If urlRedirect is specified, service or routeAction must not
               be set.  Structure is documented below.
        """
        __self__.priority = priority
        __self__.header_action = header_action
        __self__.match_rules = match_rules
        __self__.route_action = route_action
        __self__.service = service
        __self__.url_redirect = url_redirect

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the
    backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request
    prior to forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response
    prior to sending the response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the
               backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request
               prior to forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response
               prior to sending the response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the
    header. If true, headerValue is set for the header, discarding any values that
    were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the
    header. If true, headerValue is set for the header, discarding any values that
    were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleArgs:
    full_path_match: Optional[pulumi.Input[str]] = pulumi.input_property("fullPathMatch")
    """
    For satifying the matchRule condition, the path of the request must exactly
    match the value specified in fullPathMatch after removing any query parameters
    and anchor that may be part of the original URL. FullPathMatch must be between 1
    and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    be specified.
    """
    header_matches: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs']]]] = pulumi.input_property("headerMatches")
    """
    Specifies a list of header match criteria, all of which must match corresponding
    headers in the request.  Structure is documented below.
    """
    ignore_case: Optional[pulumi.Input[bool]] = pulumi.input_property("ignoreCase")
    """
    Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    Defaults to false.
    """
    metadata_filters: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs']]]] = pulumi.input_property("metadataFilters")
    """
    Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    clients present node metadata. If a match takes place, the relevant routing
    configuration is made available to those proxies. For each metadataFilter in
    this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    filterLabels must match the corresponding label provided in the metadata. If its
    filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    with corresponding labels in the provided metadata. metadataFilters specified
    here can be overrides those specified in ForwardingRule that refers to this
    UrlMap. metadataFilters only applies to Loadbalancers that have their
    loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
    """
    prefix_match: Optional[pulumi.Input[str]] = pulumi.input_property("prefixMatch")
    """
    The value of the header must start with the contents of prefixMatch. Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.
    """
    query_parameter_matches: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs']]]] = pulumi.input_property("queryParameterMatches")
    """
    Specifies a list of query parameter match criteria, all of which must match
    corresponding query parameters in the request.  Structure is documented below.
    """
    regex_match: Optional[pulumi.Input[str]] = pulumi.input_property("regexMatch")
    """
    The queryParameterMatch matches if the value of the parameter matches the
    regular expression specified by regexMatch. For the regular expression grammar,
    please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    exactMatch and regexMatch must be set.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, full_path_match: Optional[pulumi.Input[str]] = None, header_matches: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs']]]] = None, ignore_case: Optional[pulumi.Input[bool]] = None, metadata_filters: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs']]]] = None, prefix_match: Optional[pulumi.Input[str]] = None, query_parameter_matches: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs']]]] = None, regex_match: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] full_path_match: For satifying the matchRule condition, the path of the request must exactly
               match the value specified in fullPathMatch after removing any query parameters
               and anchor that may be part of the original URL. FullPathMatch must be between 1
               and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
               be specified.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs']]] header_matches: Specifies a list of header match criteria, all of which must match corresponding
               headers in the request.  Structure is documented below.
        :param pulumi.Input[bool] ignore_case: Specifies that prefixMatch and fullPathMatch matches are case sensitive.
               Defaults to false.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs']]] metadata_filters: Opaque filter criteria used by Loadbalancer to restrict routing configuration to
               a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
               clients present node metadata. If a match takes place, the relevant routing
               configuration is made available to those proxies. For each metadataFilter in
               this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
               filterLabels must match the corresponding label provided in the metadata. If its
               filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
               with corresponding labels in the provided metadata. metadataFilters specified
               here can be overrides those specified in ForwardingRule that refers to this
               UrlMap. metadataFilters only applies to Loadbalancers that have their
               loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        :param pulumi.Input[str] prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs']]] query_parameter_matches: Specifies a list of query parameter match criteria, all of which must match
               corresponding query parameters in the request.  Structure is documented below.
        :param pulumi.Input[str] regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        __self__.full_path_match = full_path_match
        __self__.header_matches = header_matches
        __self__.ignore_case = ignore_case
        __self__.metadata_filters = metadata_filters
        __self__.prefix_match = prefix_match
        __self__.query_parameter_matches = query_parameter_matches
        __self__.regex_match = regex_match

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header.
    """
    exact_match: Optional[pulumi.Input[str]] = pulumi.input_property("exactMatch")
    """
    The queryParameterMatch matches if the value of the parameter exactly matches
    the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    must be set.
    """
    invert_match: Optional[pulumi.Input[bool]] = pulumi.input_property("invertMatch")
    """
    If set to false, the headerMatch is considered a match if the match criteria
    above are met. If set to true, the headerMatch is considered a match if the
    match criteria above are NOT met. Defaults to false.
    """
    prefix_match: Optional[pulumi.Input[str]] = pulumi.input_property("prefixMatch")
    """
    The value of the header must start with the contents of prefixMatch. Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.
    """
    present_match: Optional[pulumi.Input[bool]] = pulumi.input_property("presentMatch")
    """
    Specifies that the queryParameterMatch matches if the request contains the query
    parameter, irrespective of whether the parameter has a value or not. Only one of
    presentMatch, exactMatch and regexMatch must be set.
    """
    range_match: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs']] = pulumi.input_property("rangeMatch")
    """
    The header value must be an integer and its value must be in the range specified
    in rangeMatch. If the header does not contain an integer, number or is empty,
    the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
    not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.  Structure is documented below.
    """
    regex_match: Optional[pulumi.Input[str]] = pulumi.input_property("regexMatch")
    """
    The queryParameterMatch matches if the value of the parameter matches the
    regular expression specified by regexMatch. For the regular expression grammar,
    please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    exactMatch and regexMatch must be set.
    """
    suffix_match: Optional[pulumi.Input[str]] = pulumi.input_property("suffixMatch")
    """
    The value of the header must end with the contents of suffixMatch. Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], exact_match: Optional[pulumi.Input[str]] = None, invert_match: Optional[pulumi.Input[bool]] = None, prefix_match: Optional[pulumi.Input[str]] = None, present_match: Optional[pulumi.Input[bool]] = None, range_match: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs']] = None, regex_match: Optional[pulumi.Input[str]] = None, suffix_match: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header.
        :param pulumi.Input[str] exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param pulumi.Input[bool] invert_match: If set to false, the headerMatch is considered a match if the match criteria
               above are met. If set to true, the headerMatch is considered a match if the
               match criteria above are NOT met. Defaults to false.
        :param pulumi.Input[str] prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param pulumi.Input[bool] present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs'] range_match: The header value must be an integer and its value must be in the range specified
               in rangeMatch. If the header does not contain an integer, number or is empty,
               the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
               not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.  Structure is documented below.
        :param pulumi.Input[str] regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        :param pulumi.Input[str] suffix_match: The value of the header must end with the contents of suffixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        """
        __self__.header_name = header_name
        __self__.exact_match = exact_match
        __self__.invert_match = invert_match
        __self__.prefix_match = prefix_match
        __self__.present_match = present_match
        __self__.range_match = range_match
        __self__.regex_match = regex_match
        __self__.suffix_match = suffix_match

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs:
    range_end: pulumi.Input[float] = pulumi.input_property("rangeEnd")
    """
    The end of the range (exclusive).
    """
    range_start: pulumi.Input[float] = pulumi.input_property("rangeStart")
    """
    The start of the range (inclusive).
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, range_end: pulumi.Input[float], range_start: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] range_end: The end of the range (exclusive).
        :param pulumi.Input[float] range_start: The start of the range (inclusive).
        """
        __self__.range_end = range_end
        __self__.range_start = range_start

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs:
    filter_labels: pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs']]] = pulumi.input_property("filterLabels")
    """
    The list of label value pairs that must match labels in the provided metadata
    based on filterMatchCriteria  This list must not be empty and can have at the
    most 64 entries.  Structure is documented below.
    """
    filter_match_criteria: pulumi.Input[str] = pulumi.input_property("filterMatchCriteria")
    """
    Specifies how individual filterLabel matches within the list of filterLabels
    contribute towards the overall metadataFilter match. Supported values are:
    - MATCH_ANY: At least one of the filterLabels must have a matching label in the
    provided metadata.
    - MATCH_ALL: All filterLabels must have matching labels in
    the provided metadata.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, filter_labels: pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs']]], filter_match_criteria: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs']]] filter_labels: The list of label value pairs that must match labels in the provided metadata
               based on filterMatchCriteria  This list must not be empty and can have at the
               most 64 entries.  Structure is documented below.
        :param pulumi.Input[str] filter_match_criteria: Specifies how individual filterLabel matches within the list of filterLabels
               contribute towards the overall metadataFilter match. Supported values are:
               - MATCH_ANY: At least one of the filterLabels must have a matching label in the
               provided metadata.
               - MATCH_ALL: All filterLabels must have matching labels in
               the provided metadata.
        """
        __self__.filter_labels = filter_labels
        __self__.filter_match_criteria = filter_match_criteria

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The name of the query parameter to match. The query parameter must exist in the
    request, in the absence of which the request match fails.
    """
    value: pulumi.Input[str] = pulumi.input_property("value")
    """
    The value of the label must match the specified value. value can have a maximum
    length of 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], value: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param pulumi.Input[str] value: The value of the label must match the specified value. value can have a maximum
               length of 1024 characters.
        """
        __self__.name = name
        __self__.value = value

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The name of the query parameter to match. The query parameter must exist in the
    request, in the absence of which the request match fails.
    """
    exact_match: Optional[pulumi.Input[str]] = pulumi.input_property("exactMatch")
    """
    The queryParameterMatch matches if the value of the parameter exactly matches
    the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    must be set.
    """
    present_match: Optional[pulumi.Input[bool]] = pulumi.input_property("presentMatch")
    """
    Specifies that the queryParameterMatch matches if the request contains the query
    parameter, irrespective of whether the parameter has a value or not. Only one of
    presentMatch, exactMatch and regexMatch must be set.
    """
    regex_match: Optional[pulumi.Input[str]] = pulumi.input_property("regexMatch")
    """
    The queryParameterMatch matches if the value of the parameter matches the
    regular expression specified by regexMatch. For the regular expression grammar,
    please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    exactMatch and regexMatch must be set.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], exact_match: Optional[pulumi.Input[str]] = None, present_match: Optional[pulumi.Input[bool]] = None, regex_match: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param pulumi.Input[str] exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param pulumi.Input[bool] present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param pulumi.Input[str] regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        __self__.name = name
        __self__.exact_match = exact_match
        __self__.present_match = present_match
        __self__.regex_match = regex_match

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionArgs:
    cors_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicyArgs']] = pulumi.input_property("corsPolicy")
    """
    The specification for allowing client side cross-origin requests. Please see W3C
    Recommendation for Cross Origin Resource Sharing  Structure is documented below.
    """
    fault_injection_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs']] = pulumi.input_property("faultInjectionPolicy")
    """
    The specification for fault injection introduced into traffic to test the
    resiliency of clients to backend service failure. As part of fault injection,
    when clients send requests to a backend service, delays can be introduced by
    Loadbalancer on a percentage of requests before sending those request to the
    backend service. Similarly requests from clients can be aborted by the
    Loadbalancer for a percentage of requests. timeout and retry_policy will be
    ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
    """
    request_mirror_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs']] = pulumi.input_property("requestMirrorPolicy")
    """
    Specifies the policy on how requests intended for the route's backends are
    shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    responses from the shadow service. Prior to sending traffic to the shadow
    service, the host / authority header is suffixed with -shadow.  Structure is documented below.
    """
    retry_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyArgs']] = pulumi.input_property("retryPolicy")
    """
    Specifies the retry policy associated with this route.  Structure is documented below.
    """
    timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionTimeoutArgs']] = pulumi.input_property("timeout")
    """
    Specifies the timeout for the selected route. Timeout is computed from the time
    the request is has been fully processed (i.e. end-of-stream) up until the
    response has been completely processed. Timeout includes all retries. If not
    specified, the default value is 15 seconds.  Structure is documented below.
    """
    url_rewrite: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewriteArgs']] = pulumi.input_property("urlRewrite")
    """
    The spec to modify the URL of the request, prior to forwarding the request to
    the matched service  Structure is documented below.
    """
    weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs']]]] = pulumi.input_property("weightedBackendServices")
    """
    A list of weighted backend services to send traffic to when a route match
    occurs. The weights determine the fraction of traffic that flows to their
    corresponding backend service. If all traffic needs to go to a single backend
    service, there must be one  weightedBackendService with weight set to a non 0
    number. Once a backendService is identified and before forwarding the request to
    the backend service, advanced routing actions like Url rewrites and header
    transformations are applied depending on additional settings specified in this
    HttpRouteAction.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cors_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicyArgs']] = None, fault_injection_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs']] = None, request_mirror_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs']] = None, retry_policy: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyArgs']] = None, timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionTimeoutArgs']] = None, url_rewrite: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewriteArgs']] = None, weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs']]]] = None) -> None:
        """
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicyArgs'] cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs'] fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs'] request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyArgs'] retry_policy: Specifies the retry policy associated with this route.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionTimeoutArgs'] timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewriteArgs'] url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs']]] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.  Structure is documented below.
        """
        __self__.cors_policy = cors_policy
        __self__.fault_injection_policy = fault_injection_policy
        __self__.request_mirror_policy = request_mirror_policy
        __self__.retry_policy = retry_policy
        __self__.timeout = timeout
        __self__.url_rewrite = url_rewrite
        __self__.weighted_backend_services = weighted_backend_services

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicyArgs:
    allow_credentials: Optional[pulumi.Input[bool]] = pulumi.input_property("allowCredentials")
    """
    In response to a preflight request, setting this to true indicates that the
    actual request can include user credentials. This translates to the Access-
    Control-Allow-Credentials header. Defaults to false.
    """
    allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowHeaders")
    """
    Specifies the content for the Access-Control-Allow-Headers header.
    """
    allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowMethods")
    """
    Specifies the content for the Access-Control-Allow-Methods header.
    """
    allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOriginRegexes")
    """
    Specifies the regualar expression patterns that match allowed origins. For
    regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    An origin is allowed if it matches either allow_origins or allow_origin_regex.
    """
    allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOrigins")
    """
    Specifies the list of origins that will be allowed to do CORS requests. An
    origin is allowed if it matches either allow_origins or allow_origin_regex.
    """
    disabled: Optional[pulumi.Input[bool]] = pulumi.input_property("disabled")
    """
    If true, specifies the CORS policy is disabled.
    """
    expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("exposeHeaders")
    """
    Specifies the content for the Access-Control-Expose-Headers header.
    """
    max_age: Optional[pulumi.Input[float]] = pulumi.input_property("maxAge")
    """
    Specifies how long the results of a preflight request can be cached. This
    translates to the content for the Access-Control-Max-Age header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, allow_credentials: Optional[pulumi.Input[bool]] = None, allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, disabled: Optional[pulumi.Input[bool]] = None, expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, max_age: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] allow_credentials: In response to a preflight request, setting this to true indicates that the
               actual request can include user credentials. This translates to the Access-
               Control-Allow-Credentials header. Defaults to false.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For
               regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origins: Specifies the list of origins that will be allowed to do CORS requests. An
               origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param pulumi.Input[bool] disabled: If true, specifies the CORS policy is disabled.
        :param pulumi.Input[List[pulumi.Input[str]]] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param pulumi.Input[float] max_age: Specifies how long the results of a preflight request can be cached. This
               translates to the content for the Access-Control-Max-Age header.
        """
        __self__.allow_credentials = allow_credentials
        __self__.allow_headers = allow_headers
        __self__.allow_methods = allow_methods
        __self__.allow_origin_regexes = allow_origin_regexes
        __self__.allow_origins = allow_origins
        __self__.disabled = disabled
        __self__.expose_headers = expose_headers
        __self__.max_age = max_age

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs:
    abort: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs']] = pulumi.input_property("abort")
    """
    The specification for how client requests are aborted as part of fault
    injection.  Structure is documented below.
    """
    delay: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs']] = pulumi.input_property("delay")
    """
    The specification for how client requests are delayed as part of fault
    injection, before being sent to a backend service.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, abort: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs']] = None, delay: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs']] = None) -> None:
        """
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs'] abort: The specification for how client requests are aborted as part of fault
               injection.  Structure is documented below.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs'] delay: The specification for how client requests are delayed as part of fault
               injection, before being sent to a backend service.  Structure is documented below.
        """
        __self__.abort = abort
        __self__.delay = delay

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs:
    http_status: Optional[pulumi.Input[float]] = pulumi.input_property("httpStatus")
    """
    The HTTP status code used to abort the request. The value must be between 200
    and 599 inclusive.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) on which delay will
    be introduced as part of fault injection. The value must be between 0.0 and
    100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_status: Optional[pulumi.Input[float]] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] http_status: The HTTP status code used to abort the request. The value must be between 200
               and 599 inclusive.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        __self__.http_status = http_status
        __self__.percentage = percentage

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs:
    fixed_delay: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = pulumi.input_property("fixedDelay")
    """
    Specifies the value of the fixed delay interval.  Structure is documented below.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) on which delay will
    be introduced as part of fault injection. The value must be between 0.0 and
    100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed_delay: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] fixed_delay: Specifies the value of the fixed delay interval.  Structure is documented below.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        __self__.fixed_delay = fixed_delay
        __self__.percentage = percentage

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The default RegionBackendService resource. Before
    forwarding the request to backendService, the loadbalancer applies any relevant
    headerActions specified as part of this backendServiceWeight.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        """
        __self__.backend_service = backend_service

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyArgs:
    num_retries: pulumi.Input[float] = pulumi.input_property("numRetries")
    """
    Specifies the allowed number retries. This number must be > 0.
    """
    per_try_timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = pulumi.input_property("perTryTimeout")
    """
    Specifies a non-zero timeout per retry attempt.  Structure is documented below.
    """
    retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("retryConditions")
    """
    Specifies one or more conditions when this retry rule applies. Valid values are:
    - 5xx: Loadbalancer will attempt a retry if the backend service responds with
    any 5xx response code, or if the backend service does not respond at all,
    example: disconnects, reset, read timeout, connection failure, and refused
    streams.
    - gateway-error: Similar to 5xx, but only applies to response codes
    502, 503 or 504.
    - connect-failure: Loadbalancer will retry on failures
    connecting to backend services, for example due to connection timeouts.
    - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
    Currently the only retriable error supported is 409.
    - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
    REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
    - cancelled: Loadbalancer will retry if the gRPC status code in the response
    header is set to cancelled
    - deadline-exceeded: Loadbalancer will retry if the
    gRPC status code in the response header is set to deadline-exceeded
    - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
    header is set to resource-exhausted
    - unavailable: Loadbalancer will retry if
    the gRPC status code in the response header is set to unavailable
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, num_retries: pulumi.Input[float], per_try_timeout: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = None, retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[float] num_retries: Specifies the allowed number retries. This number must be > 0.
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs'] per_try_timeout: Specifies a non-zero timeout per retry attempt.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] retry_conditions: Specifies one or more conditions when this retry rule applies. Valid values are:
               - 5xx: Loadbalancer will attempt a retry if the backend service responds with
               any 5xx response code, or if the backend service does not respond at all,
               example: disconnects, reset, read timeout, connection failure, and refused
               streams.
               - gateway-error: Similar to 5xx, but only applies to response codes
               502, 503 or 504.
               - connect-failure: Loadbalancer will retry on failures
               connecting to backend services, for example due to connection timeouts.
               - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
               REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled: Loadbalancer will retry if the gRPC status code in the response
               header is set to cancelled
               - deadline-exceeded: Loadbalancer will retry if the
               gRPC status code in the response header is set to deadline-exceeded
               - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
               header is set to resource-exhausted
               - unavailable: Loadbalancer will retry if
               the gRPC status code in the response header is set to unavailable
        """
        __self__.num_retries = num_retries
        __self__.per_try_timeout = per_try_timeout
        __self__.retry_conditions = retry_conditions

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    inclusive.
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations
    less than one second are represented with a 0 `seconds` field and a positive
    `nanos` field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewriteArgs:
    host_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("hostRewrite")
    """
    Prior to forwarding the request to the selected service, the request's host
    header is replaced with contents of hostRewrite. The value must be between 1 and
    255 characters.
    """
    path_prefix_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("pathPrefixRewrite")
    """
    Prior to forwarding the request to the selected backend service, the matching
    portion of the request's path is replaced by pathPrefixRewrite. The value must
    be between 1 and 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_rewrite: Optional[pulumi.Input[str]] = None, path_prefix_rewrite: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host_rewrite: Prior to forwarding the request to the selected service, the request's host
               header is replaced with contents of hostRewrite. The value must be between 1 and
               255 characters.
        :param pulumi.Input[str] path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching
               portion of the request's path is replaced by pathPrefixRewrite. The value must
               be between 1 and 1024 characters.
        """
        __self__.host_rewrite = host_rewrite
        __self__.path_prefix_rewrite = path_prefix_rewrite

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The default RegionBackendService resource. Before
    forwarding the request to backendService, the loadbalancer applies any relevant
    headerActions specified as part of this backendServiceWeight.
    """
    weight: pulumi.Input[float] = pulumi.input_property("weight")
    """
    Specifies the fraction of traffic sent to backendService, computed as weight /
    (sum of all weightedBackendService weights in routeAction) . The selection of a
    backend service is determined only for new traffic. Once a user's request has
    been directed to a backendService, subsequent requests will be sent to the same
    backendService as determined by the BackendService's session affinity policy.
    The value must be between 0 and 1000
    """
    header_action: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService. headerAction specified here take effect before
    headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str], weight: pulumi.Input[float], header_action: Optional[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = None) -> None:
        """
        :param pulumi.Input[str] backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        :param pulumi.Input[float] weight: Specifies the fraction of traffic sent to backendService, computed as weight /
               (sum of all weightedBackendService weights in routeAction) . The selection of a
               backend service is determined only for new traffic. Once a user's request has
               been directed to a backendService, subsequent requests will be sent to the same
               backendService as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. headerAction specified here take effect before
               headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        """
        __self__.backend_service = backend_service
        __self__.weight = weight
        __self__.header_action = header_action

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the
    backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request
    prior to forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response
    prior to sending the response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the
               backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request
               prior to forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response
               prior to sending the response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the
    header. If true, headerValue is set for the header, discarding any values that
    were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the
    header. If true, headerValue is set for the header, discarding any values that
    were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class RegionUrlMapPathMatcherRouteRuleUrlRedirectArgs:
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """
    strip_query: Optional[pulumi.Input[bool]] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None, strip_query: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        """
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code
        __self__.strip_query = strip_query

@pulumi.input_type
class RegionUrlMapTestArgs:
    host: pulumi.Input[str] = pulumi.input_property("host")
    """
    Host portion of the URL.
    """
    path: pulumi.Input[str] = pulumi.input_property("path")
    """
    Path portion of the URL.
    """
    service: pulumi.Input[str] = pulumi.input_property("service")
    """
    A reference to expected RegionBackendService resource the given URL should be mapped to.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    Description of this test case.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: pulumi.Input[str], path: pulumi.Input[str], service: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: Host portion of the URL.
        :param pulumi.Input[str] path: Path portion of the URL.
        :param pulumi.Input[str] service: A reference to expected RegionBackendService resource the given URL should be mapped to.
        :param pulumi.Input[str] description: Description of this test case.
        """
        __self__.host = host
        __self__.path = path
        __self__.service = service
        __self__.description = description

@pulumi.input_type
class ReservationSpecificReservationArgs:
    count: pulumi.Input[float] = pulumi.input_property("count")
    """
    The number of resources that are allocated.
    """
    instance_properties: pulumi.Input['ReservationSpecificReservationInstancePropertiesArgs'] = pulumi.input_property("instanceProperties")
    """
    The instance properties for the reservation.  Structure is documented below.
    """
    in_use_count: Optional[pulumi.Input[float]] = pulumi.input_property("inUseCount")
    """
    -
    How many instances are in use.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, count: pulumi.Input[float], instance_properties: pulumi.Input['ReservationSpecificReservationInstancePropertiesArgs'], in_use_count: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] count: The number of resources that are allocated.
        :param pulumi.Input['ReservationSpecificReservationInstancePropertiesArgs'] instance_properties: The instance properties for the reservation.  Structure is documented below.
        :param pulumi.Input[float] in_use_count: -
               How many instances are in use.
        """
        __self__.count = count
        __self__.instance_properties = instance_properties
        __self__.in_use_count = in_use_count

@pulumi.input_type
class ReservationSpecificReservationInstancePropertiesArgs:
    machine_type: pulumi.Input[str] = pulumi.input_property("machineType")
    """
    The name of the machine type to reserve.
    """
    guest_accelerators: Optional[pulumi.Input[List[pulumi.Input['ReservationSpecificReservationInstancePropertiesGuestAcceleratorArgs']]]] = pulumi.input_property("guestAccelerators")
    """
    Guest accelerator type and count.  Structure is documented below.
    """
    local_ssds: Optional[pulumi.Input[List[pulumi.Input['ReservationSpecificReservationInstancePropertiesLocalSsdArgs']]]] = pulumi.input_property("localSsds")
    """
    The amount of local ssd to reserve with each instance. This
    reserves disks of type `local-ssd`.  Structure is documented below.
    """
    min_cpu_platform: Optional[pulumi.Input[str]] = pulumi.input_property("minCpuPlatform")
    """
    The minimum CPU platform for the reservation. For example,
    `"Intel Skylake"`. See
    the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
    for information on available CPU platforms.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, machine_type: pulumi.Input[str], guest_accelerators: Optional[pulumi.Input[List[pulumi.Input['ReservationSpecificReservationInstancePropertiesGuestAcceleratorArgs']]]] = None, local_ssds: Optional[pulumi.Input[List[pulumi.Input['ReservationSpecificReservationInstancePropertiesLocalSsdArgs']]]] = None, min_cpu_platform: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] machine_type: The name of the machine type to reserve.
        :param pulumi.Input[List[pulumi.Input['ReservationSpecificReservationInstancePropertiesGuestAcceleratorArgs']]] guest_accelerators: Guest accelerator type and count.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['ReservationSpecificReservationInstancePropertiesLocalSsdArgs']]] local_ssds: The amount of local ssd to reserve with each instance. This
               reserves disks of type `local-ssd`.  Structure is documented below.
        :param pulumi.Input[str] min_cpu_platform: The minimum CPU platform for the reservation. For example,
               `"Intel Skylake"`. See
               the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
               for information on available CPU platforms.
        """
        __self__.machine_type = machine_type
        __self__.guest_accelerators = guest_accelerators
        __self__.local_ssds = local_ssds
        __self__.min_cpu_platform = min_cpu_platform

@pulumi.input_type
class ReservationSpecificReservationInstancePropertiesGuestAcceleratorArgs:
    accelerator_count: pulumi.Input[float] = pulumi.input_property("acceleratorCount")
    """
    The number of the guest accelerator cards exposed to
    this instance.
    """
    accelerator_type: pulumi.Input[str] = pulumi.input_property("acceleratorType")
    """
    The full or partial URL of the accelerator type to
    attach to this instance. For example:
    `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
    If you are creating an instance template, specify only the accelerator name.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, accelerator_count: pulumi.Input[float], accelerator_type: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[float] accelerator_count: The number of the guest accelerator cards exposed to
               this instance.
        :param pulumi.Input[str] accelerator_type: The full or partial URL of the accelerator type to
               attach to this instance. For example:
               `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
               If you are creating an instance template, specify only the accelerator name.
        """
        __self__.accelerator_count = accelerator_count
        __self__.accelerator_type = accelerator_type

@pulumi.input_type
class ReservationSpecificReservationInstancePropertiesLocalSsdArgs:
    disk_size_gb: pulumi.Input[float] = pulumi.input_property("diskSizeGb")
    """
    The size of the disk in base-2 GB.
    """
    interface: Optional[pulumi.Input[str]] = pulumi.input_property("interface")
    """
    The disk interface to use for attaching this disk.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, disk_size_gb: pulumi.Input[float], interface: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] disk_size_gb: The size of the disk in base-2 GB.
        :param pulumi.Input[str] interface: The disk interface to use for attaching this disk.
        """
        __self__.disk_size_gb = disk_size_gb
        __self__.interface = interface

@pulumi.input_type
class ResourcePolicyGroupPlacementPolicyArgs:
    availability_domain_count: Optional[pulumi.Input[float]] = pulumi.input_property("availabilityDomainCount")
    """
    The number of availability domains instances will be spread across. If two instances are in different
    availability domain, they will not be put in the same low latency network
    """
    collocation: Optional[pulumi.Input[str]] = pulumi.input_property("collocation")
    """
    Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
    Specify `COLLOCATED` to enable collocation. Can only be specified with `vm_count`. If compute instances are created
    with a COLLOCATED policy, then exactly `vm_count` instances must be created at the same time with the resource policy
    attached.
    """
    vm_count: Optional[pulumi.Input[float]] = pulumi.input_property("vmCount")
    """
    Number of vms in this placement group.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, availability_domain_count: Optional[pulumi.Input[float]] = None, collocation: Optional[pulumi.Input[str]] = None, vm_count: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] availability_domain_count: The number of availability domains instances will be spread across. If two instances are in different
               availability domain, they will not be put in the same low latency network
        :param pulumi.Input[str] collocation: Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
               Specify `COLLOCATED` to enable collocation. Can only be specified with `vm_count`. If compute instances are created
               with a COLLOCATED policy, then exactly `vm_count` instances must be created at the same time with the resource policy
               attached.
        :param pulumi.Input[float] vm_count: Number of vms in this placement group.
        """
        __self__.availability_domain_count = availability_domain_count
        __self__.collocation = collocation
        __self__.vm_count = vm_count

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicyArgs:
    schedule: pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleArgs'] = pulumi.input_property("schedule")
    """
    Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.  Structure is documented below.
    """
    retention_policy: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyRetentionPolicyArgs']] = pulumi.input_property("retentionPolicy")
    """
    Retention policy applied to snapshots created by this resource policy.  Structure is documented below.
    """
    snapshot_properties: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicySnapshotPropertiesArgs']] = pulumi.input_property("snapshotProperties")
    """
    Properties with which the snapshots are created, such as labels.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, schedule: pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleArgs'], retention_policy: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyRetentionPolicyArgs']] = None, snapshot_properties: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicySnapshotPropertiesArgs']] = None) -> None:
        """
        :param pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleArgs'] schedule: Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.  Structure is documented below.
        :param pulumi.Input['ResourcePolicySnapshotSchedulePolicyRetentionPolicyArgs'] retention_policy: Retention policy applied to snapshots created by this resource policy.  Structure is documented below.
        :param pulumi.Input['ResourcePolicySnapshotSchedulePolicySnapshotPropertiesArgs'] snapshot_properties: Properties with which the snapshots are created, such as labels.  Structure is documented below.
        """
        __self__.schedule = schedule
        __self__.retention_policy = retention_policy
        __self__.snapshot_properties = snapshot_properties

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicyRetentionPolicyArgs:
    max_retention_days: pulumi.Input[float] = pulumi.input_property("maxRetentionDays")
    """
    Maximum age of the snapshot that is allowed to be kept.
    """
    on_source_disk_delete: Optional[pulumi.Input[str]] = pulumi.input_property("onSourceDiskDelete")
    """
    Specifies the behavior to apply to scheduled snapshots when
    the source disk is deleted.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, max_retention_days: pulumi.Input[float], on_source_disk_delete: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] max_retention_days: Maximum age of the snapshot that is allowed to be kept.
        :param pulumi.Input[str] on_source_disk_delete: Specifies the behavior to apply to scheduled snapshots when
               the source disk is deleted.
        """
        __self__.max_retention_days = max_retention_days
        __self__.on_source_disk_delete = on_source_disk_delete

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicyScheduleArgs:
    daily_schedule: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleArgs']] = pulumi.input_property("dailySchedule")
    """
    The policy will execute every nth day at the specified time.  Structure is documented below.
    """
    hourly_schedule: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleArgs']] = pulumi.input_property("hourlySchedule")
    """
    The policy will execute every nth hour starting at the specified time.  Structure is documented below.
    """
    weekly_schedule: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleArgs']] = pulumi.input_property("weeklySchedule")
    """
    Allows specifying a snapshot time for each day of the week.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, daily_schedule: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleArgs']] = None, hourly_schedule: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleArgs']] = None, weekly_schedule: Optional[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleArgs']] = None) -> None:
        """
        :param pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleArgs'] daily_schedule: The policy will execute every nth day at the specified time.  Structure is documented below.
        :param pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleArgs'] hourly_schedule: The policy will execute every nth hour starting at the specified time.  Structure is documented below.
        :param pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleArgs'] weekly_schedule: Allows specifying a snapshot time for each day of the week.  Structure is documented below.
        """
        __self__.daily_schedule = daily_schedule
        __self__.hourly_schedule = hourly_schedule
        __self__.weekly_schedule = weekly_schedule

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleArgs:
    days_in_cycle: pulumi.Input[float] = pulumi.input_property("daysInCycle")
    """
    The number of days between snapshots.
    """
    start_time: pulumi.Input[str] = pulumi.input_property("startTime")
    """
    Time within the window to start the operations.
    It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, days_in_cycle: pulumi.Input[float], start_time: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[float] days_in_cycle: The number of days between snapshots.
        :param pulumi.Input[str] start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        __self__.days_in_cycle = days_in_cycle
        __self__.start_time = start_time

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleArgs:
    hours_in_cycle: pulumi.Input[float] = pulumi.input_property("hoursInCycle")
    """
    The number of hours between snapshots.
    """
    start_time: pulumi.Input[str] = pulumi.input_property("startTime")
    """
    Time within the window to start the operations.
    It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, hours_in_cycle: pulumi.Input[float], start_time: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[float] hours_in_cycle: The number of hours between snapshots.
        :param pulumi.Input[str] start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        __self__.hours_in_cycle = hours_in_cycle
        __self__.start_time = start_time

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleArgs:
    day_of_weeks: pulumi.Input[List[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekArgs']]] = pulumi.input_property("dayOfWeeks")
    """
    May contain up to seven (one for each day of the week) snapshot times.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, day_of_weeks: pulumi.Input[List[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekArgs']]]) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekArgs']]] day_of_weeks: May contain up to seven (one for each day of the week) snapshot times.  Structure is documented below.
        """
        __self__.day_of_weeks = day_of_weeks

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekArgs:
    day: pulumi.Input[str] = pulumi.input_property("day")
    """
    The day of the week to create the snapshot. e.g. MONDAY
    """
    start_time: pulumi.Input[str] = pulumi.input_property("startTime")
    """
    Time within the window to start the operations.
    It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, day: pulumi.Input[str], start_time: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] day: The day of the week to create the snapshot. e.g. MONDAY
        :param pulumi.Input[str] start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        __self__.day = day
        __self__.start_time = start_time

@pulumi.input_type
class ResourcePolicySnapshotSchedulePolicySnapshotPropertiesArgs:
    guest_flush: Optional[pulumi.Input[bool]] = pulumi.input_property("guestFlush")
    """
    Whether to perform a 'guest aware' snapshot.
    """
    labels: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = pulumi.input_property("labels")
    """
    A set of key-value pairs.
    """
    storage_locations: Optional[pulumi.Input[str]] = pulumi.input_property("storageLocations")
    """
    Cloud Storage bucket location to store the auto snapshot
    (regional or multi-regional)
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, guest_flush: Optional[pulumi.Input[bool]] = None, labels: Optional[pulumi.Input[Dict[str, pulumi.Input[str]]]] = None, storage_locations: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] guest_flush: Whether to perform a 'guest aware' snapshot.
        :param pulumi.Input[Dict[str, pulumi.Input[str]]] labels: A set of key-value pairs.
        :param pulumi.Input[str] storage_locations: Cloud Storage bucket location to store the auto snapshot
               (regional or multi-regional)
        """
        __self__.guest_flush = guest_flush
        __self__.labels = labels
        __self__.storage_locations = storage_locations

@pulumi.input_type
class RouterBgpArgs:
    asn: pulumi.Input[float] = pulumi.input_property("asn")
    """
    Local BGP Autonomous System Number (ASN). Must be an RFC6996
    private ASN, either 16-bit or 32-bit. The value will be fixed for
    this router resource. All VPN tunnels that link to this router
    will have the same local ASN.
    """
    advertise_mode: Optional[pulumi.Input[str]] = pulumi.input_property("advertiseMode")
    """
    User-specified flag to indicate which mode to use for advertisement.
    """
    advertised_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("advertisedGroups")
    """
    User-specified list of prefix groups to advertise in custom mode.
    This field can only be populated if advertiseMode is CUSTOM and
    is advertised to all peers of the router. These groups will be
    advertised in addition to any specified prefixes. Leave this field
    blank to advertise no custom groups.
    This enum field has the one valid value: ALL_SUBNETS
    """
    advertised_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['RouterBgpAdvertisedIpRangeArgs']]]] = pulumi.input_property("advertisedIpRanges")
    """
    User-specified list of individual IP ranges to advertise in
    custom mode. This field can only be populated if advertiseMode
    is CUSTOM and is advertised to all peers of the router. These IP
    ranges will be advertised in addition to any specified groups.
    Leave this field blank to advertise no custom IP ranges.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, asn: pulumi.Input[float], advertise_mode: Optional[pulumi.Input[str]] = None, advertised_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, advertised_ip_ranges: Optional[pulumi.Input[List[pulumi.Input['RouterBgpAdvertisedIpRangeArgs']]]] = None) -> None:
        """
        :param pulumi.Input[float] asn: Local BGP Autonomous System Number (ASN). Must be an RFC6996
               private ASN, either 16-bit or 32-bit. The value will be fixed for
               this router resource. All VPN tunnels that link to this router
               will have the same local ASN.
        :param pulumi.Input[str] advertise_mode: User-specified flag to indicate which mode to use for advertisement.
        :param pulumi.Input[List[pulumi.Input[str]]] advertised_groups: User-specified list of prefix groups to advertise in custom mode.
               This field can only be populated if advertiseMode is CUSTOM and
               is advertised to all peers of the router. These groups will be
               advertised in addition to any specified prefixes. Leave this field
               blank to advertise no custom groups.
               This enum field has the one valid value: ALL_SUBNETS
        :param pulumi.Input[List[pulumi.Input['RouterBgpAdvertisedIpRangeArgs']]] advertised_ip_ranges: User-specified list of individual IP ranges to advertise in
               custom mode. This field can only be populated if advertiseMode
               is CUSTOM and is advertised to all peers of the router. These IP
               ranges will be advertised in addition to any specified groups.
               Leave this field blank to advertise no custom IP ranges.  Structure is documented below.
        """
        __self__.asn = asn
        __self__.advertise_mode = advertise_mode
        __self__.advertised_groups = advertised_groups
        __self__.advertised_ip_ranges = advertised_ip_ranges

@pulumi.input_type
class RouterBgpAdvertisedIpRangeArgs:
    range: pulumi.Input[str] = pulumi.input_property("range")
    """
    The IP range to advertise. The value must be a
    CIDR-formatted string.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    User-specified description for the IP range.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, range: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] range: The IP range to advertise. The value must be a
               CIDR-formatted string.
        :param pulumi.Input[str] description: User-specified description for the IP range.
        """
        __self__.range = range
        __self__.description = description

@pulumi.input_type
class RouterNatLogConfigArgs:
    enable: pulumi.Input[bool] = pulumi.input_property("enable")
    """
    Indicates whether or not to export logs.
    """
    filter: pulumi.Input[str] = pulumi.input_property("filter")
    """
    Specifies the desired filtering of logs on this NAT.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, enable: pulumi.Input[bool], filter: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[bool] enable: Indicates whether or not to export logs.
        :param pulumi.Input[str] filter: Specifies the desired filtering of logs on this NAT.
        """
        __self__.enable = enable
        __self__.filter = filter

@pulumi.input_type
class RouterNatSubnetworkArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    Self-link of subnetwork to NAT
    """
    source_ip_ranges_to_nats: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("sourceIpRangesToNats")
    """
    List of options for which source IPs in the subnetwork
    should have NAT enabled. Supported values include:
    `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
    `PRIMARY_IP_RANGE`.
    """
    secondary_ip_range_names: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("secondaryIpRangeNames")
    """
    List of the secondary ranges of the subnetwork that are allowed
    to use NAT. This can be populated only if
    `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
    sourceIpRangesToNat
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], source_ip_ranges_to_nats: pulumi.Input[List[pulumi.Input[str]]], secondary_ip_range_names: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[str] name: Self-link of subnetwork to NAT
        :param pulumi.Input[List[pulumi.Input[str]]] source_ip_ranges_to_nats: List of options for which source IPs in the subnetwork
               should have NAT enabled. Supported values include:
               `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
               `PRIMARY_IP_RANGE`.
        :param pulumi.Input[List[pulumi.Input[str]]] secondary_ip_range_names: List of the secondary ranges of the subnetwork that are allowed
               to use NAT. This can be populated only if
               `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
               sourceIpRangesToNat
        """
        __self__.name = name
        __self__.source_ip_ranges_to_nats = source_ip_ranges_to_nats
        __self__.secondary_ip_range_names = secondary_ip_range_names

@pulumi.input_type
class RouterPeerAdvertisedIpRangeArgs:
    range: pulumi.Input[str] = pulumi.input_property("range")
    """
    The IP range to advertise. The value must be a
    CIDR-formatted string.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    User-specified description for the IP range.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, range: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] range: The IP range to advertise. The value must be a
               CIDR-formatted string.
        :param pulumi.Input[str] description: User-specified description for the IP range.
        """
        __self__.range = range
        __self__.description = description

@pulumi.input_type
class SecurityPolicyRuleArgs:
    action: pulumi.Input[str] = pulumi.input_property("action")
    """
    Action to take when `match` matches the request. Valid values:
    * "allow" : allow access to target
    * "deny(status)" : deny access to target, returns the  HTTP response code specified (valid values are 403, 404 and 502)
    """
    match: pulumi.Input['SecurityPolicyRuleMatchArgs'] = pulumi.input_property("match")
    """
    A match condition that incoming traffic is evaluated against.
    If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
    """
    priority: pulumi.Input[float] = pulumi.input_property("priority")
    """
    An unique positive integer indicating the priority of evaluation for a rule.
    Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    An optional description of this rule. Max size is 64.
    """
    preview: Optional[pulumi.Input[bool]] = pulumi.input_property("preview")
    """
    When set to true, the `action` specified above is not enforced.
    Stackdriver logs for requests that trigger a preview action are annotated as such.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, action: pulumi.Input[str], match: pulumi.Input['SecurityPolicyRuleMatchArgs'], priority: pulumi.Input[float], description: Optional[pulumi.Input[str]] = None, preview: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[str] action: Action to take when `match` matches the request. Valid values:
               * "allow" : allow access to target
               * "deny(status)" : deny access to target, returns the  HTTP response code specified (valid values are 403, 404 and 502)
        :param pulumi.Input['SecurityPolicyRuleMatchArgs'] match: A match condition that incoming traffic is evaluated against.
               If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
        :param pulumi.Input[float] priority: An unique positive integer indicating the priority of evaluation for a rule.
               Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        :param pulumi.Input[str] description: An optional description of this rule. Max size is 64.
        :param pulumi.Input[bool] preview: When set to true, the `action` specified above is not enforced.
               Stackdriver logs for requests that trigger a preview action are annotated as such.
        """
        __self__.action = action
        __self__.match = match
        __self__.priority = priority
        __self__.description = description
        __self__.preview = preview

@pulumi.input_type
class SecurityPolicyRuleMatchArgs:
    config: Optional[pulumi.Input['SecurityPolicyRuleMatchConfigArgs']] = pulumi.input_property("config")
    """
    The configuration options available when specifying `versioned_expr`.
    This field must be specified if `versioned_expr` is specified and cannot be specified if `versioned_expr` is not specified.
    Structure is documented below.
    """
    expr: Optional[pulumi.Input['SecurityPolicyRuleMatchExprArgs']] = pulumi.input_property("expr")
    """
    User defined CEVAL expression. A CEVAL expression is used to specify match criteria
    such as origin.ip, source.region_code and contents in the request header.
    Structure is documented below.
    """
    versioned_expr: Optional[pulumi.Input[str]] = pulumi.input_property("versionedExpr")
    """
    Predefined rule expression. If this field is specified, `config` must also be specified.
    Available options:
    * SRC_IPS_V1: Must specify the corresponding `src_ip_ranges` field in `config`.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, config: Optional[pulumi.Input['SecurityPolicyRuleMatchConfigArgs']] = None, expr: Optional[pulumi.Input['SecurityPolicyRuleMatchExprArgs']] = None, versioned_expr: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input['SecurityPolicyRuleMatchConfigArgs'] config: The configuration options available when specifying `versioned_expr`.
               This field must be specified if `versioned_expr` is specified and cannot be specified if `versioned_expr` is not specified.
               Structure is documented below.
        :param pulumi.Input['SecurityPolicyRuleMatchExprArgs'] expr: User defined CEVAL expression. A CEVAL expression is used to specify match criteria
               such as origin.ip, source.region_code and contents in the request header.
               Structure is documented below.
        :param pulumi.Input[str] versioned_expr: Predefined rule expression. If this field is specified, `config` must also be specified.
               Available options:
               * SRC_IPS_V1: Must specify the corresponding `src_ip_ranges` field in `config`.
        """
        __self__.config = config
        __self__.expr = expr
        __self__.versioned_expr = versioned_expr

@pulumi.input_type
class SecurityPolicyRuleMatchConfigArgs:
    src_ip_ranges: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("srcIpRanges")
    """
    Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
    to match against inbound traffic. There is a limit of 5 IP ranges per rule. A value of '\*' matches all IPs
    (can be used to override the default behavior).
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, src_ip_ranges: pulumi.Input[List[pulumi.Input[str]]]) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] src_ip_ranges: Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
               to match against inbound traffic. There is a limit of 5 IP ranges per rule. A value of '\*' matches all IPs
               (can be used to override the default behavior).
        """
        __self__.src_ip_ranges = src_ip_ranges

@pulumi.input_type
class SecurityPolicyRuleMatchExprArgs:
    expression: pulumi.Input[str] = pulumi.input_property("expression")
    """
    Textual representation of an expression in Common Expression Language syntax.
    The application context of the containing message determines which well-known feature set of CEL is supported.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, expression: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
               The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        __self__.expression = expression

@pulumi.input_type
class SecurityScanConfigAuthenticationArgs:
    custom_account: Optional[pulumi.Input['SecurityScanConfigAuthenticationCustomAccountArgs']] = pulumi.input_property("customAccount")
    """
    Describes authentication configuration that uses a custom account.  Structure is documented below.
    """
    google_account: Optional[pulumi.Input['SecurityScanConfigAuthenticationGoogleAccountArgs']] = pulumi.input_property("googleAccount")
    """
    Describes authentication configuration that uses a Google account.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, custom_account: Optional[pulumi.Input['SecurityScanConfigAuthenticationCustomAccountArgs']] = None, google_account: Optional[pulumi.Input['SecurityScanConfigAuthenticationGoogleAccountArgs']] = None) -> None:
        """
        :param pulumi.Input['SecurityScanConfigAuthenticationCustomAccountArgs'] custom_account: Describes authentication configuration that uses a custom account.  Structure is documented below.
        :param pulumi.Input['SecurityScanConfigAuthenticationGoogleAccountArgs'] google_account: Describes authentication configuration that uses a Google account.  Structure is documented below.
        """
        __self__.custom_account = custom_account
        __self__.google_account = google_account

@pulumi.input_type
class SecurityScanConfigAuthenticationCustomAccountArgs:
    login_url: pulumi.Input[str] = pulumi.input_property("loginUrl")
    """
    The login form URL of the website.
    """
    password: pulumi.Input[str] = pulumi.input_property("password")
    """
    The password of the custom account. The credential is stored encrypted
    in GCP.  **Note**: This property is sensitive and will not be displayed in the plan.
    """
    username: pulumi.Input[str] = pulumi.input_property("username")
    """
    The user name of the custom account.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, login_url: pulumi.Input[str], password: pulumi.Input[str], username: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] login_url: The login form URL of the website.
        :param pulumi.Input[str] password: The password of the custom account. The credential is stored encrypted
               in GCP.  **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: The user name of the custom account.
        """
        __self__.login_url = login_url
        __self__.password = password
        __self__.username = username

@pulumi.input_type
class SecurityScanConfigAuthenticationGoogleAccountArgs:
    password: pulumi.Input[str] = pulumi.input_property("password")
    """
    The password of the custom account. The credential is stored encrypted
    in GCP.  **Note**: This property is sensitive and will not be displayed in the plan.
    """
    username: pulumi.Input[str] = pulumi.input_property("username")
    """
    The user name of the custom account.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, password: pulumi.Input[str], username: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] password: The password of the custom account. The credential is stored encrypted
               in GCP.  **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: The user name of the custom account.
        """
        __self__.password = password
        __self__.username = username

@pulumi.input_type
class SecurityScanConfigScheduleArgs:
    interval_duration_days: pulumi.Input[float] = pulumi.input_property("intervalDurationDays")
    """
    The duration of time between executions in days
    """
    schedule_time: Optional[pulumi.Input[str]] = pulumi.input_property("scheduleTime")
    """
    A timestamp indicates when the next run will be scheduled. The value is refreshed
    by the server after each run. If unspecified, it will default to current server time,
    which means the scan will be scheduled to start immediately.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, interval_duration_days: pulumi.Input[float], schedule_time: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] interval_duration_days: The duration of time between executions in days
        :param pulumi.Input[str] schedule_time: A timestamp indicates when the next run will be scheduled. The value is refreshed
               by the server after each run. If unspecified, it will default to current server time,
               which means the scan will be scheduled to start immediately.
        """
        __self__.interval_duration_days = interval_duration_days
        __self__.schedule_time = schedule_time

@pulumi.input_type
class SnapshotSnapshotEncryptionKeyArgs:
    raw_key: pulumi.Input[str] = pulumi.input_property("rawKey")
    """
    Specifies a 256-bit customer-supplied encryption key, encoded in
    RFC 4648 base64 to either encrypt or decrypt this resource.  **Note**: This property is sensitive and will not be displayed in the plan.
    """
    sha256: Optional[pulumi.Input[str]] = pulumi.input_property("sha256")
    """
    -
    The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
    encryption key that protects this resource.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, raw_key: pulumi.Input[str], sha256: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.  **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        __self__.raw_key = raw_key
        __self__.sha256 = sha256

@pulumi.input_type
class SnapshotSourceDiskEncryptionKeyArgs:
    raw_key: Optional[pulumi.Input[str]] = pulumi.input_property("rawKey")
    """
    Specifies a 256-bit customer-supplied encryption key, encoded in
    RFC 4648 base64 to either encrypt or decrypt this resource.  **Note**: This property is sensitive and will not be displayed in the plan.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, raw_key: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.  **Note**: This property is sensitive and will not be displayed in the plan.
        """
        __self__.raw_key = raw_key

@pulumi.input_type
class SubnetworkIAMBindingConditionArgs:
    expression: pulumi.Input[str] = pulumi.input_property("expression")
    """
    Textual representation of an expression in Common Expression Language syntax.
    """
    title: pulumi.Input[str] = pulumi.input_property("title")
    """
    A title for the expression, i.e. a short string describing its purpose.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, expression: pulumi.Input[str], title: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        __self__.expression = expression
        __self__.title = title
        __self__.description = description

@pulumi.input_type
class SubnetworkIAMMemberConditionArgs:
    expression: pulumi.Input[str] = pulumi.input_property("expression")
    """
    Textual representation of an expression in Common Expression Language syntax.
    """
    title: pulumi.Input[str] = pulumi.input_property("title")
    """
    A title for the expression, i.e. a short string describing its purpose.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, expression: pulumi.Input[str], title: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        __self__.expression = expression
        __self__.title = title
        __self__.description = description

@pulumi.input_type
class SubnetworkLogConfigArgs:
    aggregation_interval: Optional[pulumi.Input[str]] = pulumi.input_property("aggregationInterval")
    """
    Can only be specified if VPC flow logging for this subnetwork is enabled.
    Toggles the aggregation interval for collecting flow logs. Increasing the
    interval time will reduce the amount of generated flow logs for long
    lasting connections. Default is an interval of 5 seconds per connection.
    Possible values are INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN,
    INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN
    """
    flow_sampling: Optional[pulumi.Input[float]] = pulumi.input_property("flowSampling")
    """
    Can only be specified if VPC flow logging for this subnetwork is enabled.
    The value of the field must be in [0, 1]. Set the sampling rate of VPC
    flow logs within the subnetwork where 1.0 means all collected logs are
    reported and 0.0 means no logs are reported. Default is 0.5 which means
    half of all collected logs are reported.
    """
    metadata: Optional[pulumi.Input[str]] = pulumi.input_property("metadata")
    """
    Can only be specified if VPC flow logging for this subnetwork is enabled.
    Configures whether metadata fields should be added to the reported VPC
    flow logs.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, aggregation_interval: Optional[pulumi.Input[str]] = None, flow_sampling: Optional[pulumi.Input[float]] = None, metadata: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] aggregation_interval: Can only be specified if VPC flow logging for this subnetwork is enabled.
               Toggles the aggregation interval for collecting flow logs. Increasing the
               interval time will reduce the amount of generated flow logs for long
               lasting connections. Default is an interval of 5 seconds per connection.
               Possible values are INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN,
               INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN
        :param pulumi.Input[float] flow_sampling: Can only be specified if VPC flow logging for this subnetwork is enabled.
               The value of the field must be in [0, 1]. Set the sampling rate of VPC
               flow logs within the subnetwork where 1.0 means all collected logs are
               reported and 0.0 means no logs are reported. Default is 0.5 which means
               half of all collected logs are reported.
        :param pulumi.Input[str] metadata: Can only be specified if VPC flow logging for this subnetwork is enabled.
               Configures whether metadata fields should be added to the reported VPC
               flow logs.
        """
        __self__.aggregation_interval = aggregation_interval
        __self__.flow_sampling = flow_sampling
        __self__.metadata = metadata

@pulumi.input_type
class SubnetworkSecondaryIpRangeArgs:
    ip_cidr_range: pulumi.Input[str] = pulumi.input_property("ipCidrRange")
    """
    The range of IP addresses belonging to this subnetwork secondary
    range. Provide this property when you create the subnetwork.
    Ranges must be unique and non-overlapping with all primary and
    secondary IP ranges within a network. Only IPv4 is supported.
    """
    range_name: pulumi.Input[str] = pulumi.input_property("rangeName")
    """
    The name associated with this subnetwork secondary range, used
    when adding an alias IP range to a VM instance. The name must
    be 1-63 characters long, and comply with RFC1035. The name
    must be unique within the subnetwork.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, ip_cidr_range: pulumi.Input[str], range_name: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] ip_cidr_range: The range of IP addresses belonging to this subnetwork secondary
               range. Provide this property when you create the subnetwork.
               Ranges must be unique and non-overlapping with all primary and
               secondary IP ranges within a network. Only IPv4 is supported.
        :param pulumi.Input[str] range_name: The name associated with this subnetwork secondary range, used
               when adding an alias IP range to a VM instance. The name must
               be 1-63 characters long, and comply with RFC1035. The name
               must be unique within the subnetwork.
        """
        __self__.ip_cidr_range = ip_cidr_range
        __self__.range_name = range_name

@pulumi.input_type
class URLMapDefaultRouteActionArgs:
    cors_policy: Optional[pulumi.Input['URLMapDefaultRouteActionCorsPolicyArgs']] = pulumi.input_property("corsPolicy")
    """
    The specification for allowing client side cross-origin requests. Please see
    [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
    """
    fault_injection_policy: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyArgs']] = pulumi.input_property("faultInjectionPolicy")
    """
    The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
    percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
    by the Loadbalancer for a percentage of requests.
    timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
    """
    request_mirror_policy: Optional[pulumi.Input['URLMapDefaultRouteActionRequestMirrorPolicyArgs']] = pulumi.input_property("requestMirrorPolicy")
    """
    Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
    the host / authority header is suffixed with -shadow.  Structure is documented below.
    """
    retry_policy: Optional[pulumi.Input['URLMapDefaultRouteActionRetryPolicyArgs']] = pulumi.input_property("retryPolicy")
    """
    Specifies the retry policy associated with this route.  Structure is documented below.
    """
    timeout: Optional[pulumi.Input['URLMapDefaultRouteActionTimeoutArgs']] = pulumi.input_property("timeout")
    """
    Specifies the timeout for the selected route. Timeout is computed from the time the request has been
    fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
    If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    url_rewrite: Optional[pulumi.Input['URLMapDefaultRouteActionUrlRewriteArgs']] = pulumi.input_property("urlRewrite")
    """
    The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
    """
    weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceArgs']]]] = pulumi.input_property("weightedBackendServices")
    """
    A list of weighted backend services to send traffic to when a route match occurs.
    The weights determine the fraction of traffic that flows to their corresponding backend service.
    If all traffic needs to go to a single backend service, there must be one weightedBackendService
    with weight set to a non 0 number.
    Once a backendService is identified and before forwarding the request to the backend service,
    advanced routing actions like Url rewrites and header transformations are applied depending on
    additional settings specified in this HttpRouteAction.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cors_policy: Optional[pulumi.Input['URLMapDefaultRouteActionCorsPolicyArgs']] = None, fault_injection_policy: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyArgs']] = None, request_mirror_policy: Optional[pulumi.Input['URLMapDefaultRouteActionRequestMirrorPolicyArgs']] = None, retry_policy: Optional[pulumi.Input['URLMapDefaultRouteActionRetryPolicyArgs']] = None, timeout: Optional[pulumi.Input['URLMapDefaultRouteActionTimeoutArgs']] = None, url_rewrite: Optional[pulumi.Input['URLMapDefaultRouteActionUrlRewriteArgs']] = None, weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceArgs']]]] = None) -> None:
        """
        :param pulumi.Input['URLMapDefaultRouteActionCorsPolicyArgs'] cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
        :param pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyArgs'] fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
        :param pulumi.Input['URLMapDefaultRouteActionRequestMirrorPolicyArgs'] request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.  Structure is documented below.
        :param pulumi.Input['URLMapDefaultRouteActionRetryPolicyArgs'] retry_policy: Specifies the retry policy associated with this route.  Structure is documented below.
        :param pulumi.Input['URLMapDefaultRouteActionTimeoutArgs'] timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input['URLMapDefaultRouteActionUrlRewriteArgs'] url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceArgs']]] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.  Structure is documented below.
        """
        __self__.cors_policy = cors_policy
        __self__.fault_injection_policy = fault_injection_policy
        __self__.request_mirror_policy = request_mirror_policy
        __self__.retry_policy = retry_policy
        __self__.timeout = timeout
        __self__.url_rewrite = url_rewrite
        __self__.weighted_backend_services = weighted_backend_services

@pulumi.input_type
class URLMapDefaultRouteActionCorsPolicyArgs:
    allow_credentials: Optional[pulumi.Input[bool]] = pulumi.input_property("allowCredentials")
    """
    In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
    This translates to the Access-Control-Allow-Credentials header.
    """
    allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowHeaders")
    """
    Specifies the content for the Access-Control-Allow-Headers header.
    """
    allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowMethods")
    """
    Specifies the content for the Access-Control-Allow-Methods header.
    """
    allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOriginRegexes")
    """
    Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
    please see en.cppreference.com/w/cpp/regex/ecmascript
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOrigins")
    """
    Specifies the list of origins that will be allowed to do CORS requests.
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    disabled: Optional[pulumi.Input[bool]] = pulumi.input_property("disabled")
    """
    If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
    """
    expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("exposeHeaders")
    """
    Specifies the content for the Access-Control-Expose-Headers header.
    """
    max_age: Optional[pulumi.Input[float]] = pulumi.input_property("maxAge")
    """
    Specifies how long results of a preflight request can be cached in seconds.
    This translates to the Access-Control-Max-Age header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, allow_credentials: Optional[pulumi.Input[bool]] = None, allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, disabled: Optional[pulumi.Input[bool]] = None, expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, max_age: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[bool] disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param pulumi.Input[List[pulumi.Input[str]]] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param pulumi.Input[float] max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        __self__.allow_credentials = allow_credentials
        __self__.allow_headers = allow_headers
        __self__.allow_methods = allow_methods
        __self__.allow_origin_regexes = allow_origin_regexes
        __self__.allow_origins = allow_origins
        __self__.disabled = disabled
        __self__.expose_headers = expose_headers
        __self__.max_age = max_age

@pulumi.input_type
class URLMapDefaultRouteActionFaultInjectionPolicyArgs:
    abort: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyAbortArgs']] = pulumi.input_property("abort")
    """
    The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
    """
    delay: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyDelayArgs']] = pulumi.input_property("delay")
    """
    The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, abort: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyAbortArgs']] = None, delay: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyDelayArgs']] = None) -> None:
        """
        :param pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyAbortArgs'] abort: The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
        :param pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyDelayArgs'] delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
        """
        __self__.abort = abort
        __self__.delay = delay

@pulumi.input_type
class URLMapDefaultRouteActionFaultInjectionPolicyAbortArgs:
    http_status: Optional[pulumi.Input[float]] = pulumi.input_property("httpStatus")
    """
    The HTTP status code used to abort the request.
    The value must be between 200 and 599 inclusive.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_status: Optional[pulumi.Input[float]] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.http_status = http_status
        __self__.percentage = percentage

@pulumi.input_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelayArgs:
    fixed_delay: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = pulumi.input_property("fixedDelay")
    """
    Specifies the value of the fixed delay interval.  Structure is documented below.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed_delay: Optional[pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] fixed_delay: Specifies the value of the fixed delay interval.  Structure is documented below.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.fixed_delay = fixed_delay
        __self__.percentage = percentage

@pulumi.input_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs:
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """
    seconds: Optional[pulumi.Input[str]] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nanos: Optional[pulumi.Input[float]] = None, seconds: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        __self__.nanos = nanos
        __self__.seconds = seconds

@pulumi.input_type
class URLMapDefaultRouteActionRequestMirrorPolicyArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        __self__.backend_service = backend_service

@pulumi.input_type
class URLMapDefaultRouteActionRetryPolicyArgs:
    num_retries: Optional[pulumi.Input[float]] = pulumi.input_property("numRetries")
    """
    Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
    """
    per_try_timeout: Optional[pulumi.Input['URLMapDefaultRouteActionRetryPolicyPerTryTimeoutArgs']] = pulumi.input_property("perTryTimeout")
    """
    Specifies a non-zero timeout per retry attempt.
    If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
    will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("retryConditions")
    """
    Specfies one or more conditions when this retry rule applies. Valid values are:
    5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
    or if the backend service does not respond at all, example: disconnects, reset, read timeout,
    connection failure, and refused streams.
    gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
    connect-failure: Loadbalancer will retry on failures connecting to backend services,
    for example due to connection timeouts.
    retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
    Currently the only retriable error supported is 409.
    refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
    This reset type indicates that it is safe to retry.
    cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
    deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
    resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
    unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, num_retries: Optional[pulumi.Input[float]] = None, per_try_timeout: Optional[pulumi.Input['URLMapDefaultRouteActionRetryPolicyPerTryTimeoutArgs']] = None, retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[float] num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param pulumi.Input['URLMapDefaultRouteActionRetryPolicyPerTryTimeoutArgs'] per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               connection failure, and refused streams.
               gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        __self__.num_retries = num_retries
        __self__.per_try_timeout = per_try_timeout
        __self__.retry_conditions = retry_conditions

@pulumi.input_type
class URLMapDefaultRouteActionRetryPolicyPerTryTimeoutArgs:
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """
    seconds: Optional[pulumi.Input[str]] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nanos: Optional[pulumi.Input[float]] = None, seconds: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        __self__.nanos = nanos
        __self__.seconds = seconds

@pulumi.input_type
class URLMapDefaultRouteActionTimeoutArgs:
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """
    seconds: Optional[pulumi.Input[str]] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nanos: Optional[pulumi.Input[float]] = None, seconds: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        __self__.nanos = nanos
        __self__.seconds = seconds

@pulumi.input_type
class URLMapDefaultRouteActionUrlRewriteArgs:
    host_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("hostRewrite")
    """
    Prior to forwarding the request to the selected service, the request's host header is replaced
    with contents of hostRewrite.
    The value must be between 1 and 255 characters.
    """
    path_prefix_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("pathPrefixRewrite")
    """
    Prior to forwarding the request to the selected backend service, the matching portion of the
    request's path is replaced by pathPrefixRewrite.
    The value must be between 1 and 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_rewrite: Optional[pulumi.Input[str]] = None, path_prefix_rewrite: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param pulumi.Input[str] path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        __self__.host_rewrite = host_rewrite
        __self__.path_prefix_rewrite = path_prefix_rewrite

@pulumi.input_type
class URLMapDefaultRouteActionWeightedBackendServiceArgs:
    backend_service: Optional[pulumi.Input[str]] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """
    header_action: Optional[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService.
    headerAction specified here take effect before headerAction in the enclosing
    HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """
    weight: Optional[pulumi.Input[float]] = pulumi.input_property("weight")
    """
    Specifies the fraction of traffic sent to backendService, computed as
    weight / (sum of all weightedBackendService weights in routeAction) .
    The selection of a backend service is determined only for new traffic. Once a user's request
    has been directed to a backendService, subsequent requests will be sent to the same backendService
    as determined by the BackendService's session affinity policy.
    The value must be between 0 and 1000
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: Optional[pulumi.Input[str]] = None, header_action: Optional[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionArgs']] = None, weight: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        :param pulumi.Input[float] weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        """
        __self__.backend_service = backend_service
        __self__.header_action = header_action
        __self__.weight = weight

@pulumi.input_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request prior to
    forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response prior to sending the
    response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs:
    header_name: Optional[pulumi.Input[str]] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: Optional[pulumi.Input[str]] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: Optional[pulumi.Input[bool]] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: Optional[pulumi.Input[str]] = None, header_value: Optional[pulumi.Input[str]] = None, replace: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs:
    header_name: Optional[pulumi.Input[str]] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: Optional[pulumi.Input[str]] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: Optional[pulumi.Input[bool]] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: Optional[pulumi.Input[str]] = None, header_value: Optional[pulumi.Input[str]] = None, replace: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapDefaultUrlRedirectArgs:
    strip_query: pulumi.Input[bool] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained. The default is set to false.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, strip_query: pulumi.Input[bool], host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        __self__.strip_query = strip_query
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code

@pulumi.input_type
class URLMapHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request prior to
    forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response prior to sending the
    response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['URLMapHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class URLMapHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapHostRuleArgs:
    hosts: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("hosts")
    """
    The list of host patterns to match. They must be valid hostnames, except * will
    match any string of ([a-z0-9-.]*). In that case, * must be the first character
    and must be followed in the pattern by either - or ..
    """
    path_matcher: pulumi.Input[str] = pulumi.input_property("pathMatcher")
    """
    The name of the PathMatcher to use to match the path portion of the URL if the
    hostRule matches the URL's host portion.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    Description of this test case.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, hosts: pulumi.Input[List[pulumi.Input[str]]], path_matcher: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] hosts: The list of host patterns to match. They must be valid hostnames, except * will
               match any string of ([a-z0-9-.]*). In that case, * must be the first character
               and must be followed in the pattern by either - or ..
        :param pulumi.Input[str] path_matcher: The name of the PathMatcher to use to match the path portion of the URL if the
               hostRule matches the URL's host portion.
        :param pulumi.Input[str] description: Description of this test case.
        """
        __self__.hosts = hosts
        __self__.path_matcher = path_matcher
        __self__.description = description

@pulumi.input_type
class URLMapPathMatcherArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The name of the query parameter to match. The query parameter must exist in the
    request, in the absence of which the request match fails.
    """
    default_route_action: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionArgs']] = pulumi.input_property("defaultRouteAction")
    """
    defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
    advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
    to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
    Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
    Only one of defaultRouteAction or defaultUrlRedirect must be set.  Structure is documented below.
    """
    default_service: Optional[pulumi.Input[str]] = pulumi.input_property("defaultService")
    """
    The backend service or backend bucket to use when none of the given paths match.
    """
    default_url_redirect: Optional[pulumi.Input['URLMapPathMatcherDefaultUrlRedirectArgs']] = pulumi.input_property("defaultUrlRedirect")
    """
    When none of the specified hostRules match, the request is redirected to a URL specified
    by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    defaultRouteAction must not be set.  Structure is documented below.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    Description of this test case.
    """
    header_action: Optional[pulumi.Input['URLMapPathMatcherHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService.
    headerAction specified here take effect before headerAction in the enclosing
    HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """
    path_rules: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleArgs']]]] = pulumi.input_property("pathRules")
    """
    The list of path rules. Use this list instead of routeRules when routing based
    on simple path matching is all that's required. The order by which path rules
    are specified does not matter. Matches are always done on the longest-path-first
    basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    irrespective of the order in which those paths appear in this list. Within a
    given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
    """
    route_rules: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleArgs']]]] = pulumi.input_property("routeRules")
    """
    The list of ordered HTTP route rules. Use this list instead of pathRules when
    advanced route matching and routing actions are desired. The order of specifying
    routeRules matters: the first rule that matches will cause its specified routing
    action to take effect. Within a given pathMatcher, only one of pathRules or
    routeRules must be set. routeRules are not supported in UrlMaps intended for
    External load balancers.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], default_route_action: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionArgs']] = None, default_service: Optional[pulumi.Input[str]] = None, default_url_redirect: Optional[pulumi.Input['URLMapPathMatcherDefaultUrlRedirectArgs']] = None, description: Optional[pulumi.Input[str]] = None, header_action: Optional[pulumi.Input['URLMapPathMatcherHeaderActionArgs']] = None, path_rules: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleArgs']]]] = None, route_rules: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleArgs']]]] = None) -> None:
        """
        :param pulumi.Input[str] name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionArgs'] default_route_action: defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
               advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
               to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
               Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
               Only one of defaultRouteAction or defaultUrlRedirect must be set.  Structure is documented below.
        :param pulumi.Input[str] default_service: The backend service or backend bucket to use when none of the given paths match.
        :param pulumi.Input['URLMapPathMatcherDefaultUrlRedirectArgs'] default_url_redirect: When none of the specified hostRules match, the request is redirected to a URL specified
               by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
               defaultRouteAction must not be set.  Structure is documented below.
        :param pulumi.Input[str] description: Description of this test case.
        :param pulumi.Input['URLMapPathMatcherHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleArgs']]] path_rules: The list of path rules. Use this list instead of routeRules when routing based
               on simple path matching is all that's required. The order by which path rules
               are specified does not matter. Matches are always done on the longest-path-first
               basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
               irrespective of the order in which those paths appear in this list. Within a
               given pathMatcher, only one of pathRules or routeRules must be set.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleArgs']]] route_rules: The list of ordered HTTP route rules. Use this list instead of pathRules when
               advanced route matching and routing actions are desired. The order of specifying
               routeRules matters: the first rule that matches will cause its specified routing
               action to take effect. Within a given pathMatcher, only one of pathRules or
               routeRules must be set. routeRules are not supported in UrlMaps intended for
               External load balancers.  Structure is documented below.
        """
        __self__.name = name
        __self__.default_route_action = default_route_action
        __self__.default_service = default_service
        __self__.default_url_redirect = default_url_redirect
        __self__.description = description
        __self__.header_action = header_action
        __self__.path_rules = path_rules
        __self__.route_rules = route_rules

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionArgs:
    cors_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionCorsPolicyArgs']] = pulumi.input_property("corsPolicy")
    """
    The specification for allowing client side cross-origin requests. Please see
    [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
    """
    fault_injection_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyArgs']] = pulumi.input_property("faultInjectionPolicy")
    """
    The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
    percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
    by the Loadbalancer for a percentage of requests.
    timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
    """
    request_mirror_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs']] = pulumi.input_property("requestMirrorPolicy")
    """
    Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
    the host / authority header is suffixed with -shadow.  Structure is documented below.
    """
    retry_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionRetryPolicyArgs']] = pulumi.input_property("retryPolicy")
    """
    Specifies the retry policy associated with this route.  Structure is documented below.
    """
    timeout: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionTimeoutArgs']] = pulumi.input_property("timeout")
    """
    Specifies the timeout for the selected route. Timeout is computed from the time the request has been
    fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
    If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    url_rewrite: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionUrlRewriteArgs']] = pulumi.input_property("urlRewrite")
    """
    The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
    """
    weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceArgs']]]] = pulumi.input_property("weightedBackendServices")
    """
    A list of weighted backend services to send traffic to when a route match occurs.
    The weights determine the fraction of traffic that flows to their corresponding backend service.
    If all traffic needs to go to a single backend service, there must be one weightedBackendService
    with weight set to a non 0 number.
    Once a backendService is identified and before forwarding the request to the backend service,
    advanced routing actions like Url rewrites and header transformations are applied depending on
    additional settings specified in this HttpRouteAction.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cors_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionCorsPolicyArgs']] = None, fault_injection_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyArgs']] = None, request_mirror_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs']] = None, retry_policy: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionRetryPolicyArgs']] = None, timeout: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionTimeoutArgs']] = None, url_rewrite: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionUrlRewriteArgs']] = None, weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceArgs']]]] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionCorsPolicyArgs'] cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyArgs'] fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs'] request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionRetryPolicyArgs'] retry_policy: Specifies the retry policy associated with this route.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionTimeoutArgs'] timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionUrlRewriteArgs'] url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceArgs']]] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.  Structure is documented below.
        """
        __self__.cors_policy = cors_policy
        __self__.fault_injection_policy = fault_injection_policy
        __self__.request_mirror_policy = request_mirror_policy
        __self__.retry_policy = retry_policy
        __self__.timeout = timeout
        __self__.url_rewrite = url_rewrite
        __self__.weighted_backend_services = weighted_backend_services

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionCorsPolicyArgs:
    allow_credentials: Optional[pulumi.Input[bool]] = pulumi.input_property("allowCredentials")
    """
    In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
    This translates to the Access-Control-Allow-Credentials header.
    """
    allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowHeaders")
    """
    Specifies the content for the Access-Control-Allow-Headers header.
    """
    allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowMethods")
    """
    Specifies the content for the Access-Control-Allow-Methods header.
    """
    allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOriginRegexes")
    """
    Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
    please see en.cppreference.com/w/cpp/regex/ecmascript
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOrigins")
    """
    Specifies the list of origins that will be allowed to do CORS requests.
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    disabled: Optional[pulumi.Input[bool]] = pulumi.input_property("disabled")
    """
    If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
    """
    expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("exposeHeaders")
    """
    Specifies the content for the Access-Control-Expose-Headers header.
    """
    max_age: Optional[pulumi.Input[float]] = pulumi.input_property("maxAge")
    """
    Specifies how long results of a preflight request can be cached in seconds.
    This translates to the Access-Control-Max-Age header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, allow_credentials: Optional[pulumi.Input[bool]] = None, allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, disabled: Optional[pulumi.Input[bool]] = None, expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, max_age: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[bool] disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param pulumi.Input[List[pulumi.Input[str]]] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param pulumi.Input[float] max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        __self__.allow_credentials = allow_credentials
        __self__.allow_headers = allow_headers
        __self__.allow_methods = allow_methods
        __self__.allow_origin_regexes = allow_origin_regexes
        __self__.allow_origins = allow_origins
        __self__.disabled = disabled
        __self__.expose_headers = expose_headers
        __self__.max_age = max_age

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyArgs:
    abort: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbortArgs']] = pulumi.input_property("abort")
    """
    The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
    """
    delay: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayArgs']] = pulumi.input_property("delay")
    """
    The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, abort: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbortArgs']] = None, delay: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayArgs']] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbortArgs'] abort: The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayArgs'] delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
        """
        __self__.abort = abort
        __self__.delay = delay

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbortArgs:
    http_status: Optional[pulumi.Input[float]] = pulumi.input_property("httpStatus")
    """
    The HTTP status code used to abort the request.
    The value must be between 200 and 599 inclusive.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_status: Optional[pulumi.Input[float]] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.http_status = http_status
        __self__.percentage = percentage

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayArgs:
    fixed_delay: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = pulumi.input_property("fixedDelay")
    """
    Specifies the value of the fixed delay interval.  Structure is documented below.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed_delay: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] fixed_delay: Specifies the value of the fixed delay interval.  Structure is documented below.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.fixed_delay = fixed_delay
        __self__.percentage = percentage

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs:
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """
    seconds: Optional[pulumi.Input[str]] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nanos: Optional[pulumi.Input[float]] = None, seconds: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        __self__.nanos = nanos
        __self__.seconds = seconds

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        __self__.backend_service = backend_service

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionRetryPolicyArgs:
    num_retries: Optional[pulumi.Input[float]] = pulumi.input_property("numRetries")
    """
    Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
    """
    per_try_timeout: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutArgs']] = pulumi.input_property("perTryTimeout")
    """
    Specifies a non-zero timeout per retry attempt.
    If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
    will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("retryConditions")
    """
    Specfies one or more conditions when this retry rule applies. Valid values are:
    5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
    or if the backend service does not respond at all, example: disconnects, reset, read timeout,
    connection failure, and refused streams.
    gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
    connect-failure: Loadbalancer will retry on failures connecting to backend services,
    for example due to connection timeouts.
    retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
    Currently the only retriable error supported is 409.
    refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
    This reset type indicates that it is safe to retry.
    cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
    deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
    resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
    unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, num_retries: Optional[pulumi.Input[float]] = None, per_try_timeout: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutArgs']] = None, retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[float] num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutArgs'] per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               connection failure, and refused streams.
               gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        __self__.num_retries = num_retries
        __self__.per_try_timeout = per_try_timeout
        __self__.retry_conditions = retry_conditions

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutArgs:
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """
    seconds: Optional[pulumi.Input[str]] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nanos: Optional[pulumi.Input[float]] = None, seconds: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        __self__.nanos = nanos
        __self__.seconds = seconds

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionTimeoutArgs:
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """
    seconds: Optional[pulumi.Input[str]] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, nanos: Optional[pulumi.Input[float]] = None, seconds: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        __self__.nanos = nanos
        __self__.seconds = seconds

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionUrlRewriteArgs:
    host_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("hostRewrite")
    """
    Prior to forwarding the request to the selected service, the request's host header is replaced
    with contents of hostRewrite.
    The value must be between 1 and 255 characters.
    """
    path_prefix_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("pathPrefixRewrite")
    """
    Prior to forwarding the request to the selected backend service, the matching portion of the
    request's path is replaced by pathPrefixRewrite.
    The value must be between 1 and 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_rewrite: Optional[pulumi.Input[str]] = None, path_prefix_rewrite: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param pulumi.Input[str] path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        __self__.host_rewrite = host_rewrite
        __self__.path_prefix_rewrite = path_prefix_rewrite

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceArgs:
    backend_service: Optional[pulumi.Input[str]] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """
    header_action: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService.
    headerAction specified here take effect before headerAction in the enclosing
    HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """
    weight: Optional[pulumi.Input[float]] = pulumi.input_property("weight")
    """
    Specifies the fraction of traffic sent to backendService, computed as
    weight / (sum of all weightedBackendService weights in routeAction) .
    The selection of a backend service is determined only for new traffic. Once a user's request
    has been directed to a backendService, subsequent requests will be sent to the same backendService
    as determined by the BackendService's session affinity policy.
    The value must be between 0 and 1000
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: Optional[pulumi.Input[str]] = None, header_action: Optional[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionArgs']] = None, weight: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        :param pulumi.Input[float] weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        """
        __self__.backend_service = backend_service
        __self__.header_action = header_action
        __self__.weight = weight

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request prior to
    forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response prior to sending the
    response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs:
    header_name: Optional[pulumi.Input[str]] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: Optional[pulumi.Input[str]] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: Optional[pulumi.Input[bool]] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: Optional[pulumi.Input[str]] = None, header_value: Optional[pulumi.Input[str]] = None, replace: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs:
    header_name: Optional[pulumi.Input[str]] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: Optional[pulumi.Input[str]] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: Optional[pulumi.Input[bool]] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: Optional[pulumi.Input[str]] = None, header_value: Optional[pulumi.Input[str]] = None, replace: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherDefaultUrlRedirectArgs:
    strip_query: pulumi.Input[bool] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained. The default is set to false.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, strip_query: pulumi.Input[bool], host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        __self__.strip_query = strip_query
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code

@pulumi.input_type
class URLMapPathMatcherHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request prior to
    forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response prior to sending the
    response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class URLMapPathMatcherHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherPathRuleArgs:
    paths: pulumi.Input[List[pulumi.Input[str]]] = pulumi.input_property("paths")
    """
    The list of path patterns to match. Each must start with / and the only place a
    * is allowed is at the end following a /. The string fed to the path matcher
    does not include any text after the first ? or #, and those chars are not
    allowed here.
    """
    route_action: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionArgs']] = pulumi.input_property("routeAction")
    """
    In response to a matching matchRule, the load balancer performs advanced routing
    actions like URL rewrites, header transformations, etc. prior to forwarding the
    request to the selected backend. If  routeAction specifies any
    weightedBackendServices, service must not be set. Conversely if service is set,
    routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    or urlRedirect must be set.  Structure is documented below.
    """
    service: Optional[pulumi.Input[str]] = pulumi.input_property("service")
    """
    The backend service or backend bucket link that should be matched by this test.
    """
    url_redirect: Optional[pulumi.Input['URLMapPathMatcherPathRuleUrlRedirectArgs']] = pulumi.input_property("urlRedirect")
    """
    When this rule is matched, the request is redirected to a URL specified by
    urlRedirect. If urlRedirect is specified, service or routeAction must not be
    set.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, paths: pulumi.Input[List[pulumi.Input[str]]], route_action: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionArgs']] = None, service: Optional[pulumi.Input[str]] = None, url_redirect: Optional[pulumi.Input['URLMapPathMatcherPathRuleUrlRedirectArgs']] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input[str]]] paths: The list of path patterns to match. Each must start with / and the only place a
               * is allowed is at the end following a /. The string fed to the path matcher
               does not include any text after the first ? or #, and those chars are not
               allowed here.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionArgs'] route_action: In response to a matching matchRule, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If  routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.  Structure is documented below.
        :param pulumi.Input[str] service: The backend service or backend bucket link that should be matched by this test.
        :param pulumi.Input['URLMapPathMatcherPathRuleUrlRedirectArgs'] url_redirect: When this rule is matched, the request is redirected to a URL specified by
               urlRedirect. If urlRedirect is specified, service or routeAction must not be
               set.  Structure is documented below.
        """
        __self__.paths = paths
        __self__.route_action = route_action
        __self__.service = service
        __self__.url_redirect = url_redirect

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionArgs:
    cors_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs']] = pulumi.input_property("corsPolicy")
    """
    The specification for allowing client side cross-origin requests. Please see
    [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
    """
    fault_injection_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs']] = pulumi.input_property("faultInjectionPolicy")
    """
    The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
    percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
    by the Loadbalancer for a percentage of requests.
    timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
    """
    request_mirror_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs']] = pulumi.input_property("requestMirrorPolicy")
    """
    Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
    the host / authority header is suffixed with -shadow.  Structure is documented below.
    """
    retry_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionRetryPolicyArgs']] = pulumi.input_property("retryPolicy")
    """
    Specifies the retry policy associated with this route.  Structure is documented below.
    """
    timeout: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionTimeoutArgs']] = pulumi.input_property("timeout")
    """
    Specifies the timeout for the selected route. Timeout is computed from the time the request has been
    fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
    If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    url_rewrite: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionUrlRewriteArgs']] = pulumi.input_property("urlRewrite")
    """
    The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
    """
    weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs']]]] = pulumi.input_property("weightedBackendServices")
    """
    A list of weighted backend services to send traffic to when a route match occurs.
    The weights determine the fraction of traffic that flows to their corresponding backend service.
    If all traffic needs to go to a single backend service, there must be one weightedBackendService
    with weight set to a non 0 number.
    Once a backendService is identified and before forwarding the request to the backend service,
    advanced routing actions like Url rewrites and header transformations are applied depending on
    additional settings specified in this HttpRouteAction.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cors_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs']] = None, fault_injection_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs']] = None, request_mirror_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs']] = None, retry_policy: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionRetryPolicyArgs']] = None, timeout: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionTimeoutArgs']] = None, url_rewrite: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionUrlRewriteArgs']] = None, weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs']]]] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs'] cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs'] fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs'] request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionRetryPolicyArgs'] retry_policy: Specifies the retry policy associated with this route.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionTimeoutArgs'] timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionUrlRewriteArgs'] url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs']]] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.  Structure is documented below.
        """
        __self__.cors_policy = cors_policy
        __self__.fault_injection_policy = fault_injection_policy
        __self__.request_mirror_policy = request_mirror_policy
        __self__.retry_policy = retry_policy
        __self__.timeout = timeout
        __self__.url_rewrite = url_rewrite
        __self__.weighted_backend_services = weighted_backend_services

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs:
    disabled: pulumi.Input[bool] = pulumi.input_property("disabled")
    """
    If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
    """
    allow_credentials: Optional[pulumi.Input[bool]] = pulumi.input_property("allowCredentials")
    """
    In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
    This translates to the Access-Control-Allow-Credentials header.
    """
    allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowHeaders")
    """
    Specifies the content for the Access-Control-Allow-Headers header.
    """
    allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowMethods")
    """
    Specifies the content for the Access-Control-Allow-Methods header.
    """
    allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOriginRegexes")
    """
    Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
    please see en.cppreference.com/w/cpp/regex/ecmascript
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOrigins")
    """
    Specifies the list of origins that will be allowed to do CORS requests.
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("exposeHeaders")
    """
    Specifies the content for the Access-Control-Expose-Headers header.
    """
    max_age: Optional[pulumi.Input[float]] = pulumi.input_property("maxAge")
    """
    Specifies how long results of a preflight request can be cached in seconds.
    This translates to the Access-Control-Max-Age header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, disabled: pulumi.Input[bool], allow_credentials: Optional[pulumi.Input[bool]] = None, allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, max_age: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param pulumi.Input[bool] allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[List[pulumi.Input[str]]] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param pulumi.Input[float] max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        __self__.disabled = disabled
        __self__.allow_credentials = allow_credentials
        __self__.allow_headers = allow_headers
        __self__.allow_methods = allow_methods
        __self__.allow_origin_regexes = allow_origin_regexes
        __self__.allow_origins = allow_origins
        __self__.expose_headers = expose_headers
        __self__.max_age = max_age

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs:
    abort: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs']] = pulumi.input_property("abort")
    """
    The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
    """
    delay: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs']] = pulumi.input_property("delay")
    """
    The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, abort: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs']] = None, delay: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs']] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs'] abort: The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs'] delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
        """
        __self__.abort = abort
        __self__.delay = delay

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs:
    http_status: pulumi.Input[float] = pulumi.input_property("httpStatus")
    """
    The HTTP status code used to abort the request.
    The value must be between 200 and 599 inclusive.
    """
    percentage: pulumi.Input[float] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_status: pulumi.Input[float], percentage: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.http_status = http_status
        __self__.percentage = percentage

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs:
    fixed_delay: pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] = pulumi.input_property("fixedDelay")
    """
    Specifies the value of the fixed delay interval.  Structure is documented below.
    """
    percentage: pulumi.Input[float] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed_delay: pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'], percentage: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] fixed_delay: Specifies the value of the fixed delay interval.  Structure is documented below.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.fixed_delay = fixed_delay
        __self__.percentage = percentage

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        __self__.backend_service = backend_service

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicyArgs:
    num_retries: Optional[pulumi.Input[float]] = pulumi.input_property("numRetries")
    """
    Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
    """
    per_try_timeout: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = pulumi.input_property("perTryTimeout")
    """
    Specifies a non-zero timeout per retry attempt.
    If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
    will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("retryConditions")
    """
    Specfies one or more conditions when this retry rule applies. Valid values are:
    5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
    or if the backend service does not respond at all, example: disconnects, reset, read timeout,
    connection failure, and refused streams.
    gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
    connect-failure: Loadbalancer will retry on failures connecting to backend services,
    for example due to connection timeouts.
    retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
    Currently the only retriable error supported is 409.
    refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
    This reset type indicates that it is safe to retry.
    cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
    deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
    resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
    unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, num_retries: Optional[pulumi.Input[float]] = None, per_try_timeout: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = None, retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[float] num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs'] per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               connection failure, and refused streams.
               gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        __self__.num_retries = num_retries
        __self__.per_try_timeout = per_try_timeout
        __self__.retry_conditions = retry_conditions

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionUrlRewriteArgs:
    host_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("hostRewrite")
    """
    Prior to forwarding the request to the selected service, the request's host header is replaced
    with contents of hostRewrite.
    The value must be between 1 and 255 characters.
    """
    path_prefix_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("pathPrefixRewrite")
    """
    Prior to forwarding the request to the selected backend service, the matching portion of the
    request's path is replaced by pathPrefixRewrite.
    The value must be between 1 and 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_rewrite: Optional[pulumi.Input[str]] = None, path_prefix_rewrite: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param pulumi.Input[str] path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        __self__.host_rewrite = host_rewrite
        __self__.path_prefix_rewrite = path_prefix_rewrite

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """
    weight: pulumi.Input[float] = pulumi.input_property("weight")
    """
    Specifies the fraction of traffic sent to backendService, computed as
    weight / (sum of all weightedBackendService weights in routeAction) .
    The selection of a backend service is determined only for new traffic. Once a user's request
    has been directed to a backendService, subsequent requests will be sent to the same backendService
    as determined by the BackendService's session affinity policy.
    The value must be between 0 and 1000
    """
    header_action: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService.
    headerAction specified here take effect before headerAction in the enclosing
    HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str], weight: pulumi.Input[float], header_action: Optional[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = None) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param pulumi.Input[float] weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        """
        __self__.backend_service = backend_service
        __self__.weight = weight
        __self__.header_action = header_action

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request prior to
    forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response prior to sending the
    response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherPathRuleUrlRedirectArgs:
    strip_query: pulumi.Input[bool] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained. The default is set to false.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, strip_query: pulumi.Input[bool], host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        __self__.strip_query = strip_query
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code

@pulumi.input_type
class URLMapPathMatcherRouteRuleArgs:
    priority: pulumi.Input[float] = pulumi.input_property("priority")
    """
    For routeRules within a given pathMatcher, priority determines the order
    in which load balancer will interpret routeRules. RouteRules are evaluated
    in order of priority, from the lowest to highest number. The priority of
    a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    that matches the request is applied.
    You cannot configure two or more routeRules with the same priority.
    Priority for each rule must be set to a number between 0 and
    2147483647 inclusive.
    Priority numbers can have gaps, which enable you to add or remove rules
    in the future without affecting the rest of the rules. For example,
    1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    future without any impact on existing rules.
    """
    header_action: Optional[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService.
    headerAction specified here take effect before headerAction in the enclosing
    HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """
    match_rules: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleArgs']]]] = pulumi.input_property("matchRules")
    """
    The rules for determining a match.  Structure is documented below.
    """
    route_action: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionArgs']] = pulumi.input_property("routeAction")
    """
    In response to a matching matchRule, the load balancer performs advanced routing
    actions like URL rewrites, header transformations, etc. prior to forwarding the
    request to the selected backend. If  routeAction specifies any
    weightedBackendServices, service must not be set. Conversely if service is set,
    routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    or urlRedirect must be set.  Structure is documented below.
    """
    service: Optional[pulumi.Input[str]] = pulumi.input_property("service")
    """
    The backend service or backend bucket link that should be matched by this test.
    """
    url_redirect: Optional[pulumi.Input['URLMapPathMatcherRouteRuleUrlRedirectArgs']] = pulumi.input_property("urlRedirect")
    """
    When this rule is matched, the request is redirected to a URL specified by
    urlRedirect. If urlRedirect is specified, service or routeAction must not be
    set.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, priority: pulumi.Input[float], header_action: Optional[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionArgs']] = None, match_rules: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleArgs']]]] = None, route_action: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionArgs']] = None, service: Optional[pulumi.Input[str]] = None, url_redirect: Optional[pulumi.Input['URLMapPathMatcherRouteRuleUrlRedirectArgs']] = None) -> None:
        """
        :param pulumi.Input[float] priority: For routeRules within a given pathMatcher, priority determines the order
               in which load balancer will interpret routeRules. RouteRules are evaluated
               in order of priority, from the lowest to highest number. The priority of
               a rule decreases as its number increases (1, 2, 3, N+1). The first rule
               that matches the request is applied.
               You cannot configure two or more routeRules with the same priority.
               Priority for each rule must be set to a number between 0 and
               2147483647 inclusive.
               Priority numbers can have gaps, which enable you to add or remove rules
               in the future without affecting the rest of the rules. For example,
               1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
               you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
               future without any impact on existing rules.
        :param pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleArgs']]] match_rules: The rules for determining a match.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionArgs'] route_action: In response to a matching matchRule, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If  routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.  Structure is documented below.
        :param pulumi.Input[str] service: The backend service or backend bucket link that should be matched by this test.
        :param pulumi.Input['URLMapPathMatcherRouteRuleUrlRedirectArgs'] url_redirect: When this rule is matched, the request is redirected to a URL specified by
               urlRedirect. If urlRedirect is specified, service or routeAction must not be
               set.  Structure is documented below.
        """
        __self__.priority = priority
        __self__.header_action = header_action
        __self__.match_rules = match_rules
        __self__.route_action = route_action
        __self__.service = service
        __self__.url_redirect = url_redirect

@pulumi.input_type
class URLMapPathMatcherRouteRuleHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request prior to
    forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response prior to sending the
    response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherRouteRuleMatchRuleArgs:
    full_path_match: Optional[pulumi.Input[str]] = pulumi.input_property("fullPathMatch")
    """
    For satifying the matchRule condition, the path of the request must exactly
    match the value specified in fullPathMatch after removing any query parameters
    and anchor that may be part of the original URL. FullPathMatch must be between 1
    and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    be specified.
    """
    header_matches: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs']]]] = pulumi.input_property("headerMatches")
    """
    Specifies a list of header match criteria, all of which must match corresponding
    headers in the request.  Structure is documented below.
    """
    ignore_case: Optional[pulumi.Input[bool]] = pulumi.input_property("ignoreCase")
    """
    Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    Defaults to false.
    """
    metadata_filters: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs']]]] = pulumi.input_property("metadataFilters")
    """
    Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    clients present node metadata. If a match takes place, the relevant routing
    configuration is made available to those proxies. For each metadataFilter in
    this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    filterLabels must match the corresponding label provided in the metadata. If its
    filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    with corresponding labels in the provided metadata. metadataFilters specified
    here can be overrides those specified in ForwardingRule that refers to this
    UrlMap. metadataFilters only applies to Loadbalancers that have their
    loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
    """
    prefix_match: Optional[pulumi.Input[str]] = pulumi.input_property("prefixMatch")
    """
    The value of the header must start with the contents of prefixMatch. Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.
    """
    query_parameter_matches: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs']]]] = pulumi.input_property("queryParameterMatches")
    """
    Specifies a list of query parameter match criteria, all of which must match
    corresponding query parameters in the request.  Structure is documented below.
    """
    regex_match: Optional[pulumi.Input[str]] = pulumi.input_property("regexMatch")
    """
    The queryParameterMatch matches if the value of the parameter matches the
    regular expression specified by regexMatch. For the regular expression grammar,
    please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    exactMatch and regexMatch must be set.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, full_path_match: Optional[pulumi.Input[str]] = None, header_matches: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs']]]] = None, ignore_case: Optional[pulumi.Input[bool]] = None, metadata_filters: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs']]]] = None, prefix_match: Optional[pulumi.Input[str]] = None, query_parameter_matches: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs']]]] = None, regex_match: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] full_path_match: For satifying the matchRule condition, the path of the request must exactly
               match the value specified in fullPathMatch after removing any query parameters
               and anchor that may be part of the original URL. FullPathMatch must be between 1
               and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
               be specified.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs']]] header_matches: Specifies a list of header match criteria, all of which must match corresponding
               headers in the request.  Structure is documented below.
        :param pulumi.Input[bool] ignore_case: Specifies that prefixMatch and fullPathMatch matches are case sensitive.
               Defaults to false.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs']]] metadata_filters: Opaque filter criteria used by Loadbalancer to restrict routing configuration to
               a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
               clients present node metadata. If a match takes place, the relevant routing
               configuration is made available to those proxies. For each metadataFilter in
               this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
               filterLabels must match the corresponding label provided in the metadata. If its
               filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
               with corresponding labels in the provided metadata. metadataFilters specified
               here can be overrides those specified in ForwardingRule that refers to this
               UrlMap. metadataFilters only applies to Loadbalancers that have their
               loadBalancingScheme set to INTERNAL_SELF_MANAGED.  Structure is documented below.
        :param pulumi.Input[str] prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs']]] query_parameter_matches: Specifies a list of query parameter match criteria, all of which must match
               corresponding query parameters in the request.  Structure is documented below.
        :param pulumi.Input[str] regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        __self__.full_path_match = full_path_match
        __self__.header_matches = header_matches
        __self__.ignore_case = ignore_case
        __self__.metadata_filters = metadata_filters
        __self__.prefix_match = prefix_match
        __self__.query_parameter_matches = query_parameter_matches
        __self__.regex_match = regex_match

@pulumi.input_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    exact_match: Optional[pulumi.Input[str]] = pulumi.input_property("exactMatch")
    """
    The queryParameterMatch matches if the value of the parameter exactly matches
    the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    must be set.
    """
    invert_match: Optional[pulumi.Input[bool]] = pulumi.input_property("invertMatch")
    """
    If set to false, the headerMatch is considered a match if the match criteria
    above are met. If set to true, the headerMatch is considered a match if the
    match criteria above are NOT met. Defaults to false.
    """
    prefix_match: Optional[pulumi.Input[str]] = pulumi.input_property("prefixMatch")
    """
    The value of the header must start with the contents of prefixMatch. Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.
    """
    present_match: Optional[pulumi.Input[bool]] = pulumi.input_property("presentMatch")
    """
    Specifies that the queryParameterMatch matches if the request contains the query
    parameter, irrespective of whether the parameter has a value or not. Only one of
    presentMatch, exactMatch and regexMatch must be set.
    """
    range_match: Optional[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs']] = pulumi.input_property("rangeMatch")
    """
    The header value must be an integer and its value must be in the range specified
    in rangeMatch. If the header does not contain an integer, number or is empty,
    the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
    not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.  Structure is documented below.
    """
    regex_match: Optional[pulumi.Input[str]] = pulumi.input_property("regexMatch")
    """
    The queryParameterMatch matches if the value of the parameter matches the
    regular expression specified by regexMatch. For the regular expression grammar,
    please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    exactMatch and regexMatch must be set.
    """
    suffix_match: Optional[pulumi.Input[str]] = pulumi.input_property("suffixMatch")
    """
    The value of the header must end with the contents of suffixMatch. Only one of
    exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    must be set.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], exact_match: Optional[pulumi.Input[str]] = None, invert_match: Optional[pulumi.Input[bool]] = None, prefix_match: Optional[pulumi.Input[str]] = None, present_match: Optional[pulumi.Input[bool]] = None, range_match: Optional[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs']] = None, regex_match: Optional[pulumi.Input[str]] = None, suffix_match: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param pulumi.Input[bool] invert_match: If set to false, the headerMatch is considered a match if the match criteria
               above are met. If set to true, the headerMatch is considered a match if the
               match criteria above are NOT met. Defaults to false.
        :param pulumi.Input[str] prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param pulumi.Input[bool] present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs'] range_match: The header value must be an integer and its value must be in the range specified
               in rangeMatch. If the header does not contain an integer, number or is empty,
               the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
               not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.  Structure is documented below.
        :param pulumi.Input[str] regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        :param pulumi.Input[str] suffix_match: The value of the header must end with the contents of suffixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        """
        __self__.header_name = header_name
        __self__.exact_match = exact_match
        __self__.invert_match = invert_match
        __self__.prefix_match = prefix_match
        __self__.present_match = present_match
        __self__.range_match = range_match
        __self__.regex_match = regex_match
        __self__.suffix_match = suffix_match

@pulumi.input_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs:
    range_end: pulumi.Input[float] = pulumi.input_property("rangeEnd")
    """
    The end of the range (exclusive).
    """
    range_start: pulumi.Input[float] = pulumi.input_property("rangeStart")
    """
    The start of the range (inclusive).
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, range_end: pulumi.Input[float], range_start: pulumi.Input[float]) -> None:
        """
        :param pulumi.Input[float] range_end: The end of the range (exclusive).
        :param pulumi.Input[float] range_start: The start of the range (inclusive).
        """
        __self__.range_end = range_end
        __self__.range_start = range_start

@pulumi.input_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs:
    filter_labels: pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs']]] = pulumi.input_property("filterLabels")
    """
    The list of label value pairs that must match labels in the provided metadata
    based on filterMatchCriteria  This list must not be empty and can have at the
    most 64 entries.  Structure is documented below.
    """
    filter_match_criteria: pulumi.Input[str] = pulumi.input_property("filterMatchCriteria")
    """
    Specifies how individual filterLabel matches within the list of filterLabels
    contribute towards the overall metadataFilter match. Supported values are:
    - MATCH_ANY: At least one of the filterLabels must have a matching label in the
    provided metadata.
    - MATCH_ALL: All filterLabels must have matching labels in
    the provided metadata.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, filter_labels: pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs']]], filter_match_criteria: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs']]] filter_labels: The list of label value pairs that must match labels in the provided metadata
               based on filterMatchCriteria  This list must not be empty and can have at the
               most 64 entries.  Structure is documented below.
        :param pulumi.Input[str] filter_match_criteria: Specifies how individual filterLabel matches within the list of filterLabels
               contribute towards the overall metadataFilter match. Supported values are:
               - MATCH_ANY: At least one of the filterLabels must have a matching label in the
               provided metadata.
               - MATCH_ALL: All filterLabels must have matching labels in
               the provided metadata.
        """
        __self__.filter_labels = filter_labels
        __self__.filter_match_criteria = filter_match_criteria

@pulumi.input_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The name of the query parameter to match. The query parameter must exist in the
    request, in the absence of which the request match fails.
    """
    value: pulumi.Input[str] = pulumi.input_property("value")
    """
    The value of the label must match the specified value. value can have a maximum
    length of 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], value: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param pulumi.Input[str] value: The value of the label must match the specified value. value can have a maximum
               length of 1024 characters.
        """
        __self__.name = name
        __self__.value = value

@pulumi.input_type
class URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs:
    name: pulumi.Input[str] = pulumi.input_property("name")
    """
    The name of the query parameter to match. The query parameter must exist in the
    request, in the absence of which the request match fails.
    """
    exact_match: Optional[pulumi.Input[str]] = pulumi.input_property("exactMatch")
    """
    The queryParameterMatch matches if the value of the parameter exactly matches
    the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    must be set.
    """
    present_match: Optional[pulumi.Input[bool]] = pulumi.input_property("presentMatch")
    """
    Specifies that the queryParameterMatch matches if the request contains the query
    parameter, irrespective of whether the parameter has a value or not. Only one of
    presentMatch, exactMatch and regexMatch must be set.
    """
    regex_match: Optional[pulumi.Input[str]] = pulumi.input_property("regexMatch")
    """
    The queryParameterMatch matches if the value of the parameter matches the
    regular expression specified by regexMatch. For the regular expression grammar,
    please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    exactMatch and regexMatch must be set.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, name: pulumi.Input[str], exact_match: Optional[pulumi.Input[str]] = None, present_match: Optional[pulumi.Input[bool]] = None, regex_match: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param pulumi.Input[str] exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param pulumi.Input[bool] present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param pulumi.Input[str] regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        __self__.name = name
        __self__.exact_match = exact_match
        __self__.present_match = present_match
        __self__.regex_match = regex_match

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionArgs:
    cors_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionCorsPolicyArgs']] = pulumi.input_property("corsPolicy")
    """
    The specification for allowing client side cross-origin requests. Please see
    [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
    """
    fault_injection_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs']] = pulumi.input_property("faultInjectionPolicy")
    """
    The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
    percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
    by the Loadbalancer for a percentage of requests.
    timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
    """
    request_mirror_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs']] = pulumi.input_property("requestMirrorPolicy")
    """
    Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
    the host / authority header is suffixed with -shadow.  Structure is documented below.
    """
    retry_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRetryPolicyArgs']] = pulumi.input_property("retryPolicy")
    """
    Specifies the retry policy associated with this route.  Structure is documented below.
    """
    timeout: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionTimeoutArgs']] = pulumi.input_property("timeout")
    """
    Specifies the timeout for the selected route. Timeout is computed from the time the request has been
    fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
    If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    url_rewrite: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionUrlRewriteArgs']] = pulumi.input_property("urlRewrite")
    """
    The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
    """
    weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs']]]] = pulumi.input_property("weightedBackendServices")
    """
    A list of weighted backend services to send traffic to when a route match occurs.
    The weights determine the fraction of traffic that flows to their corresponding backend service.
    If all traffic needs to go to a single backend service, there must be one weightedBackendService
    with weight set to a non 0 number.
    Once a backendService is identified and before forwarding the request to the backend service,
    advanced routing actions like Url rewrites and header transformations are applied depending on
    additional settings specified in this HttpRouteAction.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, cors_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionCorsPolicyArgs']] = None, fault_injection_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs']] = None, request_mirror_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs']] = None, retry_policy: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRetryPolicyArgs']] = None, timeout: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionTimeoutArgs']] = None, url_rewrite: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionUrlRewriteArgs']] = None, weighted_backend_services: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs']]]] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionCorsPolicyArgs'] cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs'] fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs'] request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRetryPolicyArgs'] retry_policy: Specifies the retry policy associated with this route.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionTimeoutArgs'] timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionUrlRewriteArgs'] url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs']]] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.  Structure is documented below.
        """
        __self__.cors_policy = cors_policy
        __self__.fault_injection_policy = fault_injection_policy
        __self__.request_mirror_policy = request_mirror_policy
        __self__.retry_policy = retry_policy
        __self__.timeout = timeout
        __self__.url_rewrite = url_rewrite
        __self__.weighted_backend_services = weighted_backend_services

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionCorsPolicyArgs:
    allow_credentials: Optional[pulumi.Input[bool]] = pulumi.input_property("allowCredentials")
    """
    In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
    This translates to the Access-Control-Allow-Credentials header.
    """
    allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowHeaders")
    """
    Specifies the content for the Access-Control-Allow-Headers header.
    """
    allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowMethods")
    """
    Specifies the content for the Access-Control-Allow-Methods header.
    """
    allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOriginRegexes")
    """
    Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
    please see en.cppreference.com/w/cpp/regex/ecmascript
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("allowOrigins")
    """
    Specifies the list of origins that will be allowed to do CORS requests.
    An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
    """
    disabled: Optional[pulumi.Input[bool]] = pulumi.input_property("disabled")
    """
    If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
    """
    expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("exposeHeaders")
    """
    Specifies the content for the Access-Control-Expose-Headers header.
    """
    max_age: Optional[pulumi.Input[float]] = pulumi.input_property("maxAge")
    """
    Specifies how long results of a preflight request can be cached in seconds.
    This translates to the Access-Control-Max-Age header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, allow_credentials: Optional[pulumi.Input[bool]] = None, allow_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_methods: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origin_regexes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, allow_origins: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, disabled: Optional[pulumi.Input[bool]] = None, expose_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, max_age: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[bool] allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[List[pulumi.Input[str]]] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param pulumi.Input[bool] disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param pulumi.Input[List[pulumi.Input[str]]] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param pulumi.Input[float] max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        __self__.allow_credentials = allow_credentials
        __self__.allow_headers = allow_headers
        __self__.allow_methods = allow_methods
        __self__.allow_origin_regexes = allow_origin_regexes
        __self__.allow_origins = allow_origins
        __self__.disabled = disabled
        __self__.expose_headers = expose_headers
        __self__.max_age = max_age

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs:
    abort: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs']] = pulumi.input_property("abort")
    """
    The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
    """
    delay: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs']] = pulumi.input_property("delay")
    """
    The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, abort: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs']] = None, delay: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs']] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs'] abort: The specification for how client requests are aborted as part of fault injection.  Structure is documented below.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs'] delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.  Structure is documented below.
        """
        __self__.abort = abort
        __self__.delay = delay

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs:
    http_status: Optional[pulumi.Input[float]] = pulumi.input_property("httpStatus")
    """
    The HTTP status code used to abort the request.
    The value must be between 200 and 599 inclusive.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, http_status: Optional[pulumi.Input[float]] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[float] http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.http_status = http_status
        __self__.percentage = percentage

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs:
    fixed_delay: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = pulumi.input_property("fixedDelay")
    """
    Specifies the value of the fixed delay interval.  Structure is documented below.
    """
    percentage: Optional[pulumi.Input[float]] = pulumi.input_property("percentage")
    """
    The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
    The value must be between 0.0 and 100.0 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, fixed_delay: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs']] = None, percentage: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs'] fixed_delay: Specifies the value of the fixed delay interval.  Structure is documented below.
        :param pulumi.Input[float] percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        __self__.fixed_delay = fixed_delay
        __self__.percentage = percentage

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str]) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        __self__.backend_service = backend_service

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicyArgs:
    num_retries: pulumi.Input[float] = pulumi.input_property("numRetries")
    """
    Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
    """
    per_try_timeout: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = pulumi.input_property("perTryTimeout")
    """
    Specifies a non-zero timeout per retry attempt.
    If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
    will use the largest timeout among all backend services associated with the route.  Structure is documented below.
    """
    retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("retryConditions")
    """
    Specfies one or more conditions when this retry rule applies. Valid values are:
    5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
    or if the backend service does not respond at all, example: disconnects, reset, read timeout,
    connection failure, and refused streams.
    gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
    connect-failure: Loadbalancer will retry on failures connecting to backend services,
    for example due to connection timeouts.
    retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
    Currently the only retriable error supported is 409.
    refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
    This reset type indicates that it is safe to retry.
    cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
    deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
    resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
    unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, num_retries: pulumi.Input[float], per_try_timeout: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs']] = None, retry_conditions: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[float] num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs'] per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               connection failure, and refused streams.
               gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        __self__.num_retries = num_retries
        __self__.per_try_timeout = per_try_timeout
        __self__.retry_conditions = retry_conditions

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionTimeoutArgs:
    seconds: pulumi.Input[str] = pulumi.input_property("seconds")
    """
    Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
    Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    """
    nanos: Optional[pulumi.Input[float]] = pulumi.input_property("nanos")
    """
    Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
    represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, seconds: pulumi.Input[str], nanos: Optional[pulumi.Input[float]] = None) -> None:
        """
        :param pulumi.Input[str] seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param pulumi.Input[float] nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        __self__.seconds = seconds
        __self__.nanos = nanos

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionUrlRewriteArgs:
    host_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("hostRewrite")
    """
    Prior to forwarding the request to the selected service, the request's host header is replaced
    with contents of hostRewrite.
    The value must be between 1 and 255 characters.
    """
    path_prefix_rewrite: Optional[pulumi.Input[str]] = pulumi.input_property("pathPrefixRewrite")
    """
    Prior to forwarding the request to the selected backend service, the matching portion of the
    request's path is replaced by pathPrefixRewrite.
    The value must be between 1 and 1024 characters.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_rewrite: Optional[pulumi.Input[str]] = None, path_prefix_rewrite: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param pulumi.Input[str] path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        __self__.host_rewrite = host_rewrite
        __self__.path_prefix_rewrite = path_prefix_rewrite

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs:
    backend_service: pulumi.Input[str] = pulumi.input_property("backendService")
    """
    The full or partial URL to the BackendService resource being mirrored to.
    """
    weight: pulumi.Input[float] = pulumi.input_property("weight")
    """
    Specifies the fraction of traffic sent to backendService, computed as
    weight / (sum of all weightedBackendService weights in routeAction) .
    The selection of a backend service is determined only for new traffic. Once a user's request
    has been directed to a backendService, subsequent requests will be sent to the same backendService
    as determined by the BackendService's session affinity policy.
    The value must be between 0 and 1000
    """
    header_action: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = pulumi.input_property("headerAction")
    """
    Specifies changes to request and response headers that need to take effect for
    the selected backendService.
    headerAction specified here take effect before headerAction in the enclosing
    HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, backend_service: pulumi.Input[str], weight: pulumi.Input[float], header_action: Optional[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs']] = None) -> None:
        """
        :param pulumi.Input[str] backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param pulumi.Input[float] weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs'] header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.  Structure is documented below.
        """
        __self__.backend_service = backend_service
        __self__.weight = weight
        __self__.header_action = header_action

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs:
    request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = pulumi.input_property("requestHeadersToAdds")
    """
    Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
    """
    request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("requestHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the request prior to
    forwarding the request to the backendService.
    """
    response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = pulumi.input_property("responseHeadersToAdds")
    """
    Headers to add the response prior to sending the response back to the client.  Structure is documented below.
    """
    response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = pulumi.input_property("responseHeadersToRemoves")
    """
    A list of header names for headers that need to be removed from the response prior to sending the
    response back to the client.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, request_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]]] = None, request_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None, response_headers_to_adds: Optional[pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]]] = None, response_headers_to_removes: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> None:
        """
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs']]] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param pulumi.Input[List[pulumi.Input['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs']]] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.  Structure is documented below.
        :param pulumi.Input[List[pulumi.Input[str]]] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        __self__.request_headers_to_adds = request_headers_to_adds
        __self__.request_headers_to_removes = request_headers_to_removes
        __self__.response_headers_to_adds = response_headers_to_adds
        __self__.response_headers_to_removes = response_headers_to_removes

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs:
    header_name: pulumi.Input[str] = pulumi.input_property("headerName")
    """
    The name of the header to add.
    """
    header_value: pulumi.Input[str] = pulumi.input_property("headerValue")
    """
    The value of the header to add.
    """
    replace: pulumi.Input[bool] = pulumi.input_property("replace")
    """
    If false, headerValue is appended to any values that already exist for the header.
    If true, headerValue is set for the header, discarding any values that were set for that header.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, header_name: pulumi.Input[str], header_value: pulumi.Input[str], replace: pulumi.Input[bool]) -> None:
        """
        :param pulumi.Input[str] header_name: The name of the header to add.
        :param pulumi.Input[str] header_value: The value of the header to add.
        :param pulumi.Input[bool] replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        __self__.header_name = header_name
        __self__.header_value = header_value
        __self__.replace = replace

@pulumi.input_type
class URLMapPathMatcherRouteRuleUrlRedirectArgs:
    host_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("hostRedirect")
    """
    The host that will be used in the redirect response instead of the one that was
    supplied in the request. The value must be between 1 and 255 characters.
    """
    https_redirect: Optional[pulumi.Input[bool]] = pulumi.input_property("httpsRedirect")
    """
    If set to true, the URL scheme in the redirected request is set to https. If set to
    false, the URL scheme of the redirected request will remain the same as that of the
    request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    true for TargetHttpsProxy is not permitted. The default is set to false.
    """
    path_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("pathRedirect")
    """
    The path that will be used in the redirect response instead of the one that was
    supplied in the request. pathRedirect cannot be supplied together with
    prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    original request will be used for the redirect. The value must be between 1 and 1024
    characters.
    """
    prefix_redirect: Optional[pulumi.Input[str]] = pulumi.input_property("prefixRedirect")
    """
    The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    retaining the remaining portion of the URL before redirecting the request.
    prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    neither. If neither is supplied, the path of the original request will be used for
    the redirect. The value must be between 1 and 1024 characters.
    """
    redirect_response_code: Optional[pulumi.Input[str]] = pulumi.input_property("redirectResponseCode")
    """
    The HTTP Status code to use for this RedirectAction. Supported values are:
    - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
    - FOUND, which corresponds to 302.
    - SEE_OTHER which corresponds to 303.
    - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
    will be retained.
    - PERMANENT_REDIRECT, which corresponds to 308. In this case,
    the request method will be retained.
    """
    strip_query: Optional[pulumi.Input[bool]] = pulumi.input_property("stripQuery")
    """
    If set to true, any accompanying query portion of the original URL is removed prior
    to redirecting the request. If set to false, the query portion of the original URL is
    retained. The default is set to false.
    This field is required to ensure an empty block is not set. The normal default value is false.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host_redirect: Optional[pulumi.Input[str]] = None, https_redirect: Optional[pulumi.Input[bool]] = None, path_redirect: Optional[pulumi.Input[str]] = None, prefix_redirect: Optional[pulumi.Input[str]] = None, redirect_response_code: Optional[pulumi.Input[str]] = None, strip_query: Optional[pulumi.Input[bool]] = None) -> None:
        """
        :param pulumi.Input[str] host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param pulumi.Input[bool] https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param pulumi.Input[str] path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param pulumi.Input[str] prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param pulumi.Input[str] redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               - FOUND, which corresponds to 302.
               - SEE_OTHER which corresponds to 303.
               - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               - PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        :param pulumi.Input[bool] strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        """
        __self__.host_redirect = host_redirect
        __self__.https_redirect = https_redirect
        __self__.path_redirect = path_redirect
        __self__.prefix_redirect = prefix_redirect
        __self__.redirect_response_code = redirect_response_code
        __self__.strip_query = strip_query

@pulumi.input_type
class URLMapTestArgs:
    host: pulumi.Input[str] = pulumi.input_property("host")
    """
    Host portion of the URL.
    """
    path: pulumi.Input[str] = pulumi.input_property("path")
    """
    Path portion of the URL.
    """
    service: pulumi.Input[str] = pulumi.input_property("service")
    """
    The backend service or backend bucket link that should be matched by this test.
    """
    description: Optional[pulumi.Input[str]] = pulumi.input_property("description")
    """
    Description of this test case.
    """

    # pylint: disable=no-self-argument
    def __init__(__self__, *, host: pulumi.Input[str], path: pulumi.Input[str], service: pulumi.Input[str], description: Optional[pulumi.Input[str]] = None) -> None:
        """
        :param pulumi.Input[str] host: Host portion of the URL.
        :param pulumi.Input[str] path: Path portion of the URL.
        :param pulumi.Input[str] service: The backend service or backend bucket link that should be matched by this test.
        :param pulumi.Input[str] description: Description of this test case.
        """
        __self__.host = host
        __self__.path = path
        __self__.service = service
        __self__.description = description

