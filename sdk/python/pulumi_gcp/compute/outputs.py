# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from .. import _utilities, _tables
from . import outputs

__all__ = [
    'AutoscalarAutoscalingPolicy',
    'AutoscalarAutoscalingPolicyCpuUtilization',
    'AutoscalarAutoscalingPolicyLoadBalancingUtilization',
    'AutoscalarAutoscalingPolicyMetric',
    'AutoscalarAutoscalingPolicyScaleDownControl',
    'AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'AutoscalerAutoscalingPolicy',
    'AutoscalerAutoscalingPolicyCpuUtilization',
    'AutoscalerAutoscalingPolicyLoadBalancingUtilization',
    'AutoscalerAutoscalingPolicyMetric',
    'AutoscalerAutoscalingPolicyScaleDownControl',
    'AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'BackendBucketCdnPolicy',
    'BackendServiceBackend',
    'BackendServiceCdnPolicy',
    'BackendServiceCdnPolicyCacheKeyPolicy',
    'BackendServiceCircuitBreakers',
    'BackendServiceCircuitBreakersConnectTimeout',
    'BackendServiceConsistentHash',
    'BackendServiceConsistentHashHttpCookie',
    'BackendServiceConsistentHashHttpCookieTtl',
    'BackendServiceIap',
    'BackendServiceLogConfig',
    'BackendServiceOutlierDetection',
    'BackendServiceOutlierDetectionBaseEjectionTime',
    'BackendServiceOutlierDetectionInterval',
    'DiskDiskEncryptionKey',
    'DiskSourceImageEncryptionKey',
    'DiskSourceSnapshotEncryptionKey',
    'ExternalVpnGatewayInterface',
    'FirewallAllow',
    'FirewallDeny',
    'FirewallLogConfig',
    'GlobalForwardingRuleMetadataFilter',
    'GlobalForwardingRuleMetadataFilterFilterLabel',
    'HaVpnGatewayVpnInterface',
    'HealthCheckHttp2HealthCheck',
    'HealthCheckHttpHealthCheck',
    'HealthCheckHttpsHealthCheck',
    'HealthCheckLogConfig',
    'HealthCheckSslHealthCheck',
    'HealthCheckTcpHealthCheck',
    'ImageGuestOsFeature',
    'ImageRawDisk',
    'InstanceAttachedDisk',
    'InstanceBootDisk',
    'InstanceBootDiskInitializeParams',
    'InstanceConfidentialInstanceConfig',
    'InstanceFromTemplateAttachedDisk',
    'InstanceFromTemplateBootDisk',
    'InstanceFromTemplateBootDiskInitializeParams',
    'InstanceFromTemplateConfidentialInstanceConfig',
    'InstanceFromTemplateGuestAccelerator',
    'InstanceFromTemplateNetworkInterface',
    'InstanceFromTemplateNetworkInterfaceAccessConfig',
    'InstanceFromTemplateNetworkInterfaceAliasIpRange',
    'InstanceFromTemplateScheduling',
    'InstanceFromTemplateSchedulingNodeAffinity',
    'InstanceFromTemplateScratchDisk',
    'InstanceFromTemplateServiceAccount',
    'InstanceFromTemplateShieldedInstanceConfig',
    'InstanceGroupManagerAutoHealingPolicies',
    'InstanceGroupManagerNamedPort',
    'InstanceGroupManagerStatefulDisk',
    'InstanceGroupManagerUpdatePolicy',
    'InstanceGroupManagerVersion',
    'InstanceGroupManagerVersionTargetSize',
    'InstanceGroupNamedPort',
    'InstanceGuestAccelerator',
    'InstanceIAMBindingCondition',
    'InstanceIAMMemberCondition',
    'InstanceNetworkInterface',
    'InstanceNetworkInterfaceAccessConfig',
    'InstanceNetworkInterfaceAliasIpRange',
    'InstanceScheduling',
    'InstanceSchedulingNodeAffinity',
    'InstanceScratchDisk',
    'InstanceServiceAccount',
    'InstanceShieldedInstanceConfig',
    'InstanceTemplateConfidentialInstanceConfig',
    'InstanceTemplateDisk',
    'InstanceTemplateDiskDiskEncryptionKey',
    'InstanceTemplateGuestAccelerator',
    'InstanceTemplateNetworkInterface',
    'InstanceTemplateNetworkInterfaceAccessConfig',
    'InstanceTemplateNetworkInterfaceAliasIpRange',
    'InstanceTemplateScheduling',
    'InstanceTemplateSchedulingNodeAffinity',
    'InstanceTemplateServiceAccount',
    'InstanceTemplateShieldedInstanceConfig',
    'InterconnectAttachmentPrivateInterconnectInfo',
    'ManagedSslCertificateManaged',
    'MangedSslCertificateManaged',
    'NodeGroupAutoscalingPolicy',
    'NodeTemplateNodeTypeFlexibility',
    'NodeTemplateServerBinding',
    'OrganizationSecurityPolicyRuleMatch',
    'OrganizationSecurityPolicyRuleMatchConfig',
    'OrganizationSecurityPolicyRuleMatchConfigLayer4Config',
    'PacketMirroringCollectorIlb',
    'PacketMirroringFilter',
    'PacketMirroringMirroredResources',
    'PacketMirroringMirroredResourcesInstance',
    'PacketMirroringMirroredResourcesSubnetwork',
    'PacketMirroringNetwork',
    'PerInstanceConfigPreservedState',
    'PerInstanceConfigPreservedStateDisk',
    'RegionAutoscalerAutoscalingPolicy',
    'RegionAutoscalerAutoscalingPolicyCpuUtilization',
    'RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization',
    'RegionAutoscalerAutoscalingPolicyMetric',
    'RegionAutoscalerAutoscalingPolicyScaleDownControl',
    'RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'RegionBackendServiceBackend',
    'RegionBackendServiceCircuitBreakers',
    'RegionBackendServiceCircuitBreakersConnectTimeout',
    'RegionBackendServiceConsistentHash',
    'RegionBackendServiceConsistentHashHttpCookie',
    'RegionBackendServiceConsistentHashHttpCookieTtl',
    'RegionBackendServiceFailoverPolicy',
    'RegionBackendServiceLogConfig',
    'RegionBackendServiceOutlierDetection',
    'RegionBackendServiceOutlierDetectionBaseEjectionTime',
    'RegionBackendServiceOutlierDetectionInterval',
    'RegionDiskDiskEncryptionKey',
    'RegionDiskSourceSnapshotEncryptionKey',
    'RegionHealthCheckHttp2HealthCheck',
    'RegionHealthCheckHttpHealthCheck',
    'RegionHealthCheckHttpsHealthCheck',
    'RegionHealthCheckLogConfig',
    'RegionHealthCheckSslHealthCheck',
    'RegionHealthCheckTcpHealthCheck',
    'RegionInstanceGroupManagerAutoHealingPolicies',
    'RegionInstanceGroupManagerNamedPort',
    'RegionInstanceGroupManagerStatefulDisk',
    'RegionInstanceGroupManagerUpdatePolicy',
    'RegionInstanceGroupManagerVersion',
    'RegionInstanceGroupManagerVersionTargetSize',
    'RegionNetworkEndpointGroupAppEngine',
    'RegionNetworkEndpointGroupCloudFunction',
    'RegionNetworkEndpointGroupCloudRun',
    'RegionPerInstanceConfigPreservedState',
    'RegionPerInstanceConfigPreservedStateDisk',
    'RegionUrlMapDefaultUrlRedirect',
    'RegionUrlMapHostRule',
    'RegionUrlMapPathMatcher',
    'RegionUrlMapPathMatcherDefaultUrlRedirect',
    'RegionUrlMapPathMatcherPathRule',
    'RegionUrlMapPathMatcherPathRuleRouteAction',
    'RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapPathMatcherPathRuleRouteActionTimeout',
    'RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherPathRuleUrlRedirect',
    'RegionUrlMapPathMatcherRouteRule',
    'RegionUrlMapPathMatcherRouteRuleHeaderAction',
    'RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleMatchRule',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch',
    'RegionUrlMapPathMatcherRouteRuleRouteAction',
    'RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapPathMatcherRouteRuleRouteActionTimeout',
    'RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleUrlRedirect',
    'RegionUrlMapTest',
    'ReservationSpecificReservation',
    'ReservationSpecificReservationInstanceProperties',
    'ReservationSpecificReservationInstancePropertiesGuestAccelerator',
    'ReservationSpecificReservationInstancePropertiesLocalSsd',
    'ResourcePolicyGroupPlacementPolicy',
    'ResourcePolicySnapshotSchedulePolicy',
    'ResourcePolicySnapshotSchedulePolicyRetentionPolicy',
    'ResourcePolicySnapshotSchedulePolicySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek',
    'ResourcePolicySnapshotSchedulePolicySnapshotProperties',
    'RouterBgp',
    'RouterBgpAdvertisedIpRange',
    'RouterNatLogConfig',
    'RouterNatSubnetwork',
    'RouterPeerAdvertisedIpRange',
    'SecurityPolicyRule',
    'SecurityPolicyRuleMatch',
    'SecurityPolicyRuleMatchConfig',
    'SecurityPolicyRuleMatchExpr',
    'SecurityScanConfigAuthentication',
    'SecurityScanConfigAuthenticationCustomAccount',
    'SecurityScanConfigAuthenticationGoogleAccount',
    'SecurityScanConfigSchedule',
    'SnapshotSnapshotEncryptionKey',
    'SnapshotSourceDiskEncryptionKey',
    'SubnetworkIAMBindingCondition',
    'SubnetworkIAMMemberCondition',
    'SubnetworkLogConfig',
    'SubnetworkSecondaryIpRange',
    'URLMapDefaultRouteAction',
    'URLMapDefaultRouteActionCorsPolicy',
    'URLMapDefaultRouteActionFaultInjectionPolicy',
    'URLMapDefaultRouteActionFaultInjectionPolicyAbort',
    'URLMapDefaultRouteActionFaultInjectionPolicyDelay',
    'URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapDefaultRouteActionRequestMirrorPolicy',
    'URLMapDefaultRouteActionRetryPolicy',
    'URLMapDefaultRouteActionRetryPolicyPerTryTimeout',
    'URLMapDefaultRouteActionTimeout',
    'URLMapDefaultRouteActionUrlRewrite',
    'URLMapDefaultRouteActionWeightedBackendService',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderAction',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapDefaultUrlRedirect',
    'URLMapHeaderAction',
    'URLMapHeaderActionRequestHeadersToAdd',
    'URLMapHeaderActionResponseHeadersToAdd',
    'URLMapHostRule',
    'URLMapPathMatcher',
    'URLMapPathMatcherDefaultRouteAction',
    'URLMapPathMatcherDefaultRouteActionCorsPolicy',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherDefaultRouteActionRetryPolicy',
    'URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherDefaultRouteActionTimeout',
    'URLMapPathMatcherDefaultRouteActionUrlRewrite',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendService',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherDefaultUrlRedirect',
    'URLMapPathMatcherHeaderAction',
    'URLMapPathMatcherHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherPathRule',
    'URLMapPathMatcherPathRuleRouteAction',
    'URLMapPathMatcherPathRuleRouteActionCorsPolicy',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherPathRuleRouteActionRetryPolicy',
    'URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherPathRuleRouteActionTimeout',
    'URLMapPathMatcherPathRuleRouteActionUrlRewrite',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendService',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherPathRuleUrlRedirect',
    'URLMapPathMatcherRouteRule',
    'URLMapPathMatcherRouteRuleHeaderAction',
    'URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherRouteRuleMatchRule',
    'URLMapPathMatcherRouteRuleMatchRuleHeaderMatch',
    'URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch',
    'URLMapPathMatcherRouteRuleMatchRuleMetadataFilter',
    'URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel',
    'URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch',
    'URLMapPathMatcherRouteRuleRouteAction',
    'URLMapPathMatcherRouteRuleRouteActionCorsPolicy',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherRouteRuleRouteActionRetryPolicy',
    'URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherRouteRuleRouteActionTimeout',
    'URLMapPathMatcherRouteRuleRouteActionUrlRewrite',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendService',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherRouteRuleUrlRedirect',
    'URLMapTest',
    'GetBackendBucketCdnPolicy',
    'GetBackendServiceBackend',
    'GetBackendServiceCdnPolicy',
    'GetBackendServiceCdnPolicyCacheKeyPolicy',
    'GetBackendServiceCircuitBreaker',
    'GetBackendServiceCircuitBreakerConnectTimeout',
    'GetBackendServiceConsistentHash',
    'GetBackendServiceConsistentHashHttpCooky',
    'GetBackendServiceConsistentHashHttpCookyTtl',
    'GetBackendServiceIap',
    'GetBackendServiceLogConfig',
    'GetBackendServiceOutlierDetection',
    'GetBackendServiceOutlierDetectionBaseEjectionTime',
    'GetBackendServiceOutlierDetectionInterval',
    'GetInstanceAttachedDisk',
    'GetInstanceBootDisk',
    'GetInstanceBootDiskInitializeParam',
    'GetInstanceConfidentialInstanceConfig',
    'GetInstanceGroupNamedPort',
    'GetInstanceGuestAccelerator',
    'GetInstanceNetworkInterface',
    'GetInstanceNetworkInterfaceAccessConfig',
    'GetInstanceNetworkInterfaceAliasIpRange',
    'GetInstanceScheduling',
    'GetInstanceSchedulingNodeAffinity',
    'GetInstanceScratchDisk',
    'GetInstanceServiceAccount',
    'GetInstanceShieldedInstanceConfig',
    'GetRegionInstanceGroupInstance',
    'GetRegionInstanceGroupInstanceNamedPort',
    'GetRouterBgp',
    'GetRouterBgpAdvertisedIpRange',
    'GetSubnetworkSecondaryIpRange',
]

@pulumi.output_type
class AutoscalarAutoscalingPolicy(dict):
    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[float]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        ...

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.AutoscalarAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.AutoscalarAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> float:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        ...

    @property
    @pulumi.getter
    def metrics(self) -> Optional[List['outputs.AutoscalarAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> float:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Defines operating mode for this policy.
        Default value is `ON`.
        Possible values are `OFF`, `ONLY_UP`, and `ON`.
        """
        ...

    @property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.AutoscalarAutoscalingPolicyScaleDownControl']:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyCpuUtilization(dict):
    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyLoadBalancingUtilization(dict):
    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyMetric(dict):
    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier (type) of the Stackdriver Monitoring metric.
        The metric cannot have negative values.
        The metric must have a value type of INT64 or DOUBLE.
        """
        ...

    @property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        ...

    @property
    @pulumi.getter
    def target(self) -> Optional[float]:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyScaleDownControl(dict):
    @property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[float]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    @property
    @pulumi.getter
    def fixed(self) -> Optional[float]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        ...

    @property
    @pulumi.getter
    def percent(self) -> Optional[float]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicy(dict):
    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[float]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        ...

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.AutoscalerAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.AutoscalerAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> float:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        ...

    @property
    @pulumi.getter
    def metrics(self) -> Optional[List['outputs.AutoscalerAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> float:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Defines operating mode for this policy.
        Default value is `ON`.
        Possible values are `OFF`, `ONLY_UP`, and `ON`.
        """
        ...

    @property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControl']:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyCpuUtilization(dict):
    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyLoadBalancingUtilization(dict):
    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyMetric(dict):
    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier (type) of the Stackdriver Monitoring metric.
        The metric cannot have negative values.
        The metric must have a value type of INT64 or DOUBLE.
        """
        ...

    @property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        ...

    @property
    @pulumi.getter
    def target(self) -> Optional[float]:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleDownControl(dict):
    @property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[float]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    @property
    @pulumi.getter
    def fixed(self) -> Optional[float]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        ...

    @property
    @pulumi.getter
    def percent(self) -> Optional[float]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendBucketCdnPolicy(dict):
    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> float:
        """
        Maximum number of seconds the response to a signed URL request will
        be considered fresh. After this time period,
        the response will be revalidated before being served.
        When serving responses to signed URL requests,
        Cloud CDN will internally behave as though
        all responses from this backend had a "Cache-Control: public,
        max-age=[TTL]" header, regardless of any existing Cache-Control
        header. The actual headers served in responses will not be altered.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceBackend(dict):
    @property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> Optional[str]:
        """
        Specifies the balancing mode for this backend.
        For global HTTP(S) or TCP/SSL load balancing, the default is
        UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
        and CONNECTION (for TCP/SSL).
        Default value is `UTILIZATION`.
        Possible values are `UTILIZATION`, `RATE`, and `CONNECTION`.
        """
        ...

    @property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> Optional[float]:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).
        Default value is 1, which means the group will serve up to 100%
        of its configured capacity (depending on balancingMode). A
        setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this resource.
        Provide this property when you create the resource.
        """
        ...

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.
        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.
        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.
        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        ...

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[float]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> Optional[float]:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.
        For CONNECTION mode, either
        maxConnections or maxConnectionsPerEndpoint must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> Optional[float]:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> Optional[float]:
        """
        The max requests per second (RPS) of the group.
        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. For RATE mode, either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[float]:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. The default is 0.8. Valid
        range is [0.0, 1.0].
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCdnPolicy(dict):
    @property
    @pulumi.getter(name="cacheKeyPolicy")
    def cache_key_policy(self) -> Optional['outputs.BackendServiceCdnPolicyCacheKeyPolicy']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> Optional[float]:
        """
        Maximum number of seconds the response to a signed URL request
        will be considered fresh, defaults to 1hr (3600s). After this
        time period, the response will be revalidated before
        being served.
        When serving responses to signed URL requests, Cloud CDN will
        internally behave as though all responses from this backend had a
        "Cache-Control: public, max-age=[TTL]" header, regardless of any
        existing Cache-Control header. The actual headers served in
        responses will not be altered.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCdnPolicyCacheKeyPolicy(dict):
    @property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> Optional[bool]:
        """
        If true requests to different hosts will be cached separately.
        """
        ...

    @property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> Optional[bool]:
        """
        If true, http and https requests will be cached separately.
        """
        ...

    @property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> Optional[bool]:
        """
        If true, include query string parameters in the cache key
        according to query_string_whitelist and
        query_string_blacklist. If neither is set, the entire query
        string will be included.
        If false, the query string will be excluded from the cache
        key entirely.
        """
        ...

    @property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Optional[List[str]]:
        """
        Names of query string parameters to exclude in cache keys.
        All other parameters will be included. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        ...

    @property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Optional[List[str]]:
        """
        Names of query string parameters to include in cache keys.
        All other parameters will be excluded. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCircuitBreakers(dict):
    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional['outputs.BackendServiceCircuitBreakersConnectTimeout']:
        """
        The timeout for new network connections to hosts.  Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[float]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[float]:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> Optional[float]:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[float]:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        ...

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[float]:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCircuitBreakersConnectTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceConsistentHash(dict):
    @property
    @pulumi.getter(name="httpCookie")
    def http_cookie(self) -> Optional['outputs.BackendServiceConsistentHashHttpCookie']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> Optional[str]:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        ...

    @property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> Optional[float]:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceConsistentHashHttpCookie(dict):
    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cookie.
        """
        ...

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to set for the cookie.
        """
        ...

    @property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.BackendServiceConsistentHashHttpCookieTtl']:
        """
        Lifetime of the cookie.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceConsistentHashHttpCookieTtl(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceIap(dict):
    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> str:
        """
        OAuth2 Client ID for IAP
        """
        ...

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> str:
        """
        OAuth2 Client Secret for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    @property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> Optional[str]:
        """
        -
        OAuth2 Client Secret SHA-256 for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceLogConfig(dict):
    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        ...

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceOutlierDetection(dict):
    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional['outputs.BackendServiceOutlierDetectionBaseEjectionTime']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[float]:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        ...

    @property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> Optional[float]:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        ...

    @property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> Optional[float]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        ...

    @property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> Optional[float]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        ...

    @property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> Optional[float]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        ...

    @property
    @pulumi.getter
    def interval(self) -> Optional['outputs.BackendServiceOutlierDetectionInterval']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[float]:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        ...

    @property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> Optional[float]:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        ...

    @property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> Optional[float]:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        ...

    @property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> Optional[float]:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceOutlierDetectionBaseEjectionTime(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceOutlierDetectionInterval(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskDiskEncryptionKey(dict):
    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        ...

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        ...

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskSourceImageEncryptionKey(dict):
    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        ...

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        ...

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskSourceSnapshotEncryptionKey(dict):
    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        ...

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        ...

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ExternalVpnGatewayInterface(dict):
    @property
    @pulumi.getter
    def id(self) -> Optional[float]:
        """
        The numberic ID for this interface. Allowed values are based on the redundancy type
        of this external VPN gateway
        * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
        * `0, 1 - TWO_IPS_REDUNDANCY`
        * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
        """
        ...

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        IP address of the interface in the external VPN gateway.
        Only IPv4 is supported. This IP address can be either from
        your on-premise gateway or another Cloud provider's VPN gateway,
        it cannot be an IP address from Google Compute Engine.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FirewallAllow(dict):
    @property
    @pulumi.getter
    def ports(self) -> Optional[List[str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        ...

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol type is
        required when creating a firewall rule. This value can either be
        one of the following well known protocol strings (tcp, udp,
        icmp, esp, ah, sctp, ipip), or the IP protocol number.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FirewallDeny(dict):
    @property
    @pulumi.getter
    def ports(self) -> Optional[List[str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        ...

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol type is
        required when creating a firewall rule. This value can either be
        one of the following well known protocol strings (tcp, udp,
        icmp, esp, ah, sctp, ipip), or the IP protocol number.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FirewallLogConfig(dict):
    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        This field denotes whether to include or exclude metadata for firewall logs.
        Possible values are `EXCLUDE_ALL_METADATA` and `INCLUDE_ALL_METADATA`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalForwardingRuleMetadataFilter(dict):
    @property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> List['outputs.GlobalForwardingRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the
        provided metadata based on filterMatchCriteria
        This list must not be empty and can have at the most 64 entries.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> str:
        """
        Specifies how individual filterLabel matches within the list of
        filterLabels contribute towards the overall metadataFilter match.
        MATCH_ANY - At least one of the filterLabels must have a matching
        label in the provided metadata.
        MATCH_ALL - All filterLabels must have matching labels in the
        provided metadata.
        Possible values are `MATCH_ANY` and `MATCH_ALL`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalForwardingRuleMetadataFilterFilterLabel(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the metadata label. The length must be between
        1 and 1024 characters, inclusive.
        """
        ...

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that the label must match. The value has a maximum
        length of 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HaVpnGatewayVpnInterface(dict):
    @property
    @pulumi.getter
    def id(self) -> Optional[float]:
        """
        an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
        """
        ...

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckHttp2HealthCheck(dict):
    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckHttpHealthCheck(dict):
    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckHttpsHealthCheck(dict):
    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckLogConfig(dict):
    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Indicates whether or not to export logs. This is false by default,
        which means no health check logging will be done.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckSslHealthCheck(dict):
    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckTcpHealthCheck(dict):
    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImageGuestOsFeature(dict):
    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        Possible values are `MULTI_IP_SUBNET`, `SECURE_BOOT`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, and `WINDOWS`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImageRawDisk(dict):
    @property
    @pulumi.getter(name="containerType")
    def container_type(self) -> Optional[str]:
        """
        The format used to encode and transmit the block device, which
        should be TAR. This is just a container and transmission format
        and not a runtime format. Provided by the client when the disk
        image is created.
        Default value is `TAR`.
        Possible values are `TAR`.
        """
        ...

    @property
    @pulumi.getter
    def sha1(self) -> Optional[str]:
        """
        An optional SHA1 checksum of the disk image before unpackaging.
        This is provided by the client when the disk image is created.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The full Google Cloud Storage URL where disk storage is stored
        You must provide either this property or the sourceDisk property
        but not both.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceAttachedDisk(dict):
    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name with which the attached disk will be accessible
        under `/dev/disk/by-id/google-*`
        """
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        """
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
        and `disk_encryption_key_raw` may be set.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
        If you have a persistent disk with data that you want to share
        between multiple instances, detach it from any read-write instances and
        attach it to one or more instances in read-only mode.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The name or self_link of the disk to attach to this instance.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceBootDisk(dict):
    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        """
        Whether the disk will be auto-deleted when the instance
        is deleted. Defaults to true.
        """
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name with which the attached disk will be accessible
        under `/dev/disk/by-id/google-*`
        """
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        """
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceBootDiskInitializeParams']:
        """
        Parameters for a new disk that will be created
        alongside the new instance. Either `initialize_params` or `source` must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
        and `disk_encryption_key_raw` may be set.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
        If you have a persistent disk with data that you want to share
        between multiple instances, detach it from any read-write instances and
        attach it to one or more instances in read-only mode.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The name or self_link of the disk to attach to this instance.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceBootDiskInitializeParams(dict):
    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image from which to initialize this disk. This can be
        one of: the image's `self_link`, `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
        images names must include the family name. If they don't, use the
        [compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
        For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
        These images can be referred by family name here.
        """
        ...

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        A map of key/value label pairs to assign to the instance.
        """
        ...

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        """
        The size of the image in gigabytes. If not specified, it
        will inherit the size of its base image.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceConfidentialInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateAttachedDisk(dict):
    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def source(self) -> str:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateBootDisk(dict):
    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceFromTemplateBootDiskInitializeParams']:
        ...

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateBootDiskInitializeParams(dict):
    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        ...

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        ...

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateConfidentialInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateGuestAccelerator(dict):
    @property
    @pulumi.getter
    def count(self) -> float:
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateNetworkInterface(dict):
    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[List['outputs.InstanceFromTemplateNetworkInterfaceAccessConfig']]:
        ...

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[List['outputs.InstanceFromTemplateNetworkInterfaceAliasIpRange']]:
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        ...

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateNetworkInterfaceAccessConfig(dict):
    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateNetworkInterfaceAliasIpRange(dict):
    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        ...

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateScheduling(dict):
    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[bool]:
        ...

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[float]:
        ...

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[List['outputs.InstanceFromTemplateSchedulingNodeAffinity']]:
        ...

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateSchedulingNodeAffinity(dict):
    @property
    @pulumi.getter
    def key(self) -> str:
        ...

    @property
    @pulumi.getter
    def operator(self) -> str:
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateScratchDisk(dict):
    @property
    @pulumi.getter
    def interface(self) -> str:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateServiceAccount(dict):
    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        ...

    @property
    @pulumi.getter
    def scopes(self) -> List[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateShieldedInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[bool]:
        ...

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[bool]:
        ...

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[bool]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerAutoHealingPolicies(dict):
    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> str:
        """
        The health check resource that signals autohealing.
        """
        ...

    @property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> float:
        """
        The number of seconds that the managed instance group waits before
        it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerNamedPort(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Version name.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port number.
        - - -
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerStatefulDisk(dict):
    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` detatch the disk when the VM is deleted, but not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        , The device name of the disk to be attached.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerUpdatePolicy(dict):
    @property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> Optional[float]:
        """
        , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. If neither is set, defaults to 1
        """
        ...

    @property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> Optional[float]:
        """
        , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`.
        """
        ...

    @property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> Optional[float]:
        """
        , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. If neither is set, defaults to 1
        """
        ...

    @property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> Optional[float]:
        """
        , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`.
        """
        ...

    @property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> Optional[float]:
        """
        , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        - - -
        """
        ...

    @property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> str:
        """
        - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerVersion(dict):
    @property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> str:
        """
        - The full URL to an instance template from which all new instances of this version will be created.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - Version name.
        """
        ...

    @property
    @pulumi.getter(name="targetSize")
    def target_size(self) -> Optional['outputs.InstanceGroupManagerVersionTargetSize']:
        """
        - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerVersionTargetSize(dict):
    @property
    @pulumi.getter
    def fixed(self) -> Optional[float]:
        """
        , The number of instances which are managed for this version. Conflicts with `percent`.
        """
        ...

    @property
    @pulumi.getter
    def percent(self) -> Optional[float]:
        """
        , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
        Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
        one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupNamedPort(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which the port will be mapped to.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port number to map the name to.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGuestAccelerator(dict):
    @property
    @pulumi.getter
    def count(self) -> float:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceIAMBindingCondition(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        ...

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        ...

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceIAMMemberCondition(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        ...

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        ...

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[List['outputs.InstanceNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Omit to ensure that the instance
        is not accessible from the Internet. If omitted, ssh will not
        work unless this provider can send traffic to the instance's network (e.g. via
        tunnel or because it is running on another cloud instance on that network).
        This block can be repeated multiple times. Structure documented below.
        """
        ...

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[List['outputs.InstanceNetworkInterfaceAliasIpRange']]:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        ...

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        The name or self_link of the network to attach this interface to.
        Either `network` or `subnetwork` must be provided.
        """
        ...

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        ...

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[str]:
        """
        The name or self_link of the subnetwork to attach this
        interface to. The subnetwork must exist in the same region this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        ...

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[str]:
        """
        The project in which the subnetwork belongs.
        If the `subnetwork` is a self_link, this field is ignored in favor of the project
        defined in the subnetwork self_link. If the `subnetwork` is a name and this
        field is not provided, the provider project is used.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceNetworkInterfaceAccessConfig(dict):
    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[str]:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        ...

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[str]:
        """
        The [networking tier][network-tier] used for configuring this instance.
        This field can take the following values: PREMIUM or STANDARD. If this field is
        not specified, it is assumed to be PREMIUM.
        """
        ...

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[str]:
        """
        The DNS domain name for the public PTR record.
        To set this field on an instance, you must be verified as the owner of the domain.
        See [the docs](https://cloud.google.com/compute/docs/instances/create-ptr-record) for how
        to become verified as a domain owner.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceNetworkInterfaceAliasIpRange(dict):
    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. This range may be a single IP address
        (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
        """
        ...

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[str]:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceScheduling(dict):
    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[bool]:
        """
        Specifies if the instance should be
        restarted if it was terminated by Compute Engine (not a user).
        Defaults to true.
        """
        ...

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[float]:
        ...

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[List['outputs.InstanceSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        ...

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[str]:
        """
        Describes maintenance behavior for the
        instance. Can be MIGRATE or TERMINATE, for more info, read
        [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
        """
        ...

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Specifies if the instance is preemptible.
        If this field is set to true, then `automatic_restart` must be
        set to false.  Defaults to false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceSchedulingNodeAffinity(dict):
    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key for the node affinity label.
        """
        ...

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceScratchDisk(dict):
    @property
    @pulumi.getter
    def interface(self) -> str:
        """
        The disk interface to use for attaching this disk; either SCSI or NVME.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceServiceAccount(dict):
    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        ...

    @property
    @pulumi.getter
    def scopes(self) -> List[str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceShieldedInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[bool]:
        """
        -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        """
        ...

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[bool]:
        """
        -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[bool]:
        """
        -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateConfidentialInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateDisk(dict):
    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        """
        Whether or not the disk should be auto-deleted.
        This defaults to true.
        """
        ...

    @property
    @pulumi.getter
    def boot(self) -> Optional[bool]:
        """
        Indicates that this is a boot disk.
        """
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        A unique device name that is reflected into the
        /dev/  tree of a Linux operating system running within the instance. If not
        specified, the server chooses a default device name to apply to this disk.
        """
        ...

    @property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional['outputs.InstanceTemplateDiskDiskEncryptionKey']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.
        """
        ...

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> Optional[str]:
        """
        Name of the disk. When not provided, this defaults
        to the name of the instance.
        """
        ...

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[float]:
        """
        The size of the image in gigabytes. If not
        specified, it will inherit the size of its base image. For SCRATCH disks,
        the size must be exactly 375GB.
        """
        ...

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[str]:
        """
        The GCE disk type. Can be either `"pd-ssd"`,
        `"local-ssd"`, or `"pd-standard"`.
        """
        ...

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        Specifies the disk interface to use for attaching
        this disk.
        """
        ...

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A set of key/value label pairs to assign to instances
        created from this template,
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode in which to attach this disk, either READ_WRITE
        or READ_ONLY. If you are attaching or creating a boot disk, this must
        read-write mode.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The name (**not self_link**)
        of the disk (such as those managed by `compute.Disk`) to attach.
        > **Note:** Either `source` or `source_image` is **required** when creating a new instance except for when creating a local SSD. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        ...

    @property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[str]:
        """
        The image from which to
        initialize this disk. This can be one of: the image's `self_link`,
        `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`.
        > **Note:** Either `source` or `source_image` is **required** when creating a new instance except for when creating a local SSD. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateDiskDiskEncryptionKey(dict):
    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateGuestAccelerator(dict):
    @property
    @pulumi.getter
    def count(self) -> float:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateNetworkInterface(dict):
    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[List['outputs.InstanceTemplateNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Omit to ensure that the instance
        is not accessible from the Internet (this means that ssh provisioners will
        not work unless you can send traffic to the instance's
        network (e.g. via tunnel or because it is running on another cloud instance
        on that network). This block can be repeated multiple times. Structure documented below.
        """
        ...

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[List['outputs.InstanceTemplateNetworkInterfaceAliasIpRange']]:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the instance template. If you leave
        this blank, the provider will auto-generate a unique name.
        """
        ...

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        The name or self_link of the network to attach this interface to.
        Use `network` attribute for Legacy or Auto subnetted networks and
        `subnetwork` for custom subnetted networks.
        """
        ...

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        ...

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[str]:
        """
        the name of the subnetwork to attach this interface
        to. The subnetwork must exist in the same `region` this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        ...

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[str]:
        """
        The ID of the project in which the subnetwork belongs.
        If it is not provided, the provider project is used.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateNetworkInterfaceAccessConfig(dict):
    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[str]:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        ...

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[str]:
        """
        The [networking tier][network-tier] used for configuring
        this instance template. This field can take the following values: PREMIUM or
        STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        ...

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateNetworkInterfaceAliasIpRange(dict):
    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. At the time of writing only a
        netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
        error.
        """
        ...

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[str]:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateScheduling(dict):
    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[bool]:
        """
        Specifies whether the instance should be
        automatically restarted if it is terminated by Compute Engine (not
        terminated by a user). This defaults to true.
        """
        ...

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[float]:
        ...

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[List['outputs.InstanceTemplateSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        ...

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[str]:
        """
        Defines the maintenance behavior for this
        instance.
        """
        ...

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Allows instance to be preempted. This defaults to
        false. Read more on this
        [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateSchedulingNodeAffinity(dict):
    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key for the node affinity label.
        """
        ...

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateServiceAccount(dict):
    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        """
        ...

    @property
    @pulumi.getter
    def scopes(self) -> List[str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateShieldedInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[bool]:
        """
        -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        """
        ...

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[bool]:
        """
        -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[bool]:
        """
        -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InterconnectAttachmentPrivateInterconnectInfo(dict):
    @property
    @pulumi.getter
    def tag8021q(self) -> Optional[float]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedSslCertificateManaged(dict):
    @property
    @pulumi.getter
    def domains(self) -> List[str]:
        """
        Domains for which a managed SSL certificate will be valid.  Currently,
        there can be up to 100 domains in this list.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MangedSslCertificateManaged(dict):
    @property
    @pulumi.getter
    def domains(self) -> List[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NodeGroupAutoscalingPolicy(dict):
    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[float]:
        """
        Maximum size of the node group. Set to a value less than or equal
        to 100 and greater than or equal to min-nodes.
        """
        ...

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[float]:
        """
        Minimum size of the node group. Must be less
        than or equal to max-nodes. The default value is 0.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The autoscaling mode. Set to one of the following:
        - OFF: Disables the autoscaler.
        - ON: Enables scaling in and scaling out.
        - ONLY_SCALE_OUT: Enables only scaling out.
        You must use this mode if your node groups are configured to
        restart their hosted VMs on minimal servers.
        Possible values are `OFF`, `ON`, and `ONLY_SCALE_OUT`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NodeTemplateNodeTypeFlexibility(dict):
    @property
    @pulumi.getter
    def cpus(self) -> Optional[str]:
        """
        Number of virtual CPUs to use.
        """
        ...

    @property
    @pulumi.getter(name="localSsd")
    def local_ssd(self) -> Optional[str]:
        """
        -
        Use local SSD
        """
        ...

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        Physical memory available to the node, defined in MB.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NodeTemplateServerBinding(dict):
    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
        nodes using this template will restart on any physical server
        following a maintenance event.
        If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
        will restart on the same physical server following a maintenance
        event, instead of being live migrated to or restarted on a new
        physical server. This option may be useful if you are using
        software licenses tied to the underlying server characteristics
        such as physical sockets or cores, to avoid the need for
        additional licenses when maintenance occurs. However, VMs on such
        nodes will experience outages while maintenance is applied.
        Possible values are `RESTART_NODE_ON_ANY_SERVER` and `RESTART_NODE_ON_MINIMAL_SERVERS`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatch(dict):
    @property
    @pulumi.getter
    def config(self) -> 'outputs.OrganizationSecurityPolicyRuleMatchConfig':
        """
        The configuration options for matching the rule.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the rule.
        """
        ...

    @property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> Optional[str]:
        """
        Preconfigured versioned expression. For organization security policy rules,
        the only supported type is "FIREWALL".
        Default value is `FIREWALL`.
        Possible values are `FIREWALL`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatchConfig(dict):
    @property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[List[str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        ...

    @property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> List['outputs.OrganizationSecurityPolicyRuleMatchConfigLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[List[str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatchConfigLayer4Config(dict):
    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        ...

    @property
    @pulumi.getter
    def ports(self) -> Optional[List[str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringCollectorIlb(dict):
    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringFilter(dict):
    @property
    @pulumi.getter(name="cidrRanges")
    def cidr_ranges(self) -> Optional[List[str]]:
        """
        IP CIDR ranges that apply as a filter on the source (ingress) or
        destination (egress) IP in the IP header. Only IPv4 is supported.
        """
        ...

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[List[str]]:
        """
        Protocols that apply as a filter on mirrored traffic.
        Each value may be one of `tcp`, `udp`, and `icmp`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringMirroredResources(dict):
    @property
    @pulumi.getter
    def instances(self) -> Optional[List['outputs.PacketMirroringMirroredResourcesInstance']]:
        """
        All the listed instances will be mirrored.  Specify at most 50.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def subnetworks(self) -> Optional[List['outputs.PacketMirroringMirroredResourcesSubnetwork']]:
        """
        All instances in one of these subnetworks will be mirrored.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def tags(self) -> Optional[List[str]]:
        """
        All instances with these tags will be mirrored.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringMirroredResourcesInstance(dict):
    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringMirroredResourcesSubnetwork(dict):
    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringNetwork(dict):
    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PerInstanceConfigPreservedState(dict):
    @property
    @pulumi.getter
    def disks(self) -> Optional[List['outputs.PerInstanceConfigPreservedStateDisk']]:
        """
        Stateful disks for the instance.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PerInstanceConfigPreservedStateDisk(dict):
    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
        The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        `NEVER` detatch the disk when the VM is deleted, but not delete the disk.
        `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
        deleted from the instance group.
        Default value is `NEVER`.
        Possible values are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        """
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode of the disk.
        Default value is `READ_WRITE`.
        Possible values are `READ_ONLY` and `READ_WRITE`.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The URI of an existing persistent disk to attach under the specified device-name in the format
        `projects/project-id/zones/zone/disks/disk-name`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicy(dict):
    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[float]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        ...

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> float:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        ...

    @property
    @pulumi.getter
    def metrics(self) -> Optional[List['outputs.RegionAutoscalerAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> float:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Defines operating mode for this policy.
        Default value is `ON`.
        Possible values are `OFF`, `ONLY_UP`, and `ON`.
        """
        ...

    @property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControl']:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyCpuUtilization(dict):
    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization(dict):
    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyMetric(dict):
    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier (type) of the Stackdriver Monitoring metric.
        The metric cannot have negative values.
        The metric must have a value type of INT64 or DOUBLE.
        """
        ...

    @property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        ...

    @property
    @pulumi.getter
    def target(self) -> Optional[float]:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleDownControl(dict):
    @property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[float]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    @property
    @pulumi.getter
    def fixed(self) -> Optional[float]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        ...

    @property
    @pulumi.getter
    def percent(self) -> Optional[float]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceBackend(dict):
    @property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> Optional[str]:
        """
        Specifies the balancing mode for this backend.
        Default value is `CONNECTION`.
        Possible values are `UTILIZATION`, `RATE`, and `CONNECTION`.
        """
        ...

    @property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> Optional[float]:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).
        ~>**NOTE**: This field cannot be set for
        INTERNAL region backend services (default loadBalancingScheme),
        but is required for non-INTERNAL backend service. The total
        capacity_scaler for all backends must be non-zero.
        A setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this resource.
        Provide this property when you create the resource.
        """
        ...

    @property
    @pulumi.getter
    def failover(self) -> Optional[bool]:
        """
        This field designates whether this is a failover backend. More
        than one failover backend can be configured for a given RegionBackendService.
        """
        ...

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.
        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.
        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.
        When the `load_balancing_scheme` is INTERNAL, only instance groups
        are supported.
        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        ...

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[float]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> Optional[float]:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. Cannot be set
        for INTERNAL backend services.
        This is used to calculate the capacity of the group. Can be
        used in either CONNECTION or UTILIZATION balancing modes. For
        CONNECTION mode, either maxConnections or
        maxConnectionsPerEndpoint must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> Optional[float]:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. Cannot be set for INTERNAL backend
        services.
        This is used to calculate the capacity of the group.
        Can be used in either CONNECTION or UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> Optional[float]:
        """
        The max requests per second (RPS) of the group. Cannot be set
        for INTERNAL backend services.
        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. Either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        ...

    @property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set. Cannot be set
        for INTERNAL backend services.
        """
        ...

    @property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set. Cannot be set
        for INTERNAL backend services.
        """
        ...

    @property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[float]:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. Valid range is [0.0, 1.0].
        Cannot be set for INTERNAL backend services.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceCircuitBreakers(dict):
    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional['outputs.RegionBackendServiceCircuitBreakersConnectTimeout']:
        """
        The timeout for new network connections to hosts.  Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[float]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[float]:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> Optional[float]:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        ...

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[float]:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        ...

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[float]:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceCircuitBreakersConnectTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceConsistentHash(dict):
    @property
    @pulumi.getter(name="httpCookie")
    def http_cookie(self) -> Optional['outputs.RegionBackendServiceConsistentHashHttpCookie']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> Optional[str]:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        ...

    @property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> Optional[float]:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceConsistentHashHttpCookie(dict):
    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cookie.
        """
        ...

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to set for the cookie.
        """
        ...

    @property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.RegionBackendServiceConsistentHashHttpCookieTtl']:
        """
        Lifetime of the cookie.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceConsistentHashHttpCookieTtl(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceFailoverPolicy(dict):
    @property
    @pulumi.getter(name="disableConnectionDrainOnFailover")
    def disable_connection_drain_on_failover(self) -> Optional[bool]:
        """
        On failover or failback, this field indicates whether connection drain
        will be honored. Setting this to true has the following effect: connections
        to the old active pool are not drained. Connections to the new active pool
        use the timeout of 10 min (currently fixed). Setting to false has the
        following effect: both old and new connections will have a drain timeout
        of 10 min.
        This can be set to true only if the protocol is TCP.
        The default is false.
        """
        ...

    @property
    @pulumi.getter(name="dropTrafficIfUnhealthy")
    def drop_traffic_if_unhealthy(self) -> Optional[bool]:
        """
        This option is used only when no healthy VMs are detected in the primary
        and backup instance groups. When set to true, traffic is dropped. When
        set to false, new connections are sent across all VMs in the primary group.
        The default is false.
        """
        ...

    @property
    @pulumi.getter(name="failoverRatio")
    def failover_ratio(self) -> Optional[float]:
        """
        The value of the field must be in [0, 1]. If the ratio of the healthy
        VMs in the primary backend is at or below this number, traffic arriving
        at the load-balanced IP will be directed to the failover backend.
        In case where 'failoverRatio' is not set or all the VMs in the backup
        backend are unhealthy, the traffic will be directed back to the primary
        backend in the "force" mode, where traffic will be spread to the healthy
        VMs with the best effort, or to all VMs when no VM is healthy.
        This field is only used with l4 load balancing.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceLogConfig(dict):
    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        ...

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceOutlierDetection(dict):
    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional['outputs.RegionBackendServiceOutlierDetectionBaseEjectionTime']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[float]:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        ...

    @property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> Optional[float]:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        ...

    @property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> Optional[float]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        ...

    @property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> Optional[float]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        ...

    @property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> Optional[float]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        ...

    @property
    @pulumi.getter
    def interval(self) -> Optional['outputs.RegionBackendServiceOutlierDetectionInterval']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[float]:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        ...

    @property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> Optional[float]:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        ...

    @property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> Optional[float]:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        ...

    @property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> Optional[float]:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceOutlierDetectionBaseEjectionTime(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceOutlierDetectionInterval(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionDiskDiskEncryptionKey(dict):
    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        ...

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        ...

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionDiskSourceSnapshotEncryptionKey(dict):
    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        ...

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        ...

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckHttp2HealthCheck(dict):
    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckHttpHealthCheck(dict):
    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckHttpsHealthCheck(dict):
    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckLogConfig(dict):
    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Indicates whether or not to export logs. This is false by default,
        which means no health check logging will be done.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckSslHealthCheck(dict):
    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckTcpHealthCheck(dict):
    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        ...

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        ...

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        ...

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        ...

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        ...

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerAutoHealingPolicies(dict):
    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> str:
        """
        The health check resource that signals autohealing.
        """
        ...

    @property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> float:
        """
        The number of seconds that the managed instance group waits before
        it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerNamedPort(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Version name.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        The port number.
        - - -
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerStatefulDisk(dict):
    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` detatch the disk when the VM is deleted, but not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        , The device name of the disk to be attached.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerUpdatePolicy(dict):
    @property
    @pulumi.getter(name="instanceRedistributionType")
    def instance_redistribution_type(self) -> Optional[str]:
        """
        - The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
        """
        ...

    @property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> Optional[float]:
        """
        , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. It has to be either 0 or at least equal to the number of zones.  If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        """
        ...

    @property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> Optional[float]:
        """
        , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        """
        ...

    @property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> Optional[float]:
        """
        , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. It has to be either 0 or at least equal to the number of zones. If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        """
        ...

    @property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> Optional[float]:
        """
        , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        """
        ...

    @property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> Optional[float]:
        """
        , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        - - -
        """
        ...

    @property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> str:
        """
        - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerVersion(dict):
    @property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> str:
        """
        - The full URL to an instance template from which all new instances of this version will be created.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - Version name.
        """
        ...

    @property
    @pulumi.getter(name="targetSize")
    def target_size(self) -> Optional['outputs.RegionInstanceGroupManagerVersionTargetSize']:
        """
        - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerVersionTargetSize(dict):
    @property
    @pulumi.getter
    def fixed(self) -> Optional[float]:
        """
        , The number of instances which are managed for this version. Conflicts with `percent`.
        """
        ...

    @property
    @pulumi.getter
    def percent(self) -> Optional[float]:
        """
        , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
        Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
        one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionNetworkEndpointGroupAppEngine(dict):
    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Optional serving service.
        The service name must be 1-63 characters long, and comply with RFC1035.
        Example value: "default", "my-service".
        """
        ...

    @property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[str]:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.
        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        ...

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Optional serving version.
        The version must be 1-63 characters long, and comply with RFC1035.
        Example value: "v1", "v2".
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionNetworkEndpointGroupCloudFunction(dict):
    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        """
        A user-defined name of the Cloud Function.
        The function name is case-sensitive and must be 1-63 characters long.
        Example value: "func1".
        """
        ...

    @property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[str]:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.
        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionNetworkEndpointGroupCloudRun(dict):
    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Optional serving service.
        The service name must be 1-63 characters long, and comply with RFC1035.
        Example value: "default", "my-service".
        """
        ...

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Cloud Run tag represents the "named-revision" to provide
        additional fine-grained traffic routing information.
        The tag must be 1-63 characters long, and comply with RFC1035.
        Example value: "revision-0010".
        """
        ...

    @property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[str]:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.
        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionPerInstanceConfigPreservedState(dict):
    @property
    @pulumi.getter
    def disks(self) -> Optional[List['outputs.RegionPerInstanceConfigPreservedStateDisk']]:
        """
        Stateful disks for the instance.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionPerInstanceConfigPreservedStateDisk(dict):
    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
        The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        `NEVER` detatch the disk when the VM is deleted, but not delete the disk.
        `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
        deleted from the instance group.
        Default value is `NEVER`.
        Possible values are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        """
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        """
        ...

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode of the disk.
        Default value is `READ_WRITE`.
        Possible values are `READ_ONLY` and `READ_WRITE`.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The URI of an existing persistent disk to attach under the specified device-name in the format
        `projects/project-id/zones/zone/disks/disk-name`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapDefaultUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapHostRule(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        ...

    @property
    @pulumi.getter
    def hosts(self) -> List[str]:
        """
        The list of host patterns to match. They must be valid
        hostnames, except * will match any string of ([a-z0-9-.]*). In
        that case, * must be the first character and must be followed in
        the pattern by either - or ..
        """
        ...

    @property
    @pulumi.getter(name="pathMatcher")
    def path_matcher(self) -> str:
        """
        The name of the PathMatcher to use to match the path portion of
        the URL if the hostRule matches the URL's host portion.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcher(dict):
    @property
    @pulumi.getter(name="defaultService")
    def default_service(self) -> str:
        """
        A reference to a RegionBackendService resource. This will be used if
        none of the pathRules defined by this PathMatcher is matched by
        the URL's path portion.
        """
        ...

    @property
    @pulumi.getter(name="defaultUrlRedirect")
    def default_url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultUrlRedirect']:
        """
        When none of the specified hostRules match, the request is redirected to a URL specified
        by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
        defaultRouteAction must not be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        ...

    @property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Optional[List['outputs.RegionUrlMapPathMatcherPathRule']]:
        """
        The list of path rules. Use this list instead of routeRules when routing based
        on simple path matching is all that's required. The order by which path rules
        are specified does not matter. Matches are always done on the longest-path-first
        basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        irrespective of the order in which those paths appear in this list. Within a
        given pathMatcher, only one of pathRules or routeRules must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="routeRules")
    def route_rules(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRule']]:
        """
        The list of ordered HTTP route rules. Use this list instead of pathRules when
        advanced route matching and routing actions are desired. The order of specifying
        routeRules matters: the first rule that matches will cause its specified routing
        action to take effect. Within a given pathMatcher, only one of pathRules or
        routeRules must be set. routeRules are not supported in UrlMaps intended for
        External load balancers.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRule(dict):
    @property
    @pulumi.getter
    def paths(self) -> List[str]:
        """
        The list of path patterns to match. Each must start with / and the only place a
        * is allowed is at the end following a /. The string fed to the path matcher
        does not include any text after the first ? or #, and those chars are not
        allowed here.
        """
        ...

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteAction']:
        """
        In response to a matching path, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        A reference to expected RegionBackendService resource the given URL should be mapped to.
        """
        ...

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleUrlRedirect']:
        """
        When a path pattern is matched, the request is redirected to a URL specified
        by urlRedirect. If urlRedirect is specified, service or routeAction must not
        be set.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteAction(dict):
    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[List['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy(dict):
    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the
        actual request can include user credentials. This translates to the Access-
        Control-Allow-Credentials header. Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        ...

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[List[str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For
        regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        ...

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[List[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests. An
        origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        ...

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        If true, specifies the CORS policy is disabled.
        """
        ...

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        Specifies how long the results of a preflight request can be cached. This
        translates to the content for the Access-Control-Max-Age header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy(dict):
    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault
        injection.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault
        injection, before being sent to a backend service.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(dict):
    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> float:
        """
        The HTTP status code used to abort the request. The value must be between 200
        and 599 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(dict):
    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> 'outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay':
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy(dict):
    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[float]:
        """
        Specifies the allowed number retries. This number must be > 0.
        """
        ...

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[List[str]]:
        """
        Specifies one or more conditions when this retry rule applies. Valid values are:
        - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        any 5xx response code, or if the backend service does not respond at all,
        example: disconnects, reset, read timeout, connection failure, and refused
        streams.
        - gateway-error: Similar to 5xx, but only applies to response codes
        502, 503 or 504.
        - connect-failure: Loadbalancer will retry on failures
        connecting to backend services, for example due to connection timeouts.
        - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled: Loadbalancer will retry if the gRPC status code in the response
        header is set to cancelled
        - deadline-exceeded: Loadbalancer will retry if the
        gRPC status code in the response header is set to deadline-exceeded
        - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        header is set to resource-exhausted
        - unavailable: Loadbalancer will retry if
        the gRPC status code in the response header is set to unavailable
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite(dict):
    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host
        header is replaced with contents of hostRewrite. The value must be between 1 and
        255 characters.
        """
        ...

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching
        portion of the request's path is replaced by pathPrefixRewrite. The value must
        be between 1 and 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        ...

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. headerAction specified here take effect before
        headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        Specifies the fraction of traffic sent to backendService, computed as weight /
        (sum of all weightedBackendService weights in routeAction) . The selection of a
        backend service is determined only for new traffic. Once a user's request has
        been directed to a backendService, subsequent requests will be sent to the same
        backendService as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the
        backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request
        prior to forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response
        prior to sending the response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRule(dict):
    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. headerAction specified here take effect before
        headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleMatchRule']]:
        """
        The rules for determining a match.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        For routeRules within a given pathMatcher, priority determines the order
        in which load balancer will interpret routeRules. RouteRules are evaluated
        in order of priority, from the lowest to highest number. The priority of
        a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        that matches the request is applied.
        You cannot configure two or more routeRules with the same priority.
        Priority for each rule must be set to a number between 0 and
        2147483647 inclusive.
        Priority numbers can have gaps, which enable you to add or remove rules
        in the future without affecting the rest of the rules. For example,
        1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        future without any impact on existing rules.
        """
        ...

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteAction']:
        """
        In response to a matching path, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        A reference to expected RegionBackendService resource the given URL should be mapped to.
        """
        ...

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleUrlRedirect']:
        """
        When a path pattern is matched, the request is redirected to a URL specified
        by urlRedirect. If urlRedirect is specified, service or routeAction must not
        be set.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the
        backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request
        prior to forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response
        prior to sending the response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRule(dict):
    @property
    @pulumi.getter(name="fullPathMatch")
    def full_path_match(self) -> Optional[str]:
        """
        For satifying the matchRule condition, the path of the request must exactly
        match the value specified in fullPathMatch after removing any query parameters
        and anchor that may be part of the original URL. FullPathMatch must be between 1
        and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        be specified.
        """
        ...

    @property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch']]:
        """
        Specifies a list of header match criteria, all of which must match corresponding
        headers in the request.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="metadataFilters")
    def metadata_filters(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter']]:
        """
        Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        clients present node metadata. If a match takes place, the relevant routing
        configuration is made available to those proxies. For each metadataFilter in
        this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        filterLabels must match the corresponding label provided in the metadata. If its
        filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        with corresponding labels in the provided metadata. metadataFilters specified
        here can be overrides those specified in ForwardingRule that refers to this
        UrlMap. metadataFilters only applies to Loadbalancers that have their
        loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter(name="queryParameterMatches")
    def query_parameter_matches(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']]:
        """
        Specifies a list of query parameter match criteria, all of which must match
        corresponding query parameters in the request.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch(dict):
    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        ...

    @property
    @pulumi.getter(name="invertMatch")
    def invert_match(self) -> Optional[bool]:
        """
        If set to false, the headerMatch is considered a match if the match criteria
        above are met. If set to true, the headerMatch is considered a match if the
        match criteria above are NOT met. Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        ...

    @property
    @pulumi.getter(name="rangeMatch")
    def range_match(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch']:
        """
        The header value must be an integer and its value must be in the range specified
        in rangeMatch. If the header does not contain an integer, number or is empty,
        the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        ...

    @property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[str]:
        """
        The value of the header must end with the contents of suffixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch(dict):
    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> float:
        """
        The end of the range (exclusive).
        """
        ...

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> float:
        """
        The start of the range (inclusive).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter(dict):
    @property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> List['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the provided metadata
        based on filterMatchCriteria  This list must not be empty and can have at the
        most 64 entries.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> str:
        """
        Specifies how individual filterLabel matches within the list of filterLabels
        contribute towards the overall metadataFilter match. Supported values are:
        - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        provided metadata.
        - MATCH_ALL: All filterLabels must have matching labels in
        the provided metadata.
        Possible values are `MATCH_ALL` and `MATCH_ANY`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        ...

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label must match the specified value. value can have a maximum
        length of 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch(dict):
    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        ...

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        ...

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteAction(dict):
    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy(dict):
    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the
        actual request can include user credentials. This translates to the Access-
        Control-Allow-Credentials header. Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        ...

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[List[str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For
        regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        ...

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[List[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests. An
        origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        ...

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled.
        """
        ...

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        Specifies how long the results of a preflight request can be cached. This
        translates to the content for the Access-Control-Max-Age header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy(dict):
    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault
        injection.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault
        injection, before being sent to a backend service.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort(dict):
    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[float]:
        """
        The HTTP status code used to abort the request. The value must be between 200
        and 599 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay(dict):
    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy(dict):
    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> float:
        """
        Specifies the allowed number retries. This number must be > 0.
        """
        ...

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[List[str]]:
        """
        Specifies one or more conditions when this retry rule applies. Valid values are:
        - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        any 5xx response code, or if the backend service does not respond at all,
        example: disconnects, reset, read timeout, connection failure, and refused
        streams.
        - gateway-error: Similar to 5xx, but only applies to response codes
        502, 503 or 504.
        - connect-failure: Loadbalancer will retry on failures
        connecting to backend services, for example due to connection timeouts.
        - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled: Loadbalancer will retry if the gRPC status code in the response
        header is set to cancelled
        - deadline-exceeded: Loadbalancer will retry if the
        gRPC status code in the response header is set to deadline-exceeded
        - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        header is set to resource-exhausted
        - unavailable: Loadbalancer will retry if
        the gRPC status code in the response header is set to unavailable
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite(dict):
    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host
        header is replaced with contents of hostRewrite. The value must be between 1 and
        255 characters.
        """
        ...

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching
        portion of the request's path is replaced by pathPrefixRewrite. The value must
        be between 1 and 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        ...

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. headerAction specified here take effect before
        headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        Specifies the fraction of traffic sent to backendService, computed as weight /
        (sum of all weightedBackendService weights in routeAction) . The selection of a
        backend service is determined only for new traffic. Once a user's request has
        been directed to a backendService, subsequent requests will be sent to the same
        backendService as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the
        backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request
        prior to forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response
        prior to sending the response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> Optional[bool]:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapTest(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        ...

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host portion of the URL.
        """
        ...

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path portion of the URL.
        """
        ...

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        A reference to expected RegionBackendService resource the given URL should be mapped to.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservation(dict):
    @property
    @pulumi.getter
    def count(self) -> float:
        """
        The number of resources that are allocated.
        """
        ...

    @property
    @pulumi.getter(name="inUseCount")
    def in_use_count(self) -> Optional[float]:
        """
        -
        How many instances are in use.
        """
        ...

    @property
    @pulumi.getter(name="instanceProperties")
    def instance_properties(self) -> 'outputs.ReservationSpecificReservationInstanceProperties':
        """
        The instance properties for the reservation.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservationInstanceProperties(dict):
    @property
    @pulumi.getter(name="guestAccelerators")
    def guest_accelerators(self) -> Optional[List['outputs.ReservationSpecificReservationInstancePropertiesGuestAccelerator']]:
        """
        Guest accelerator type and count.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="localSsds")
    def local_ssds(self) -> Optional[List['outputs.ReservationSpecificReservationInstancePropertiesLocalSsd']]:
        """
        The amount of local ssd to reserve with each instance. This
        reserves disks of type `local-ssd`.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        """
        The name of the machine type to reserve.
        """
        ...

    @property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> Optional[str]:
        """
        The minimum CPU platform for the reservation. For example,
        `"Intel Skylake"`. See
        the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
        for information on available CPU platforms.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservationInstancePropertiesGuestAccelerator(dict):
    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> float:
        """
        The number of the guest accelerator cards exposed to
        this instance.
        """
        ...

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> str:
        """
        The full or partial URL of the accelerator type to
        attach to this instance. For example:
        `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
        If you are creating an instance template, specify only the accelerator name.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservationInstancePropertiesLocalSsd(dict):
    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        The size of the disk in base-2 GB.
        """
        ...

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        The disk interface to use for attaching this disk.
        Default value is `SCSI`.
        Possible values are `SCSI` and `NVME`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicyGroupPlacementPolicy(dict):
    @property
    @pulumi.getter(name="availabilityDomainCount")
    def availability_domain_count(self) -> Optional[float]:
        """
        The number of availability domains instances will be spread across. If two instances are in different
        availability domain, they will not be put in the same low latency network
        """
        ...

    @property
    @pulumi.getter
    def collocation(self) -> Optional[str]:
        """
        Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
        Specify `COLLOCATED` to enable collocation. Can only be specified with `vm_count`. If compute instances are created
        with a COLLOCATED policy, then exactly `vm_count` instances must be created at the same time with the resource policy
        attached.
        Possible values are `COLLOCATED`.
        """
        ...

    @property
    @pulumi.getter(name="vmCount")
    def vm_count(self) -> Optional[float]:
        """
        Number of vms in this placement group.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicy(dict):
    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyRetentionPolicy']:
        """
        Retention policy applied to snapshots created by this resource policy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.ResourcePolicySnapshotSchedulePolicySchedule':
        """
        Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="snapshotProperties")
    def snapshot_properties(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicySnapshotProperties']:
        """
        Properties with which the snapshots are created, such as labels.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyRetentionPolicy(dict):
    @property
    @pulumi.getter(name="maxRetentionDays")
    def max_retention_days(self) -> float:
        """
        Maximum age of the snapshot that is allowed to be kept.
        """
        ...

    @property
    @pulumi.getter(name="onSourceDiskDelete")
    def on_source_disk_delete(self) -> Optional[str]:
        """
        Specifies the behavior to apply to scheduled snapshots when
        the source disk is deleted.
        Default value is `KEEP_AUTO_SNAPSHOTS`.
        Possible values are `KEEP_AUTO_SNAPSHOTS` and `APPLY_RETENTION_POLICY`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicySchedule(dict):
    @property
    @pulumi.getter(name="dailySchedule")
    def daily_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule']:
        """
        The policy will execute every nth day at the specified time.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="hourlySchedule")
    def hourly_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule']:
        """
        The policy will execute every nth hour starting at the specified time.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="weeklySchedule")
    def weekly_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule']:
        """
        Allows specifying a snapshot time for each day of the week.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule(dict):
    @property
    @pulumi.getter(name="daysInCycle")
    def days_in_cycle(self) -> float:
        """
        The number of days between snapshots.
        """
        ...

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule(dict):
    @property
    @pulumi.getter(name="hoursInCycle")
    def hours_in_cycle(self) -> float:
        """
        The number of hours between snapshots.
        """
        ...

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule(dict):
    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> List['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek']:
        """
        May contain up to seven (one for each day of the week) snapshot times.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek(dict):
    @property
    @pulumi.getter
    def day(self) -> str:
        """
        The day of the week to create the snapshot. e.g. MONDAY
        Possible values are `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, and `SUNDAY`.
        """
        ...

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicySnapshotProperties(dict):
    @property
    @pulumi.getter(name="guestFlush")
    def guest_flush(self) -> Optional[bool]:
        """
        Whether to perform a 'guest aware' snapshot.
        """
        ...

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A set of key-value pairs.
        """
        ...

    @property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Optional[str]:
        """
        Cloud Storage bucket location to store the auto snapshot
        (regional or multi-regional)
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterBgp(dict):
    @property
    @pulumi.getter(name="advertiseMode")
    def advertise_mode(self) -> Optional[str]:
        """
        User-specified flag to indicate which mode to use for advertisement.
        Default value is `DEFAULT`.
        Possible values are `DEFAULT` and `CUSTOM`.
        """
        ...

    @property
    @pulumi.getter(name="advertisedGroups")
    def advertised_groups(self) -> Optional[List[str]]:
        """
        User-specified list of prefix groups to advertise in custom mode.
        This field can only be populated if advertiseMode is CUSTOM and
        is advertised to all peers of the router. These groups will be
        advertised in addition to any specified prefixes. Leave this field
        blank to advertise no custom groups.
        This enum field has the one valid value: ALL_SUBNETS
        """
        ...

    @property
    @pulumi.getter(name="advertisedIpRanges")
    def advertised_ip_ranges(self) -> Optional[List['outputs.RouterBgpAdvertisedIpRange']]:
        """
        User-specified list of individual IP ranges to advertise in
        custom mode. This field can only be populated if advertiseMode
        is CUSTOM and is advertised to all peers of the router. These IP
        ranges will be advertised in addition to any specified groups.
        Leave this field blank to advertise no custom IP ranges.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def asn(self) -> float:
        """
        Local BGP Autonomous System Number (ASN). Must be an RFC6996
        private ASN, either 16-bit or 32-bit. The value will be fixed for
        this router resource. All VPN tunnels that link to this router
        will have the same local ASN.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterBgpAdvertisedIpRange(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        User-specified description for the IP range.
        """
        ...

    @property
    @pulumi.getter
    def range(self) -> str:
        """
        The IP range to advertise. The value must be a
        CIDR-formatted string.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterNatLogConfig(dict):
    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Indicates whether or not to export logs.
        """
        ...

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        Specifies the desired filtering of logs on this NAT.
        Possible values are `ERRORS_ONLY`, `TRANSLATIONS_ONLY`, and `ALL`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterNatSubnetwork(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Self-link of subnetwork to NAT
        """
        ...

    @property
    @pulumi.getter(name="secondaryIpRangeNames")
    def secondary_ip_range_names(self) -> Optional[List[str]]:
        """
        List of the secondary ranges of the subnetwork that are allowed
        to use NAT. This can be populated only if
        `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
        sourceIpRangesToNat
        """
        ...

    @property
    @pulumi.getter(name="sourceIpRangesToNats")
    def source_ip_ranges_to_nats(self) -> List[str]:
        """
        List of options for which source IPs in the subnetwork
        should have NAT enabled. Supported values include:
        `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
        `PRIMARY_IP_RANGE`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterPeerAdvertisedIpRange(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        User-specified description for the IP range.
        """
        ...

    @property
    @pulumi.getter
    def range(self) -> str:
        """
        The IP range to advertise. The value must be a
        CIDR-formatted string.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRule(dict):
    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to take when `match` matches the request. Valid values:
        * "allow" : allow access to target
        * "deny(status)" : deny access to target, returns the  HTTP response code specified (valid values are 403, 404 and 502)
        """
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this rule. Max size is 64.
        """
        ...

    @property
    @pulumi.getter
    def match(self) -> 'outputs.SecurityPolicyRuleMatch':
        """
        A match condition that incoming traffic is evaluated against.
        If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def preview(self) -> Optional[bool]:
        """
        When set to true, the `action` specified above is not enforced.
        Stackdriver logs for requests that trigger a preview action are annotated as such.
        """
        ...

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        An unique positive integer indicating the priority of evaluation for a rule.
        Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRuleMatch(dict):
    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.SecurityPolicyRuleMatchConfig']:
        """
        The configuration options available when specifying `versioned_expr`.
        This field must be specified if `versioned_expr` is specified and cannot be specified if `versioned_expr` is not specified.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def expr(self) -> Optional['outputs.SecurityPolicyRuleMatchExpr']:
        """
        User defined CEVAL expression. A CEVAL expression is used to specify match criteria
        such as origin.ip, source.region_code and contents in the request header.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> Optional[str]:
        """
        Predefined rule expression. If this field is specified, `config` must also be specified.
        Available options:
        * SRC_IPS_V1: Must specify the corresponding `src_ip_ranges` field in `config`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRuleMatchConfig(dict):
    @property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> List[str]:
        """
        Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
        to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of '\*' matches all IPs
        (can be used to override the default behavior).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRuleMatchExpr(dict):
    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigAuthentication(dict):
    @property
    @pulumi.getter(name="customAccount")
    def custom_account(self) -> Optional['outputs.SecurityScanConfigAuthenticationCustomAccount']:
        """
        Describes authentication configuration that uses a custom account.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="googleAccount")
    def google_account(self) -> Optional['outputs.SecurityScanConfigAuthenticationGoogleAccount']:
        """
        Describes authentication configuration that uses a Google account.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigAuthenticationCustomAccount(dict):
    @property
    @pulumi.getter(name="loginUrl")
    def login_url(self) -> str:
        """
        The login form URL of the website.
        """
        ...

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the custom account. The credential is stored encrypted
        in GCP.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The user name of the custom account.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigAuthenticationGoogleAccount(dict):
    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the custom account. The credential is stored encrypted
        in GCP.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The user name of the custom account.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigSchedule(dict):
    @property
    @pulumi.getter(name="intervalDurationDays")
    def interval_duration_days(self) -> float:
        """
        The duration of time between executions in days
        """
        ...

    @property
    @pulumi.getter(name="scheduleTime")
    def schedule_time(self) -> Optional[str]:
        """
        A timestamp indicates when the next run will be scheduled. The value is refreshed
        by the server after each run. If unspecified, it will default to current server time,
        which means the scan will be scheduled to start immediately.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SnapshotSnapshotEncryptionKey(dict):
    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SnapshotSourceDiskEncryptionKey(dict):
    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkIAMBindingCondition(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        ...

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        ...

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkIAMMemberCondition(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        ...

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        ...

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkLogConfig(dict):
    @property
    @pulumi.getter(name="aggregationInterval")
    def aggregation_interval(self) -> Optional[str]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        Toggles the aggregation interval for collecting flow logs. Increasing the
        interval time will reduce the amount of generated flow logs for long
        lasting connections. Default is an interval of 5 seconds per connection.
        Possible values are INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN,
        INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN
        Default value is `INTERVAL_5_SEC`.
        Possible values are `INTERVAL_5_SEC`, `INTERVAL_30_SEC`, `INTERVAL_1_MIN`, `INTERVAL_5_MIN`, `INTERVAL_10_MIN`, and `INTERVAL_15_MIN`.
        """
        ...

    @property
    @pulumi.getter(name="flowSampling")
    def flow_sampling(self) -> Optional[float]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        The value of the field must be in [0, 1]. Set the sampling rate of VPC
        flow logs within the subnetwork where 1.0 means all collected logs are
        reported and 0.0 means no logs are reported. Default is 0.5 which means
        half of all collected logs are reported.
        """
        ...

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        Configures whether metadata fields should be added to the reported VPC
        flow logs.
        Default value is `INCLUDE_ALL_METADATA`.
        Possible values are `EXCLUDE_ALL_METADATA` and `INCLUDE_ALL_METADATA`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkSecondaryIpRange(dict):
    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The range of IP addresses belonging to this subnetwork secondary
        range. Provide this property when you create the subnetwork.
        Ranges must be unique and non-overlapping with all primary and
        secondary IP ranges within a network. Only IPv4 is supported.
        """
        ...

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        """
        The name associated with this subnetwork secondary range, used
        when adding an alias IP range to a VM instance. The name must
        be 1-63 characters long, and comply with RFC1035. The name
        must be unique within the subnetwork.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteAction(dict):
    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[List['outputs.URLMapDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionCorsPolicy(dict):
    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        ...

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        ...

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[List[str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[List[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        ...

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicy(dict):
    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyAbort(dict):
    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[float]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelay(dict):
    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionRequestMirrorPolicy(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionRetryPolicy(dict):
    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[float]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        ...

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[List[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        connection failure, and refused streams.
        gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionUrlRewrite(dict):
    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendService(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[str]:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.URLMapHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.URLMapHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHostRule(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        ...

    @property
    @pulumi.getter
    def hosts(self) -> List[str]:
        """
        The list of host patterns to match. They must be valid hostnames, except * will
        match any string of ([a-z0-9-.]*). In that case, * must be the first character
        and must be followed in the pattern by either - or ..
        """
        ...

    @property
    @pulumi.getter(name="pathMatcher")
    def path_matcher(self) -> str:
        """
        The name of the PathMatcher to use to match the path portion of the URL if the
        hostRule matches the URL's host portion.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcher(dict):
    @property
    @pulumi.getter(name="defaultRouteAction")
    def default_route_action(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteAction']:
        """
        defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
        advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
        to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
        Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
        Only one of defaultRouteAction or defaultUrlRedirect must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="defaultService")
    def default_service(self) -> Optional[str]:
        """
        The backend service or backend bucket to use when none of the given paths match.
        """
        ...

    @property
    @pulumi.getter(name="defaultUrlRedirect")
    def default_url_redirect(self) -> Optional['outputs.URLMapPathMatcherDefaultUrlRedirect']:
        """
        When none of the specified hostRules match, the request is redirected to a URL specified
        by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
        defaultRouteAction must not be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        ...

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        ...

    @property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Optional[List['outputs.URLMapPathMatcherPathRule']]:
        """
        The list of path rules. Use this list instead of routeRules when routing based
        on simple path matching is all that's required. The order by which path rules
        are specified does not matter. Matches are always done on the longest-path-first
        basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        irrespective of the order in which those paths appear in this list. Within a
        given pathMatcher, only one of pathRules or routeRules must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="routeRules")
    def route_rules(self) -> Optional[List['outputs.URLMapPathMatcherRouteRule']]:
        """
        The list of ordered HTTP route rules. Use this list instead of pathRules when
        advanced route matching and routing actions are desired. The order of specifying
        routeRules matters: the first rule that matches will cause its specified routing
        action to take effect. Within a given pathMatcher, only one of pathRules or
        routeRules must be set. routeRules are not supported in UrlMaps intended for
        External load balancers.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteAction(dict):
    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[List['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionCorsPolicy(dict):
    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        ...

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        ...

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[List[str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[List[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        ...

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy(dict):
    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort(dict):
    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[float]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay(dict):
    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRetryPolicy(dict):
    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[float]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        ...

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[List[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        connection failure, and refused streams.
        gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionUrlRewrite(dict):
    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendService(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[str]:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRule(dict):
    @property
    @pulumi.getter
    def paths(self) -> List[str]:
        """
        The list of path patterns to match. Each must start with / and the only place a
        * is allowed is at the end following a /. The string fed to the path matcher
        does not include any text after the first ? or #, and those chars are not
        allowed here.
        """
        ...

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteAction']:
        """
        In response to a matching matchRule, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If  routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The backend service or backend bucket link that should be matched by this test.
        """
        ...

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.URLMapPathMatcherPathRuleUrlRedirect']:
        """
        When this rule is matched, the request is redirected to a URL specified by
        urlRedirect. If urlRedirect is specified, service or routeAction must not be
        set.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteAction(dict):
    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[List['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionCorsPolicy(dict):
    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        ...

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        ...

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[List[str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[List[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        ...

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy(dict):
    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(dict):
    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> float:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(dict):
    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> 'outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay':
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicy(dict):
    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[float]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        ...

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[List[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        connection failure, and refused streams.
        gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionUrlRewrite(dict):
    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendService(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRule(dict):
    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleMatchRule']]:
        """
        The rules for determining a match.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def priority(self) -> float:
        """
        For routeRules within a given pathMatcher, priority determines the order
        in which load balancer will interpret routeRules. RouteRules are evaluated
        in order of priority, from the lowest to highest number. The priority of
        a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        that matches the request is applied.
        You cannot configure two or more routeRules with the same priority.
        Priority for each rule must be set to a number between 0 and
        2147483647 inclusive.
        Priority numbers can have gaps, which enable you to add or remove rules
        in the future without affecting the rest of the rules. For example,
        1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        future without any impact on existing rules.
        """
        ...

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteAction']:
        """
        In response to a matching matchRule, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If  routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The backend service or backend bucket link that should be matched by this test.
        """
        ...

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.URLMapPathMatcherRouteRuleUrlRedirect']:
        """
        When this rule is matched, the request is redirected to a URL specified by
        urlRedirect. If urlRedirect is specified, service or routeAction must not be
        set.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRule(dict):
    @property
    @pulumi.getter(name="fullPathMatch")
    def full_path_match(self) -> Optional[str]:
        """
        For satifying the matchRule condition, the path of the request must exactly
        match the value specified in fullPathMatch after removing any query parameters
        and anchor that may be part of the original URL. FullPathMatch must be between 1
        and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        be specified.
        """
        ...

    @property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch']]:
        """
        Specifies a list of header match criteria, all of which must match corresponding
        headers in the request.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="metadataFilters")
    def metadata_filters(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter']]:
        """
        Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        clients present node metadata. If a match takes place, the relevant routing
        configuration is made available to those proxies. For each metadataFilter in
        this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        filterLabels must match the corresponding label provided in the metadata. If its
        filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        with corresponding labels in the provided metadata. metadataFilters specified
        here can be overrides those specified in ForwardingRule that refers to this
        UrlMap. metadataFilters only applies to Loadbalancers that have their
        loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter(name="queryParameterMatches")
    def query_parameter_matches(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']]:
        """
        Specifies a list of query parameter match criteria, all of which must match
        corresponding query parameters in the request.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatch(dict):
    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="invertMatch")
    def invert_match(self) -> Optional[bool]:
        """
        If set to false, the headerMatch is considered a match if the match criteria
        above are met. If set to true, the headerMatch is considered a match if the
        match criteria above are NOT met. Defaults to false.
        """
        ...

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        ...

    @property
    @pulumi.getter(name="rangeMatch")
    def range_match(self) -> Optional['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch']:
        """
        The header value must be an integer and its value must be in the range specified
        in rangeMatch. If the header does not contain an integer, number or is empty,
        the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        ...

    @property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[str]:
        """
        The value of the header must end with the contents of suffixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch(dict):
    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> float:
        """
        The end of the range (exclusive).
        """
        ...

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> float:
        """
        The start of the range (inclusive).
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilter(dict):
    @property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> List['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the provided metadata
        based on filterMatchCriteria  This list must not be empty and can have at the
        most 64 entries.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> str:
        """
        Specifies how individual filterLabel matches within the list of filterLabels
        contribute towards the overall metadataFilter match. Supported values are:
        - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        provided metadata.
        - MATCH_ALL: All filterLabels must have matching labels in
        the provided metadata.
        Possible values are `MATCH_ALL` and `MATCH_ANY`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        ...

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label must match the specified value. value can have a maximum
        length of 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch(dict):
    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        ...

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        ...

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteAction(dict):
    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionCorsPolicy(dict):
    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        ...

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        ...

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[List[str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[List[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        ...

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        ...

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[List[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        ...

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy(dict):
    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort(dict):
    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[float]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay(dict):
    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicy(dict):
    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> float:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        ...

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[List[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        connection failure, and refused streams.
        gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> Optional[float]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        ...

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionUrlRewrite(dict):
    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendService(dict):
    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        ...

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter
    def weight(self) -> float:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[List['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[List[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        ...

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        ...

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleUrlRedirect(dict):
    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        ...

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        ...

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        ...

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        ...

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        ...

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> Optional[bool]:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapTest(dict):
    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        ...

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host portion of the URL.
        """
        ...

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path portion of the URL.
        """
        ...

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The backend service or backend bucket link that should be matched by this test.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendBucketCdnPolicy(dict):
    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> float:
        """
        Maximum number of seconds the response to a signed URL request will be considered fresh. After this time period, the response will be revalidated before being served. When serving responses to signed URL requests, Cloud CDN will internally behave as though all responses from this backend had a "Cache-Control: public, max-age=[TTL]" header, regardless of any existing Cache-Control header. The actual headers served in responses will not be altered.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceBackend(dict):
    @property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> str:
        ...

    @property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> float:
        ...

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Textual description for the Backend Service.
        """
        ...

    @property
    @pulumi.getter
    def group(self) -> str:
        ...

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceCdnPolicy(dict):
    @property
    @pulumi.getter(name="cacheKeyPolicies")
    def cache_key_policies(self) -> List['outputs.GetBackendServiceCdnPolicyCacheKeyPolicy']:
        ...

    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceCdnPolicyCacheKeyPolicy(dict):
    @property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> bool:
        ...

    @property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> bool:
        ...

    @property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> bool:
        ...

    @property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> List[str]:
        ...

    @property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> List[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceCircuitBreaker(dict):
    @property
    @pulumi.getter(name="connectTimeouts")
    def connect_timeouts(self) -> List['outputs.GetBackendServiceCircuitBreakerConnectTimeout']:
        ...

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> float:
        ...

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceCircuitBreakerConnectTimeout(dict):
    @property
    @pulumi.getter
    def nanos(self) -> float:
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceConsistentHash(dict):
    @property
    @pulumi.getter(name="httpCookies")
    def http_cookies(self) -> List['outputs.GetBackendServiceConsistentHashHttpCooky']:
        ...

    @property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> str:
        ...

    @property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceConsistentHashHttpCooky(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Backend Service.
        """
        ...

    @property
    @pulumi.getter
    def path(self) -> str:
        ...

    @property
    @pulumi.getter
    def ttls(self) -> List['outputs.GetBackendServiceConsistentHashHttpCookyTtl']:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceConsistentHashHttpCookyTtl(dict):
    @property
    @pulumi.getter
    def nanos(self) -> float:
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceIap(dict):
    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> str:
        ...

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> str:
        ...

    @property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> str:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceLogConfig(dict):
    @property
    @pulumi.getter
    def enable(self) -> bool:
        ...

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceOutlierDetection(dict):
    @property
    @pulumi.getter(name="baseEjectionTimes")
    def base_ejection_times(self) -> List['outputs.GetBackendServiceOutlierDetectionBaseEjectionTime']:
        ...

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> float:
        ...

    @property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> float:
        ...

    @property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> float:
        ...

    @property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> float:
        ...

    @property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> float:
        ...

    @property
    @pulumi.getter
    def intervals(self) -> List['outputs.GetBackendServiceOutlierDetectionInterval']:
        ...

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> float:
        ...

    @property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> float:
        ...

    @property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> float:
        ...

    @property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceOutlierDetectionBaseEjectionTime(dict):
    @property
    @pulumi.getter
    def nanos(self) -> float:
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendServiceOutlierDetectionInterval(dict):
    @property
    @pulumi.getter
    def nanos(self) -> float:
        ...

    @property
    @pulumi.getter
    def seconds(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceAttachedDisk(dict):
    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name with which the attached disk is accessible
        under `/dev/disk/by-id/`
        """
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> str:
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> str:
        ...

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> str:
        ...

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The name or self_link of the disk attached to this instance.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceBootDisk(dict):
    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> bool:
        """
        Whether the disk will be auto-deleted when the instance is deleted.
        """
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name with which the attached disk is accessible
        under `/dev/disk/by-id/`
        """
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> str:
        ...

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> str:
        ...

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> List['outputs.GetInstanceBootDiskInitializeParam']:
        """
        Parameters with which a disk was created alongside the instance.
        Structure is documented below.
        """
        ...

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> str:
        ...

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        """
        ...

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The name or self_link of the disk attached to this instance.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceBootDiskInitializeParam(dict):
    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The image from which this disk was initialised.
        """
        ...

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        """
        A set of key/value label pairs assigned to the instance.
        """
        ...

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the image in gigabytes.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceConfidentialInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceGroupNamedPort(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceGuestAccelerator(dict):
    @property
    @pulumi.getter
    def count(self) -> float:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        ...

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceNetworkInterface(dict):
    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> List['outputs.GetInstanceNetworkInterfaceAccessConfig']:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Structure documented below.
        """
        ...

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> List['outputs.GetInstanceNetworkInterfaceAliasIpRange']:
        """
        An array of alias IP ranges for this network interface. Structure documented below.
        """
        ...

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance. One of `name` or `self_link` must be provided.
        """
        ...

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The name or self_link of the network attached to this interface.
        """
        ...

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> str:
        """
        The private IP address assigned to the instance.
        """
        ...

    @property
    @pulumi.getter
    def subnetwork(self) -> str:
        """
        The name or self_link of the subnetwork attached to this interface.
        """
        ...

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> str:
        """
        The project in which the subnetwork belongs.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceNetworkInterfaceAccessConfig(dict):
    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> str:
        """
        The IP address that is be 1:1 mapped to the instance's
        network ip.
        """
        ...

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> str:
        """
        The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
        """
        ...

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> str:
        """
        The DNS domain name for the public PTR record.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceNetworkInterfaceAliasIpRange(dict):
    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The IP CIDR range represented by this alias IP range.
        """
        ...

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> str:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceScheduling(dict):
    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> bool:
        """
        Specifies if the instance should be
        restarted if it was terminated by Compute Engine (not a user).
        """
        ...

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> float:
        ...

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> List['outputs.GetInstanceSchedulingNodeAffinity']:
        ...

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> str:
        """
        Describes maintenance behavior for the
        instance. One of `MIGRATE` or `TERMINATE`, for more info, read
        [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
        """
        ...

    @property
    @pulumi.getter
    def preemptible(self) -> bool:
        """
        Whether the instance is preemptible.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceSchedulingNodeAffinity(dict):
    @property
    @pulumi.getter
    def key(self) -> str:
        ...

    @property
    @pulumi.getter
    def operator(self) -> str:
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceScratchDisk(dict):
    @property
    @pulumi.getter
    def interface(self) -> str:
        """
        The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceServiceAccount(dict):
    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The service account e-mail address.
        """
        ...

    @property
    @pulumi.getter
    def scopes(self) -> List[str]:
        """
        A list of service scopes.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetInstanceShieldedInstanceConfig(dict):
    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> bool:
        ...

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> bool:
        ...

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> bool:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetRegionInstanceGroupInstance(dict):
    @property
    @pulumi.getter
    def instance(self) -> str:
        """
        URL to the instance.
        """
        ...

    @property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> List['outputs.GetRegionInstanceGroupInstanceNamedPort']:
        """
        List of named ports in the group, as a list of resources, each containing:
        """
        ...

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        String description of current state of the instance.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetRegionInstanceGroupInstanceNamedPort(dict):
    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance group.  One of `name` or `self_link` must be provided.
        """
        ...

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        Integer port number
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetRouterBgp(dict):
    @property
    @pulumi.getter(name="advertiseMode")
    def advertise_mode(self) -> str:
        ...

    @property
    @pulumi.getter(name="advertisedGroups")
    def advertised_groups(self) -> List[str]:
        ...

    @property
    @pulumi.getter(name="advertisedIpRanges")
    def advertised_ip_ranges(self) -> List['outputs.GetRouterBgpAdvertisedIpRange']:
        ...

    @property
    @pulumi.getter
    def asn(self) -> float:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetRouterBgpAdvertisedIpRange(dict):
    @property
    @pulumi.getter
    def description(self) -> str:
        ...

    @property
    @pulumi.getter
    def range(self) -> str:
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetSubnetworkSecondaryIpRange(dict):
    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The range of IP addresses belonging to this subnetwork
        secondary range.
        """
        ...

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        """
        The name associated with this subnetwork secondary range, used
        when adding an alias IP range to a VM instance.
        """
        ...

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


