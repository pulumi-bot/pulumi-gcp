# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from .. import _utilities, _tables

__all__ = [
    'ApplicationFeatureSettingsArgs',
    'ApplicationIapArgs',
    'ApplicationUrlDispatchRuleArgs',
    'ApplicationUrlDispatchRulesDispatchRuleArgs',
    'DomainMappingResourceRecordArgs',
    'DomainMappingSslSettingsArgs',
    'EngineSplitTrafficSplitArgs',
    'FlexibleAppVersionApiConfigArgs',
    'FlexibleAppVersionAutomaticScalingArgs',
    'FlexibleAppVersionAutomaticScalingCpuUtilizationArgs',
    'FlexibleAppVersionAutomaticScalingDiskUtilizationArgs',
    'FlexibleAppVersionAutomaticScalingNetworkUtilizationArgs',
    'FlexibleAppVersionAutomaticScalingRequestUtilizationArgs',
    'FlexibleAppVersionDeploymentArgs',
    'FlexibleAppVersionDeploymentCloudBuildOptionsArgs',
    'FlexibleAppVersionDeploymentContainerArgs',
    'FlexibleAppVersionDeploymentFileArgs',
    'FlexibleAppVersionDeploymentZipArgs',
    'FlexibleAppVersionEndpointsApiServiceArgs',
    'FlexibleAppVersionEntrypointArgs',
    'FlexibleAppVersionHandlerArgs',
    'FlexibleAppVersionHandlerScriptArgs',
    'FlexibleAppVersionHandlerStaticFilesArgs',
    'FlexibleAppVersionLivenessCheckArgs',
    'FlexibleAppVersionManualScalingArgs',
    'FlexibleAppVersionNetworkArgs',
    'FlexibleAppVersionReadinessCheckArgs',
    'FlexibleAppVersionResourcesArgs',
    'FlexibleAppVersionResourcesVolumeArgs',
    'FlexibleAppVersionVpcAccessConnectorArgs',
    'StandardAppVersionAutomaticScalingArgs',
    'StandardAppVersionAutomaticScalingStandardSchedulerSettingsArgs',
    'StandardAppVersionBasicScalingArgs',
    'StandardAppVersionDeploymentArgs',
    'StandardAppVersionDeploymentFileArgs',
    'StandardAppVersionDeploymentZipArgs',
    'StandardAppVersionEntrypointArgs',
    'StandardAppVersionHandlerArgs',
    'StandardAppVersionHandlerScriptArgs',
    'StandardAppVersionHandlerStaticFilesArgs',
    'StandardAppVersionLibraryArgs',
    'StandardAppVersionManualScalingArgs',
]

@pulumi.input_type
class ApplicationFeatureSettingsArgs:
    def __init__(__self__, *,
                 split_health_checks: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] split_health_checks: Set to false to use the legacy health check instead of the readiness
               and liveness checks.
        """
        pulumi.set(__self__, "splitHealthChecks", split_health_checks)

    @property
    @pulumi.getter(name="splitHealthChecks")
    def split_health_checks(self) -> pulumi.Input[bool]:
        """
        Set to false to use the legacy health check instead of the readiness
        and liveness checks.
        """
        ...

    @split_health_checks.setter
    def split_health_checks(self, value: pulumi.Input[bool]):
        ...


@pulumi.input_type
class ApplicationIapArgs:
    def __init__(__self__, *,
                 oauth2_client_id: pulumi.Input[str],
                 oauth2_client_secret: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 oauth2_client_secret_sha256: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oauth2_client_id: OAuth2 client ID to use for the authentication flow.
        :param pulumi.Input[str] oauth2_client_secret: OAuth2 client secret to use for the authentication flow.
               The SHA-256 hash of the value is returned in the oauth2ClientSecretSha256 field.
        :param pulumi.Input[str] oauth2_client_secret_sha256: Hex-encoded SHA-256 hash of the client secret.
        """
        pulumi.set(__self__, "oauth2ClientId", oauth2_client_id)
        pulumi.set(__self__, "oauth2ClientSecret", oauth2_client_secret)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "oauth2ClientSecretSha256", oauth2_client_secret_sha256)

    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> pulumi.Input[str]:
        """
        OAuth2 client ID to use for the authentication flow.
        """
        ...

    @oauth2_client_id.setter
    def oauth2_client_id(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> pulumi.Input[str]:
        """
        OAuth2 client secret to use for the authentication flow.
        The SHA-256 hash of the value is returned in the oauth2ClientSecretSha256 field.
        """
        ...

    @oauth2_client_secret.setter
    def oauth2_client_secret(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        ...

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> Optional[pulumi.Input[str]]:
        """
        Hex-encoded SHA-256 hash of the client secret.
        """
        ...

    @oauth2_client_secret_sha256.setter
    def oauth2_client_secret_sha256(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class ApplicationUrlDispatchRuleArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        ...

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        ...

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        ...

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class ApplicationUrlDispatchRulesDispatchRuleArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 service: pulumi.Input[str],
                 domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path.
               The sum of the lengths of the domain and path may not exceed 100 characters.
        :param pulumi.Input[str] service: Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path.
               The sum of the lengths of the domain and path may not exceed 100 characters.
        :param pulumi.Input[str] domain: Domain name to match against. The wildcard "*" is supported if specified before a period: "*.".
               Defaults to matching all domains: "*".
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path.
        The sum of the lengths of the domain and path may not exceed 100 characters.
        """
        ...

    @path.setter
    def path(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path.
        The sum of the lengths of the domain and path may not exceed 100 characters.
        """
        ...

    @service.setter
    def service(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name to match against. The wildcard "*" is supported if specified before a period: "*.".
        Defaults to matching all domains: "*".
        """
        ...

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class DomainMappingResourceRecordArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 rrdata: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rrdata", rrdata)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        ...

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def rrdata(self) -> Optional[pulumi.Input[str]]:
        ...

    @rrdata.setter
    def rrdata(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        ...

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class DomainMappingSslSettingsArgs:
    def __init__(__self__, *,
                 ssl_management_type: pulumi.Input[str],
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 pending_managed_certificate_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ssl_management_type: SSL management type for this domain. If `AUTOMATIC`, a managed certificate is automatically provisioned.
               If `MANUAL`, `certificateId` must be manually specified in order to configure SSL for this domain.
               Possible values are `AUTOMATIC` and `MANUAL`.
        :param pulumi.Input[str] certificate_id: ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
               remove SSL support.
               By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
               or to configure SSL manually, specify `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must be
               authorized to administer the `AuthorizedCertificate` resource to manually map it to a DomainMapping resource.
               Example: 12345.
        :param pulumi.Input[str] pending_managed_certificate_id: -
               ID of the managed `AuthorizedCertificate` resource currently being provisioned, if applicable. Until the new
               managed certificate has been successfully provisioned, the previous SSL state will be preserved. Once the
               provisioning process completes, the `certificateId` field will reflect the new managed certificate and this
               field will be left empty. To remove SSL support while there is still a pending managed certificate, clear the
               `certificateId` field with an update request.
        """
        pulumi.set(__self__, "sslManagementType", ssl_management_type)
        pulumi.set(__self__, "certificateId", certificate_id)
        pulumi.set(__self__, "pendingManagedCertificateId", pending_managed_certificate_id)

    @property
    @pulumi.getter(name="sslManagementType")
    def ssl_management_type(self) -> pulumi.Input[str]:
        """
        SSL management type for this domain. If `AUTOMATIC`, a managed certificate is automatically provisioned.
        If `MANUAL`, `certificateId` must be manually specified in order to configure SSL for this domain.
        Possible values are `AUTOMATIC` and `MANUAL`.
        """
        ...

    @ssl_management_type.setter
    def ssl_management_type(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
        remove SSL support.
        By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
        or to configure SSL manually, specify `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must be
        authorized to administer the `AuthorizedCertificate` resource to manually map it to a DomainMapping resource.
        Example: 12345.
        """
        ...

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="pendingManagedCertificateId")
    def pending_managed_certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        -
        ID of the managed `AuthorizedCertificate` resource currently being provisioned, if applicable. Until the new
        managed certificate has been successfully provisioned, the previous SSL state will be preserved. Once the
        provisioning process completes, the `certificateId` field will reflect the new managed certificate and this
        field will be left empty. To remove SSL support while there is still a pending managed certificate, clear the
        `certificateId` field with an update request.
        """
        ...

    @pending_managed_certificate_id.setter
    def pending_managed_certificate_id(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class EngineSplitTrafficSplitArgs:
    def __init__(__self__, *,
                 allocations: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 shard_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] allocations: Mapping from version IDs within the service to fractional (0.000, 1] allocations of traffic for that version. Each version can be specified only once, but some versions in the service may not have any traffic allocation. Services that have traffic allocated cannot be deleted until either the service is deleted or their traffic allocation is removed. Allocations must sum to 1. Up to two decimal place precision is supported for IP-based splits and up to three decimal places is supported for cookie-based splits.
        :param pulumi.Input[str] shard_by: Mechanism used to determine which version a request is sent to. The traffic selection algorithm will be stable for either type until allocations are changed.
               Possible values are `UNSPECIFIED`, `COOKIE`, `IP`, and `RANDOM`.
        """
        pulumi.set(__self__, "allocations", allocations)
        pulumi.set(__self__, "shardBy", shard_by)

    @property
    @pulumi.getter
    def allocations(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Mapping from version IDs within the service to fractional (0.000, 1] allocations of traffic for that version. Each version can be specified only once, but some versions in the service may not have any traffic allocation. Services that have traffic allocated cannot be deleted until either the service is deleted or their traffic allocation is removed. Allocations must sum to 1. Up to two decimal place precision is supported for IP-based splits and up to three decimal places is supported for cookie-based splits.
        """
        ...

    @allocations.setter
    def allocations(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        ...

    @property
    @pulumi.getter(name="shardBy")
    def shard_by(self) -> Optional[pulumi.Input[str]]:
        """
        Mechanism used to determine which version a request is sent to. The traffic selection algorithm will be stable for either type until allocations are changed.
        Possible values are `UNSPECIFIED`, `COOKIE`, `IP`, and `RANDOM`.
        """
        ...

    @shard_by.setter
    def shard_by(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionApiConfigArgs:
    def __init__(__self__, *,
                 script: pulumi.Input[str],
                 auth_fail_action: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] script: Path to the script from the application root directory.
        :param pulumi.Input[str] auth_fail_action: Action to take when users access resources that require authentication.
               Default value is `AUTH_FAIL_ACTION_REDIRECT`.
               Possible values are `AUTH_FAIL_ACTION_REDIRECT` and `AUTH_FAIL_ACTION_UNAUTHORIZED`.
        :param pulumi.Input[str] login: Level of login required to access this resource.
               Default value is `LOGIN_OPTIONAL`.
               Possible values are `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, and `LOGIN_REQUIRED`.
        :param pulumi.Input[str] security_level: Security (HTTPS) enforcement for this URL.
               Possible values are `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, and `SECURE_ALWAYS`.
        :param pulumi.Input[str] url: URL to serve the endpoint at.
        """
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "authFailAction", auth_fail_action)
        pulumi.set(__self__, "login", login)
        pulumi.set(__self__, "securityLevel", security_level)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def script(self) -> pulumi.Input[str]:
        """
        Path to the script from the application root directory.
        """
        ...

    @script.setter
    def script(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="authFailAction")
    def auth_fail_action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to take when users access resources that require authentication.
        Default value is `AUTH_FAIL_ACTION_REDIRECT`.
        Possible values are `AUTH_FAIL_ACTION_REDIRECT` and `AUTH_FAIL_ACTION_UNAUTHORIZED`.
        """
        ...

    @auth_fail_action.setter
    def auth_fail_action(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input[str]]:
        """
        Level of login required to access this resource.
        Default value is `LOGIN_OPTIONAL`.
        Possible values are `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, and `LOGIN_REQUIRED`.
        """
        ...

    @login.setter
    def login(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Security (HTTPS) enforcement for this URL.
        Possible values are `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, and `SECURE_ALWAYS`.
        """
        ...

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL to serve the endpoint at.
        """
        ...

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionAutomaticScalingArgs:
    def __init__(__self__, *,
                 cpu_utilization: pulumi.Input['FlexibleAppVersionAutomaticScalingCpuUtilizationArgs'],
                 cool_down_period: Optional[pulumi.Input[str]] = None,
                 disk_utilization: Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingDiskUtilizationArgs']] = None,
                 max_concurrent_requests: Optional[pulumi.Input[float]] = None,
                 max_idle_instances: Optional[pulumi.Input[float]] = None,
                 max_pending_latency: Optional[pulumi.Input[str]] = None,
                 max_total_instances: Optional[pulumi.Input[float]] = None,
                 min_idle_instances: Optional[pulumi.Input[float]] = None,
                 min_pending_latency: Optional[pulumi.Input[str]] = None,
                 min_total_instances: Optional[pulumi.Input[float]] = None,
                 network_utilization: Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingNetworkUtilizationArgs']] = None,
                 request_utilization: Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingRequestUtilizationArgs']] = None):
        """
        :param pulumi.Input['FlexibleAppVersionAutomaticScalingCpuUtilizationArgs'] cpu_utilization: Target scaling by CPU usage.
               Structure is documented below.
        :param pulumi.Input[str] cool_down_period: The time period that the Autoscaler should wait before it starts collecting information from a new instance.
               This prevents the autoscaler from collecting information when the instance is initializing,
               during which the collected usage would not be reliable. Default: 120s
        :param pulumi.Input['FlexibleAppVersionAutomaticScalingDiskUtilizationArgs'] disk_utilization: Target scaling by disk usage.
               Structure is documented below.
        :param pulumi.Input[float] max_concurrent_requests: Number of concurrent requests an automatic scaling instance can accept before the scheduler spawns a new instance.
               Defaults to a runtime-specific value.
        :param pulumi.Input[float] max_idle_instances: Maximum number of idle instances that should be maintained for this version.
        :param pulumi.Input[str] max_pending_latency: Maximum amount of time that a request should wait in the pending queue before starting a new instance to handle it.
        :param pulumi.Input[float] max_total_instances: Maximum number of instances that should be started to handle requests for this version. Default: 20
        :param pulumi.Input[float] min_idle_instances: Minimum number of idle instances that should be maintained for this version. Only applicable for the default version of a service.
        :param pulumi.Input[str] min_pending_latency: Minimum amount of time a request should wait in the pending queue before starting a new instance to handle it.
        :param pulumi.Input[float] min_total_instances: Minimum number of running instances that should be maintained for this version. Default: 2
        :param pulumi.Input['FlexibleAppVersionAutomaticScalingNetworkUtilizationArgs'] network_utilization: Target scaling by network usage.
               Structure is documented below.
        :param pulumi.Input['FlexibleAppVersionAutomaticScalingRequestUtilizationArgs'] request_utilization: Target scaling by request utilization.
               Structure is documented below.
        """
        pulumi.set(__self__, "cpuUtilization", cpu_utilization)
        pulumi.set(__self__, "coolDownPeriod", cool_down_period)
        pulumi.set(__self__, "diskUtilization", disk_utilization)
        pulumi.set(__self__, "maxConcurrentRequests", max_concurrent_requests)
        pulumi.set(__self__, "maxIdleInstances", max_idle_instances)
        pulumi.set(__self__, "maxPendingLatency", max_pending_latency)
        pulumi.set(__self__, "maxTotalInstances", max_total_instances)
        pulumi.set(__self__, "minIdleInstances", min_idle_instances)
        pulumi.set(__self__, "minPendingLatency", min_pending_latency)
        pulumi.set(__self__, "minTotalInstances", min_total_instances)
        pulumi.set(__self__, "networkUtilization", network_utilization)
        pulumi.set(__self__, "requestUtilization", request_utilization)

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> pulumi.Input['FlexibleAppVersionAutomaticScalingCpuUtilizationArgs']:
        """
        Target scaling by CPU usage.
        Structure is documented below.
        """
        ...

    @cpu_utilization.setter
    def cpu_utilization(self, value: pulumi.Input['FlexibleAppVersionAutomaticScalingCpuUtilizationArgs']):
        ...

    @property
    @pulumi.getter(name="coolDownPeriod")
    def cool_down_period(self) -> Optional[pulumi.Input[str]]:
        """
        The time period that the Autoscaler should wait before it starts collecting information from a new instance.
        This prevents the autoscaler from collecting information when the instance is initializing,
        during which the collected usage would not be reliable. Default: 120s
        """
        ...

    @cool_down_period.setter
    def cool_down_period(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="diskUtilization")
    def disk_utilization(self) -> Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingDiskUtilizationArgs']]:
        """
        Target scaling by disk usage.
        Structure is documented below.
        """
        ...

    @disk_utilization.setter
    def disk_utilization(self, value: Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingDiskUtilizationArgs']]):
        ...

    @property
    @pulumi.getter(name="maxConcurrentRequests")
    def max_concurrent_requests(self) -> Optional[pulumi.Input[float]]:
        """
        Number of concurrent requests an automatic scaling instance can accept before the scheduler spawns a new instance.
        Defaults to a runtime-specific value.
        """
        ...

    @max_concurrent_requests.setter
    def max_concurrent_requests(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="maxIdleInstances")
    def max_idle_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of idle instances that should be maintained for this version.
        """
        ...

    @max_idle_instances.setter
    def max_idle_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="maxPendingLatency")
    def max_pending_latency(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum amount of time that a request should wait in the pending queue before starting a new instance to handle it.
        """
        ...

    @max_pending_latency.setter
    def max_pending_latency(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="maxTotalInstances")
    def max_total_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of instances that should be started to handle requests for this version. Default: 20
        """
        ...

    @max_total_instances.setter
    def max_total_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="minIdleInstances")
    def min_idle_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum number of idle instances that should be maintained for this version. Only applicable for the default version of a service.
        """
        ...

    @min_idle_instances.setter
    def min_idle_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="minPendingLatency")
    def min_pending_latency(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum amount of time a request should wait in the pending queue before starting a new instance to handle it.
        """
        ...

    @min_pending_latency.setter
    def min_pending_latency(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="minTotalInstances")
    def min_total_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum number of running instances that should be maintained for this version. Default: 2
        """
        ...

    @min_total_instances.setter
    def min_total_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="networkUtilization")
    def network_utilization(self) -> Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingNetworkUtilizationArgs']]:
        """
        Target scaling by network usage.
        Structure is documented below.
        """
        ...

    @network_utilization.setter
    def network_utilization(self, value: Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingNetworkUtilizationArgs']]):
        ...

    @property
    @pulumi.getter(name="requestUtilization")
    def request_utilization(self) -> Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingRequestUtilizationArgs']]:
        """
        Target scaling by request utilization.
        Structure is documented below.
        """
        ...

    @request_utilization.setter
    def request_utilization(self, value: Optional[pulumi.Input['FlexibleAppVersionAutomaticScalingRequestUtilizationArgs']]):
        ...


@pulumi.input_type
class FlexibleAppVersionAutomaticScalingCpuUtilizationArgs:
    def __init__(__self__, *,
                 target_utilization: pulumi.Input[float],
                 aggregation_window_length: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] target_utilization: Target CPU utilization ratio to maintain when scaling. Must be between 0 and 1.
        :param pulumi.Input[str] aggregation_window_length: Period of time over which CPU utilization is calculated.
        """
        pulumi.set(__self__, "targetUtilization", target_utilization)
        pulumi.set(__self__, "aggregationWindowLength", aggregation_window_length)

    @property
    @pulumi.getter(name="targetUtilization")
    def target_utilization(self) -> pulumi.Input[float]:
        """
        Target CPU utilization ratio to maintain when scaling. Must be between 0 and 1.
        """
        ...

    @target_utilization.setter
    def target_utilization(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="aggregationWindowLength")
    def aggregation_window_length(self) -> Optional[pulumi.Input[str]]:
        """
        Period of time over which CPU utilization is calculated.
        """
        ...

    @aggregation_window_length.setter
    def aggregation_window_length(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionAutomaticScalingDiskUtilizationArgs:
    def __init__(__self__, *,
                 target_read_bytes_per_second: Optional[pulumi.Input[float]] = None,
                 target_read_ops_per_second: Optional[pulumi.Input[float]] = None,
                 target_write_bytes_per_second: Optional[pulumi.Input[float]] = None,
                 target_write_ops_per_second: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] target_read_bytes_per_second: Target bytes read per second.
        :param pulumi.Input[float] target_read_ops_per_second: Target ops read per seconds.
        :param pulumi.Input[float] target_write_bytes_per_second: Target bytes written per second.
        :param pulumi.Input[float] target_write_ops_per_second: Target ops written per second.
        """
        pulumi.set(__self__, "targetReadBytesPerSecond", target_read_bytes_per_second)
        pulumi.set(__self__, "targetReadOpsPerSecond", target_read_ops_per_second)
        pulumi.set(__self__, "targetWriteBytesPerSecond", target_write_bytes_per_second)
        pulumi.set(__self__, "targetWriteOpsPerSecond", target_write_ops_per_second)

    @property
    @pulumi.getter(name="targetReadBytesPerSecond")
    def target_read_bytes_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target bytes read per second.
        """
        ...

    @target_read_bytes_per_second.setter
    def target_read_bytes_per_second(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetReadOpsPerSecond")
    def target_read_ops_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target ops read per seconds.
        """
        ...

    @target_read_ops_per_second.setter
    def target_read_ops_per_second(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetWriteBytesPerSecond")
    def target_write_bytes_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target bytes written per second.
        """
        ...

    @target_write_bytes_per_second.setter
    def target_write_bytes_per_second(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetWriteOpsPerSecond")
    def target_write_ops_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target ops written per second.
        """
        ...

    @target_write_ops_per_second.setter
    def target_write_ops_per_second(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class FlexibleAppVersionAutomaticScalingNetworkUtilizationArgs:
    def __init__(__self__, *,
                 target_received_bytes_per_second: Optional[pulumi.Input[float]] = None,
                 target_received_packets_per_second: Optional[pulumi.Input[float]] = None,
                 target_sent_bytes_per_second: Optional[pulumi.Input[float]] = None,
                 target_sent_packets_per_second: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] target_received_bytes_per_second: Target bytes received per second.
        :param pulumi.Input[float] target_received_packets_per_second: Target packets received per second.
        :param pulumi.Input[float] target_sent_bytes_per_second: Target bytes sent per second.
        :param pulumi.Input[float] target_sent_packets_per_second: Target packets sent per second.
        """
        pulumi.set(__self__, "targetReceivedBytesPerSecond", target_received_bytes_per_second)
        pulumi.set(__self__, "targetReceivedPacketsPerSecond", target_received_packets_per_second)
        pulumi.set(__self__, "targetSentBytesPerSecond", target_sent_bytes_per_second)
        pulumi.set(__self__, "targetSentPacketsPerSecond", target_sent_packets_per_second)

    @property
    @pulumi.getter(name="targetReceivedBytesPerSecond")
    def target_received_bytes_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target bytes received per second.
        """
        ...

    @target_received_bytes_per_second.setter
    def target_received_bytes_per_second(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetReceivedPacketsPerSecond")
    def target_received_packets_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target packets received per second.
        """
        ...

    @target_received_packets_per_second.setter
    def target_received_packets_per_second(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetSentBytesPerSecond")
    def target_sent_bytes_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target bytes sent per second.
        """
        ...

    @target_sent_bytes_per_second.setter
    def target_sent_bytes_per_second(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetSentPacketsPerSecond")
    def target_sent_packets_per_second(self) -> Optional[pulumi.Input[float]]:
        """
        Target packets sent per second.
        """
        ...

    @target_sent_packets_per_second.setter
    def target_sent_packets_per_second(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class FlexibleAppVersionAutomaticScalingRequestUtilizationArgs:
    def __init__(__self__, *,
                 target_concurrent_requests: Optional[pulumi.Input[float]] = None,
                 target_request_count_per_second: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] target_concurrent_requests: Target number of concurrent requests.
        :param pulumi.Input[str] target_request_count_per_second: Target requests per second.
        """
        pulumi.set(__self__, "targetConcurrentRequests", target_concurrent_requests)
        pulumi.set(__self__, "targetRequestCountPerSecond", target_request_count_per_second)

    @property
    @pulumi.getter(name="targetConcurrentRequests")
    def target_concurrent_requests(self) -> Optional[pulumi.Input[float]]:
        """
        Target number of concurrent requests.
        """
        ...

    @target_concurrent_requests.setter
    def target_concurrent_requests(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetRequestCountPerSecond")
    def target_request_count_per_second(self) -> Optional[pulumi.Input[str]]:
        """
        Target requests per second.
        """
        ...

    @target_request_count_per_second.setter
    def target_request_count_per_second(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionDeploymentArgs:
    def __init__(__self__, *,
                 cloud_build_options: Optional[pulumi.Input['FlexibleAppVersionDeploymentCloudBuildOptionsArgs']] = None,
                 container: Optional[pulumi.Input['FlexibleAppVersionDeploymentContainerArgs']] = None,
                 files: Optional[pulumi.Input[List[pulumi.Input['FlexibleAppVersionDeploymentFileArgs']]]] = None,
                 zip: Optional[pulumi.Input['FlexibleAppVersionDeploymentZipArgs']] = None):
        """
        :param pulumi.Input['FlexibleAppVersionDeploymentCloudBuildOptionsArgs'] cloud_build_options: Options for the build operations performed as a part of the version deployment. Only applicable when creating a version using source code directly.
               Structure is documented below.
        :param pulumi.Input['FlexibleAppVersionDeploymentContainerArgs'] container: The Docker image for the container that runs the version.
               Structure is documented below.
        :param pulumi.Input[List[pulumi.Input['FlexibleAppVersionDeploymentFileArgs']]] files: Manifest of the files stored in Google Cloud Storage that are included as part of this version.
               All files must be readable using the credentials supplied with this call.
               Structure is documented below.
        :param pulumi.Input['FlexibleAppVersionDeploymentZipArgs'] zip: Zip File
               Structure is documented below.
        """
        pulumi.set(__self__, "cloudBuildOptions", cloud_build_options)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "files", files)
        pulumi.set(__self__, "zip", zip)

    @property
    @pulumi.getter(name="cloudBuildOptions")
    def cloud_build_options(self) -> Optional[pulumi.Input['FlexibleAppVersionDeploymentCloudBuildOptionsArgs']]:
        """
        Options for the build operations performed as a part of the version deployment. Only applicable when creating a version using source code directly.
        Structure is documented below.
        """
        ...

    @cloud_build_options.setter
    def cloud_build_options(self, value: Optional[pulumi.Input['FlexibleAppVersionDeploymentCloudBuildOptionsArgs']]):
        ...

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input['FlexibleAppVersionDeploymentContainerArgs']]:
        """
        The Docker image for the container that runs the version.
        Structure is documented below.
        """
        ...

    @container.setter
    def container(self, value: Optional[pulumi.Input['FlexibleAppVersionDeploymentContainerArgs']]):
        ...

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[List[pulumi.Input['FlexibleAppVersionDeploymentFileArgs']]]]:
        """
        Manifest of the files stored in Google Cloud Storage that are included as part of this version.
        All files must be readable using the credentials supplied with this call.
        Structure is documented below.
        """
        ...

    @files.setter
    def files(self, value: Optional[pulumi.Input[List[pulumi.Input['FlexibleAppVersionDeploymentFileArgs']]]]):
        ...

    @property
    @pulumi.getter
    def zip(self) -> Optional[pulumi.Input['FlexibleAppVersionDeploymentZipArgs']]:
        """
        Zip File
        Structure is documented below.
        """
        ...

    @zip.setter
    def zip(self, value: Optional[pulumi.Input['FlexibleAppVersionDeploymentZipArgs']]):
        ...


@pulumi.input_type
class FlexibleAppVersionDeploymentCloudBuildOptionsArgs:
    def __init__(__self__, *,
                 app_yaml_path: pulumi.Input[str],
                 cloud_build_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] app_yaml_path: Path to the yaml file used in deployment, used to determine runtime configuration details.
        :param pulumi.Input[str] cloud_build_timeout: The Cloud Build timeout used as part of any dependent builds performed by version creation. Defaults to 10 minutes.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        pulumi.set(__self__, "appYamlPath", app_yaml_path)
        pulumi.set(__self__, "cloudBuildTimeout", cloud_build_timeout)

    @property
    @pulumi.getter(name="appYamlPath")
    def app_yaml_path(self) -> pulumi.Input[str]:
        """
        Path to the yaml file used in deployment, used to determine runtime configuration details.
        """
        ...

    @app_yaml_path.setter
    def app_yaml_path(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="cloudBuildTimeout")
    def cloud_build_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud Build timeout used as part of any dependent builds performed by version creation. Defaults to 10 minutes.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        ...

    @cloud_build_timeout.setter
    def cloud_build_timeout(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionDeploymentContainerArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str]):
        """
        :param pulumi.Input[str] image: URI to the hosted container image in Google Container Registry. The URI must be fully qualified and include a tag or digest.
               Examples: "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
        """
        pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        URI to the hosted container image in Google Container Registry. The URI must be fully qualified and include a tag or digest.
        Examples: "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
        """
        ...

    @image.setter
    def image(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class FlexibleAppVersionDeploymentFileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 source_url: pulumi.Input[str],
                 sha1_sum: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        :param pulumi.Input[str] source_url: Source URL
        :param pulumi.Input[str] sha1_sum: SHA1 checksum of the file
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sourceUrl", source_url)
        pulumi.set(__self__, "sha1Sum", sha1_sum)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        """
        ...

    @name.setter
    def name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        Source URL
        """
        ...

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="sha1Sum")
    def sha1_sum(self) -> Optional[pulumi.Input[str]]:
        """
        SHA1 checksum of the file
        """
        ...

    @sha1_sum.setter
    def sha1_sum(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionDeploymentZipArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[str],
                 files_count: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] source_url: Source URL
        :param pulumi.Input[float] files_count: files count
        """
        pulumi.set(__self__, "sourceUrl", source_url)
        pulumi.set(__self__, "filesCount", files_count)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        Source URL
        """
        ...

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="filesCount")
    def files_count(self) -> Optional[pulumi.Input[float]]:
        """
        files count
        """
        ...

    @files_count.setter
    def files_count(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class FlexibleAppVersionEndpointsApiServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 config_id: Optional[pulumi.Input[str]] = None,
                 disable_trace_sampling: Optional[pulumi.Input[bool]] = None,
                 rollout_strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        :param pulumi.Input[str] config_id: Endpoints service configuration ID as specified by the Service Management API. For example "2016-09-19r1".
               By default, the rollout strategy for Endpoints is "FIXED". This means that Endpoints starts up with a particular configuration ID.
               When a new configuration is rolled out, Endpoints must be given the new configuration ID. The configId field is used to give the configuration ID
               and is required in this case.
               Endpoints also has a rollout strategy called "MANAGED". When using this, Endpoints fetches the latest configuration and does not need
               the configuration ID. In this case, configId must be omitted.
        :param pulumi.Input[bool] disable_trace_sampling: Enable or disable trace sampling. By default, this is set to false for enabled.
        :param pulumi.Input[str] rollout_strategy: Endpoints rollout strategy. If FIXED, configId must be specified. If MANAGED, configId must be omitted.
               Default value is `FIXED`.
               Possible values are `FIXED` and `MANAGED`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "configId", config_id)
        pulumi.set(__self__, "disableTraceSampling", disable_trace_sampling)
        pulumi.set(__self__, "rolloutStrategy", rollout_strategy)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        """
        ...

    @name.setter
    def name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoints service configuration ID as specified by the Service Management API. For example "2016-09-19r1".
        By default, the rollout strategy for Endpoints is "FIXED". This means that Endpoints starts up with a particular configuration ID.
        When a new configuration is rolled out, Endpoints must be given the new configuration ID. The configId field is used to give the configuration ID
        and is required in this case.
        Endpoints also has a rollout strategy called "MANAGED". When using this, Endpoints fetches the latest configuration and does not need
        the configuration ID. In this case, configId must be omitted.
        """
        ...

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="disableTraceSampling")
    def disable_trace_sampling(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable trace sampling. By default, this is set to false for enabled.
        """
        ...

    @disable_trace_sampling.setter
    def disable_trace_sampling(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="rolloutStrategy")
    def rollout_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoints rollout strategy. If FIXED, configId must be specified. If MANAGED, configId must be omitted.
        Default value is `FIXED`.
        Possible values are `FIXED` and `MANAGED`.
        """
        ...

    @rollout_strategy.setter
    def rollout_strategy(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionEntrypointArgs:
    def __init__(__self__, *,
                 shell: pulumi.Input[str]):
        """
        :param pulumi.Input[str] shell: The format should be a shell command that can be fed to bash -c.
        """
        pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def shell(self) -> pulumi.Input[str]:
        """
        The format should be a shell command that can be fed to bash -c.
        """
        ...

    @shell.setter
    def shell(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class FlexibleAppVersionHandlerArgs:
    def __init__(__self__, *,
                 auth_fail_action: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input[str]] = None,
                 redirect_http_response_code: Optional[pulumi.Input[str]] = None,
                 script: Optional[pulumi.Input['FlexibleAppVersionHandlerScriptArgs']] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 static_files: Optional[pulumi.Input['FlexibleAppVersionHandlerStaticFilesArgs']] = None,
                 url_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_fail_action: Action to take when users access resources that require authentication.
               Default value is `AUTH_FAIL_ACTION_REDIRECT`.
               Possible values are `AUTH_FAIL_ACTION_REDIRECT` and `AUTH_FAIL_ACTION_UNAUTHORIZED`.
        :param pulumi.Input[str] login: Level of login required to access this resource.
               Default value is `LOGIN_OPTIONAL`.
               Possible values are `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, and `LOGIN_REQUIRED`.
        :param pulumi.Input[str] redirect_http_response_code: 30x code to use when performing redirects for the secure field.
               Possible values are `REDIRECT_HTTP_RESPONSE_CODE_301`, `REDIRECT_HTTP_RESPONSE_CODE_302`, `REDIRECT_HTTP_RESPONSE_CODE_303`, and `REDIRECT_HTTP_RESPONSE_CODE_307`.
        :param pulumi.Input['FlexibleAppVersionHandlerScriptArgs'] script: Path to the script from the application root directory.
        :param pulumi.Input[str] security_level: Security (HTTPS) enforcement for this URL.
               Possible values are `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, and `SECURE_ALWAYS`.
        :param pulumi.Input['FlexibleAppVersionHandlerStaticFilesArgs'] static_files: Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files.
               Static file handlers describe which files in the application directory are static files, and which URLs serve them.
               Structure is documented below.
        :param pulumi.Input[str] url_regex: URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings.
               All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
        """
        pulumi.set(__self__, "authFailAction", auth_fail_action)
        pulumi.set(__self__, "login", login)
        pulumi.set(__self__, "redirectHttpResponseCode", redirect_http_response_code)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "securityLevel", security_level)
        pulumi.set(__self__, "staticFiles", static_files)
        pulumi.set(__self__, "urlRegex", url_regex)

    @property
    @pulumi.getter(name="authFailAction")
    def auth_fail_action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to take when users access resources that require authentication.
        Default value is `AUTH_FAIL_ACTION_REDIRECT`.
        Possible values are `AUTH_FAIL_ACTION_REDIRECT` and `AUTH_FAIL_ACTION_UNAUTHORIZED`.
        """
        ...

    @auth_fail_action.setter
    def auth_fail_action(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input[str]]:
        """
        Level of login required to access this resource.
        Default value is `LOGIN_OPTIONAL`.
        Possible values are `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, and `LOGIN_REQUIRED`.
        """
        ...

    @login.setter
    def login(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="redirectHttpResponseCode")
    def redirect_http_response_code(self) -> Optional[pulumi.Input[str]]:
        """
        30x code to use when performing redirects for the secure field.
        Possible values are `REDIRECT_HTTP_RESPONSE_CODE_301`, `REDIRECT_HTTP_RESPONSE_CODE_302`, `REDIRECT_HTTP_RESPONSE_CODE_303`, and `REDIRECT_HTTP_RESPONSE_CODE_307`.
        """
        ...

    @redirect_http_response_code.setter
    def redirect_http_response_code(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input['FlexibleAppVersionHandlerScriptArgs']]:
        """
        Path to the script from the application root directory.
        """
        ...

    @script.setter
    def script(self, value: Optional[pulumi.Input['FlexibleAppVersionHandlerScriptArgs']]):
        ...

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Security (HTTPS) enforcement for this URL.
        Possible values are `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, and `SECURE_ALWAYS`.
        """
        ...

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="staticFiles")
    def static_files(self) -> Optional[pulumi.Input['FlexibleAppVersionHandlerStaticFilesArgs']]:
        """
        Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files.
        Static file handlers describe which files in the application directory are static files, and which URLs serve them.
        Structure is documented below.
        """
        ...

    @static_files.setter
    def static_files(self, value: Optional[pulumi.Input['FlexibleAppVersionHandlerStaticFilesArgs']]):
        ...

    @property
    @pulumi.getter(name="urlRegex")
    def url_regex(self) -> Optional[pulumi.Input[str]]:
        """
        URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings.
        All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
        """
        ...

    @url_regex.setter
    def url_regex(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionHandlerScriptArgs:
    def __init__(__self__, *,
                 script_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] script_path: Path to the script from the application root directory.
        """
        pulumi.set(__self__, "scriptPath", script_path)

    @property
    @pulumi.getter(name="scriptPath")
    def script_path(self) -> pulumi.Input[str]:
        """
        Path to the script from the application root directory.
        """
        ...

    @script_path.setter
    def script_path(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class FlexibleAppVersionHandlerStaticFilesArgs:
    def __init__(__self__, *,
                 application_readable: Optional[pulumi.Input[bool]] = None,
                 expiration: Optional[pulumi.Input[str]] = None,
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 mime_type: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 require_matching_file: Optional[pulumi.Input[bool]] = None,
                 upload_path_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] application_readable: Whether files should also be uploaded as code data. By default, files declared in static file handlers are
               uploaded as static data and are only served to end users; they cannot be read by the application. If enabled,
               uploads are charged against both your code and static data storage resource quotas.
        :param pulumi.Input[str] expiration: Time a static file served by this handler should be cached by web proxies and browsers.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example "3.5s".
               Default is '0s'
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers to use for all responses from these URLs.
               An object containing a list of "key:value" value pairs.".
        :param pulumi.Input[str] mime_type: MIME type used to serve all files served by this handler.
               Defaults to file-specific MIME types, which are derived from each file's filename extension.
        :param pulumi.Input[str] path: Path to the static files matched by the URL pattern, from the application root directory.
               The path can refer to text matched in groupings in the URL pattern.
        :param pulumi.Input[bool] require_matching_file: Whether this handler should match the request if the file referenced by the handler does not exist.
        :param pulumi.Input[str] upload_path_regex: Regular expression that matches the file paths for all files that should be referenced by this handler.
        """
        pulumi.set(__self__, "applicationReadable", application_readable)
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "httpHeaders", http_headers)
        pulumi.set(__self__, "mimeType", mime_type)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "requireMatchingFile", require_matching_file)
        pulumi.set(__self__, "uploadPathRegex", upload_path_regex)

    @property
    @pulumi.getter(name="applicationReadable")
    def application_readable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether files should also be uploaded as code data. By default, files declared in static file handlers are
        uploaded as static data and are only served to end users; they cannot be read by the application. If enabled,
        uploads are charged against both your code and static data storage resource quotas.
        """
        ...

    @application_readable.setter
    def application_readable(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[str]]:
        """
        Time a static file served by this handler should be cached by web proxies and browsers.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example "3.5s".
        Default is '0s'
        """
        ...

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers to use for all responses from these URLs.
        An object containing a list of "key:value" value pairs.".
        """
        ...

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[str]]:
        """
        MIME type used to serve all files served by this handler.
        Defaults to file-specific MIME types, which are derived from each file's filename extension.
        """
        ...

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the static files matched by the URL pattern, from the application root directory.
        The path can refer to text matched in groupings in the URL pattern.
        """
        ...

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="requireMatchingFile")
    def require_matching_file(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this handler should match the request if the file referenced by the handler does not exist.
        """
        ...

    @require_matching_file.setter
    def require_matching_file(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="uploadPathRegex")
    def upload_path_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression that matches the file paths for all files that should be referenced by this handler.
        """
        ...

    @upload_path_regex.setter
    def upload_path_regex(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionLivenessCheckArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 check_interval: Optional[pulumi.Input[str]] = None,
                 failure_threshold: Optional[pulumi.Input[float]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 initial_delay: Optional[pulumi.Input[str]] = None,
                 success_threshold: Optional[pulumi.Input[float]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: Path to the static files matched by the URL pattern, from the application root directory.
               The path can refer to text matched in groupings in the URL pattern.
        :param pulumi.Input[str] check_interval: Interval between health checks.
        :param pulumi.Input[float] failure_threshold: Number of consecutive failed checks required before considering the VM unhealthy. Default: 4.
        :param pulumi.Input[str] host: Host header to send when performing a HTTP Readiness check. Example: "myapp.appspot.com"
        :param pulumi.Input[str] initial_delay: The initial delay before starting to execute the checks. Default: "300s"
        :param pulumi.Input[float] success_threshold: Number of consecutive successful checks required before considering the VM healthy. Default: 2.
        :param pulumi.Input[str] timeout: Time before the check is considered failed. Default: "4s"
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "checkInterval", check_interval)
        pulumi.set(__self__, "failureThreshold", failure_threshold)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "initialDelay", initial_delay)
        pulumi.set(__self__, "successThreshold", success_threshold)
        pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to the static files matched by the URL pattern, from the application root directory.
        The path can refer to text matched in groupings in the URL pattern.
        """
        ...

    @path.setter
    def path(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Interval between health checks.
        """
        ...

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Number of consecutive failed checks required before considering the VM unhealthy. Default: 4.
        """
        ...

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host header to send when performing a HTTP Readiness check. Example: "myapp.appspot.com"
        """
        ...

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="initialDelay")
    def initial_delay(self) -> Optional[pulumi.Input[str]]:
        """
        The initial delay before starting to execute the checks. Default: "300s"
        """
        ...

    @initial_delay.setter
    def initial_delay(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Number of consecutive successful checks required before considering the VM healthy. Default: 2.
        """
        ...

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Time before the check is considered failed. Default: "4s"
        """
        ...

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionManualScalingArgs:
    def __init__(__self__, *,
                 instances: pulumi.Input[float]):
        """
        :param pulumi.Input[float] instances: Number of instances to assign to the service at the start.
               **Note:** When managing the number of instances at runtime through the App Engine Admin API or the (now deprecated) Python 2
               Modules API set_num_instances() you must use `lifecycle.ignore_changes = ["manual_scaling"[0].instances]` to prevent drift detection.
        """
        pulumi.set(__self__, "instances", instances)

    @property
    @pulumi.getter
    def instances(self) -> pulumi.Input[float]:
        """
        Number of instances to assign to the service at the start.
        **Note:** When managing the number of instances at runtime through the App Engine Admin API or the (now deprecated) Python 2
        Modules API set_num_instances() you must use `lifecycle.ignore_changes = ["manual_scaling"[0].instances]` to prevent drift detection.
        """
        ...

    @instances.setter
    def instances(self, value: pulumi.Input[float]):
        ...


@pulumi.input_type
class FlexibleAppVersionNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 forwarded_ports: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 instance_tag: Optional[pulumi.Input[str]] = None,
                 session_affinity: Optional[pulumi.Input[bool]] = None,
                 subnetwork: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        :param pulumi.Input[List[pulumi.Input[str]]] forwarded_ports: List of ports, or port pairs, to forward from the virtual machine to the application container.
        :param pulumi.Input[str] instance_tag: Tag to apply to the instance during creation.
        :param pulumi.Input[bool] session_affinity: Enable session affinity.
        :param pulumi.Input[str] subnetwork: Google Cloud Platform sub-network where the virtual machines are created. Specify the short name, not the resource path.
               If the network that the instance is being created in is a Legacy network, then the IP address is allocated from the IPv4Range.
               If the network that the instance is being created in is an auto Subnet Mode Network, then only network name should be specified (not the subnetworkName) and the IP address is created from the IPCidrRange of the subnetwork that exists in that zone for that network.
               If the network that the instance is being created in is a custom Subnet Mode Network, then the subnetworkName must be specified and the IP address is created from the IPCidrRange of the subnetwork.
               If specified, the subnetwork must exist in the same region as the App Engine flexible environment application.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "forwardedPorts", forwarded_ports)
        pulumi.set(__self__, "instanceTag", instance_tag)
        pulumi.set(__self__, "sessionAffinity", session_affinity)
        pulumi.set(__self__, "subnetwork", subnetwork)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        """
        ...

    @name.setter
    def name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="forwardedPorts")
    def forwarded_ports(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of ports, or port pairs, to forward from the virtual machine to the application container.
        """
        ...

    @forwarded_ports.setter
    def forwarded_ports(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="instanceTag")
    def instance_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Tag to apply to the instance during creation.
        """
        ...

    @instance_tag.setter
    def instance_tag(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable session affinity.
        """
        ...

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[pulumi.Input[str]]:
        """
        Google Cloud Platform sub-network where the virtual machines are created. Specify the short name, not the resource path.
        If the network that the instance is being created in is a Legacy network, then the IP address is allocated from the IPv4Range.
        If the network that the instance is being created in is an auto Subnet Mode Network, then only network name should be specified (not the subnetworkName) and the IP address is created from the IPCidrRange of the subnetwork that exists in that zone for that network.
        If the network that the instance is being created in is a custom Subnet Mode Network, then the subnetworkName must be specified and the IP address is created from the IPCidrRange of the subnetwork.
        If specified, the subnetwork must exist in the same region as the App Engine flexible environment application.
        """
        ...

    @subnetwork.setter
    def subnetwork(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionReadinessCheckArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 app_start_timeout: Optional[pulumi.Input[str]] = None,
                 check_interval: Optional[pulumi.Input[str]] = None,
                 failure_threshold: Optional[pulumi.Input[float]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 success_threshold: Optional[pulumi.Input[float]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: Path to the static files matched by the URL pattern, from the application root directory.
               The path can refer to text matched in groupings in the URL pattern.
        :param pulumi.Input[str] app_start_timeout: A maximum time limit on application initialization, measured from moment the application successfully
               replies to a healthcheck until it is ready to serve traffic. Default: "300s"
        :param pulumi.Input[str] check_interval: Interval between health checks.
        :param pulumi.Input[float] failure_threshold: Number of consecutive failed checks required before considering the VM unhealthy. Default: 4.
        :param pulumi.Input[str] host: Host header to send when performing a HTTP Readiness check. Example: "myapp.appspot.com"
        :param pulumi.Input[float] success_threshold: Number of consecutive successful checks required before considering the VM healthy. Default: 2.
        :param pulumi.Input[str] timeout: Time before the check is considered failed. Default: "4s"
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "appStartTimeout", app_start_timeout)
        pulumi.set(__self__, "checkInterval", check_interval)
        pulumi.set(__self__, "failureThreshold", failure_threshold)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "successThreshold", success_threshold)
        pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to the static files matched by the URL pattern, from the application root directory.
        The path can refer to text matched in groupings in the URL pattern.
        """
        ...

    @path.setter
    def path(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="appStartTimeout")
    def app_start_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        A maximum time limit on application initialization, measured from moment the application successfully
        replies to a healthcheck until it is ready to serve traffic. Default: "300s"
        """
        ...

    @app_start_timeout.setter
    def app_start_timeout(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Interval between health checks.
        """
        ...

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Number of consecutive failed checks required before considering the VM unhealthy. Default: 4.
        """
        ...

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host header to send when performing a HTTP Readiness check. Example: "myapp.appspot.com"
        """
        ...

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Number of consecutive successful checks required before considering the VM healthy. Default: 2.
        """
        ...

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Time before the check is considered failed. Default: "4s"
        """
        ...

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FlexibleAppVersionResourcesArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[float]] = None,
                 disk_gb: Optional[pulumi.Input[float]] = None,
                 memory_gb: Optional[pulumi.Input[float]] = None,
                 volumes: Optional[pulumi.Input[List[pulumi.Input['FlexibleAppVersionResourcesVolumeArgs']]]] = None):
        """
        :param pulumi.Input[float] cpu: Number of CPU cores needed.
        :param pulumi.Input[float] disk_gb: Disk size (GB) needed.
        :param pulumi.Input[float] memory_gb: Memory (GB) needed.
        :param pulumi.Input[List[pulumi.Input['FlexibleAppVersionResourcesVolumeArgs']]] volumes: List of ports, or port pairs, to forward from the virtual machine to the application container.
               Structure is documented below.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "diskGb", disk_gb)
        pulumi.set(__self__, "memoryGb", memory_gb)
        pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[float]]:
        """
        Number of CPU cores needed.
        """
        ...

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="diskGb")
    def disk_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Disk size (GB) needed.
        """
        ...

    @disk_gb.setter
    def disk_gb(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="memoryGb")
    def memory_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Memory (GB) needed.
        """
        ...

    @memory_gb.setter
    def memory_gb(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[List[pulumi.Input['FlexibleAppVersionResourcesVolumeArgs']]]]:
        """
        List of ports, or port pairs, to forward from the virtual machine to the application container.
        Structure is documented below.
        """
        ...

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[List[pulumi.Input['FlexibleAppVersionResourcesVolumeArgs']]]]):
        ...


@pulumi.input_type
class FlexibleAppVersionResourcesVolumeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 size_gb: pulumi.Input[float],
                 volume_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        :param pulumi.Input[float] size_gb: Volume size in gigabytes.
        :param pulumi.Input[str] volume_type: Underlying volume type, e.g. 'tmpfs'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sizeGb", size_gb)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        """
        ...

    @name.setter
    def name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> pulumi.Input[float]:
        """
        Volume size in gigabytes.
        """
        ...

    @size_gb.setter
    def size_gb(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[str]:
        """
        Underlying volume type, e.g. 'tmpfs'.
        """
        ...

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class FlexibleAppVersionVpcAccessConnectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
        """
        ...

    @name.setter
    def name(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class StandardAppVersionAutomaticScalingArgs:
    def __init__(__self__, *,
                 max_concurrent_requests: Optional[pulumi.Input[float]] = None,
                 max_idle_instances: Optional[pulumi.Input[float]] = None,
                 max_pending_latency: Optional[pulumi.Input[str]] = None,
                 min_idle_instances: Optional[pulumi.Input[float]] = None,
                 min_pending_latency: Optional[pulumi.Input[str]] = None,
                 standard_scheduler_settings: Optional[pulumi.Input['StandardAppVersionAutomaticScalingStandardSchedulerSettingsArgs']] = None):
        """
        :param pulumi.Input[float] max_concurrent_requests: Number of concurrent requests an automatic scaling instance can accept before the scheduler spawns a new instance.
               Defaults to a runtime-specific value.
        :param pulumi.Input[float] max_idle_instances: Maximum number of idle instances that should be maintained for this version.
        :param pulumi.Input[str] max_pending_latency: Maximum amount of time that a request should wait in the pending queue before starting a new instance to handle it.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        :param pulumi.Input[float] min_idle_instances: Minimum number of idle instances that should be maintained for this version. Only applicable for the default version of a service.
        :param pulumi.Input[str] min_pending_latency: Minimum amount of time a request should wait in the pending queue before starting a new instance to handle it.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        :param pulumi.Input['StandardAppVersionAutomaticScalingStandardSchedulerSettingsArgs'] standard_scheduler_settings: Scheduler settings for standard environment.
               Structure is documented below.
        """
        pulumi.set(__self__, "maxConcurrentRequests", max_concurrent_requests)
        pulumi.set(__self__, "maxIdleInstances", max_idle_instances)
        pulumi.set(__self__, "maxPendingLatency", max_pending_latency)
        pulumi.set(__self__, "minIdleInstances", min_idle_instances)
        pulumi.set(__self__, "minPendingLatency", min_pending_latency)
        pulumi.set(__self__, "standardSchedulerSettings", standard_scheduler_settings)

    @property
    @pulumi.getter(name="maxConcurrentRequests")
    def max_concurrent_requests(self) -> Optional[pulumi.Input[float]]:
        """
        Number of concurrent requests an automatic scaling instance can accept before the scheduler spawns a new instance.
        Defaults to a runtime-specific value.
        """
        ...

    @max_concurrent_requests.setter
    def max_concurrent_requests(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="maxIdleInstances")
    def max_idle_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of idle instances that should be maintained for this version.
        """
        ...

    @max_idle_instances.setter
    def max_idle_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="maxPendingLatency")
    def max_pending_latency(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum amount of time that a request should wait in the pending queue before starting a new instance to handle it.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        ...

    @max_pending_latency.setter
    def max_pending_latency(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="minIdleInstances")
    def min_idle_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum number of idle instances that should be maintained for this version. Only applicable for the default version of a service.
        """
        ...

    @min_idle_instances.setter
    def min_idle_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="minPendingLatency")
    def min_pending_latency(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum amount of time a request should wait in the pending queue before starting a new instance to handle it.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        ...

    @min_pending_latency.setter
    def min_pending_latency(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="standardSchedulerSettings")
    def standard_scheduler_settings(self) -> Optional[pulumi.Input['StandardAppVersionAutomaticScalingStandardSchedulerSettingsArgs']]:
        """
        Scheduler settings for standard environment.
        Structure is documented below.
        """
        ...

    @standard_scheduler_settings.setter
    def standard_scheduler_settings(self, value: Optional[pulumi.Input['StandardAppVersionAutomaticScalingStandardSchedulerSettingsArgs']]):
        ...


@pulumi.input_type
class StandardAppVersionAutomaticScalingStandardSchedulerSettingsArgs:
    def __init__(__self__, *,
                 max_instances: Optional[pulumi.Input[float]] = None,
                 min_instances: Optional[pulumi.Input[float]] = None,
                 target_cpu_utilization: Optional[pulumi.Input[float]] = None,
                 target_throughput_utilization: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max_instances: Maximum number of instances to create for this version. Must be in the range [1.0, 200.0].
        :param pulumi.Input[float] min_instances: Minimum number of instances to run for this version. Set to zero to disable minInstances configuration.
        :param pulumi.Input[float] target_cpu_utilization: Target CPU utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
        :param pulumi.Input[float] target_throughput_utilization: Target throughput utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
        """
        pulumi.set(__self__, "maxInstances", max_instances)
        pulumi.set(__self__, "minInstances", min_instances)
        pulumi.set(__self__, "targetCpuUtilization", target_cpu_utilization)
        pulumi.set(__self__, "targetThroughputUtilization", target_throughput_utilization)

    @property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of instances to create for this version. Must be in the range [1.0, 200.0].
        """
        ...

    @max_instances.setter
    def max_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum number of instances to run for this version. Set to zero to disable minInstances configuration.
        """
        ...

    @min_instances.setter
    def min_instances(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetCpuUtilization")
    def target_cpu_utilization(self) -> Optional[pulumi.Input[float]]:
        """
        Target CPU utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
        """
        ...

    @target_cpu_utilization.setter
    def target_cpu_utilization(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="targetThroughputUtilization")
    def target_throughput_utilization(self) -> Optional[pulumi.Input[float]]:
        """
        Target throughput utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
        """
        ...

    @target_throughput_utilization.setter
    def target_throughput_utilization(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class StandardAppVersionBasicScalingArgs:
    def __init__(__self__, *,
                 max_instances: pulumi.Input[float],
                 idle_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] max_instances: Maximum number of instances to create for this version. Must be in the range [1.0, 200.0].
        :param pulumi.Input[str] idle_timeout: Duration of time after the last request that an instance must wait before the instance is shut down.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        pulumi.set(__self__, "maxInstances", max_instances)
        pulumi.set(__self__, "idleTimeout", idle_timeout)

    @property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> pulumi.Input[float]:
        """
        Maximum number of instances to create for this version. Must be in the range [1.0, 200.0].
        """
        ...

    @max_instances.setter
    def max_instances(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Duration of time after the last request that an instance must wait before the instance is shut down.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        ...

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class StandardAppVersionDeploymentArgs:
    def __init__(__self__, *,
                 files: Optional[pulumi.Input[List[pulumi.Input['StandardAppVersionDeploymentFileArgs']]]] = None,
                 zip: Optional[pulumi.Input['StandardAppVersionDeploymentZipArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input['StandardAppVersionDeploymentFileArgs']]] files: Manifest of the files stored in Google Cloud Storage that are included as part of this version.
               All files must be readable using the credentials supplied with this call.
               Structure is documented below.
        :param pulumi.Input['StandardAppVersionDeploymentZipArgs'] zip: Zip File
               Structure is documented below.
        """
        pulumi.set(__self__, "files", files)
        pulumi.set(__self__, "zip", zip)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[List[pulumi.Input['StandardAppVersionDeploymentFileArgs']]]]:
        """
        Manifest of the files stored in Google Cloud Storage that are included as part of this version.
        All files must be readable using the credentials supplied with this call.
        Structure is documented below.
        """
        ...

    @files.setter
    def files(self, value: Optional[pulumi.Input[List[pulumi.Input['StandardAppVersionDeploymentFileArgs']]]]):
        ...

    @property
    @pulumi.getter
    def zip(self) -> Optional[pulumi.Input['StandardAppVersionDeploymentZipArgs']]:
        """
        Zip File
        Structure is documented below.
        """
        ...

    @zip.setter
    def zip(self, value: Optional[pulumi.Input['StandardAppVersionDeploymentZipArgs']]):
        ...


@pulumi.input_type
class StandardAppVersionDeploymentFileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 source_url: pulumi.Input[str],
                 sha1_sum: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the library. Example "django".
        :param pulumi.Input[str] source_url: Source URL
        :param pulumi.Input[str] sha1_sum: SHA1 checksum of the file
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sourceUrl", source_url)
        pulumi.set(__self__, "sha1Sum", sha1_sum)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the library. Example "django".
        """
        ...

    @name.setter
    def name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        Source URL
        """
        ...

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="sha1Sum")
    def sha1_sum(self) -> Optional[pulumi.Input[str]]:
        """
        SHA1 checksum of the file
        """
        ...

    @sha1_sum.setter
    def sha1_sum(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class StandardAppVersionDeploymentZipArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[str],
                 files_count: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] source_url: Source URL
        :param pulumi.Input[float] files_count: files count
        """
        pulumi.set(__self__, "sourceUrl", source_url)
        pulumi.set(__self__, "filesCount", files_count)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        """
        Source URL
        """
        ...

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="filesCount")
    def files_count(self) -> Optional[pulumi.Input[float]]:
        """
        files count
        """
        ...

    @files_count.setter
    def files_count(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class StandardAppVersionEntrypointArgs:
    def __init__(__self__, *,
                 shell: pulumi.Input[str]):
        """
        :param pulumi.Input[str] shell: The format should be a shell command that can be fed to bash -c.
        """
        pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def shell(self) -> pulumi.Input[str]:
        """
        The format should be a shell command that can be fed to bash -c.
        """
        ...

    @shell.setter
    def shell(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class StandardAppVersionHandlerArgs:
    def __init__(__self__, *,
                 auth_fail_action: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input[str]] = None,
                 redirect_http_response_code: Optional[pulumi.Input[str]] = None,
                 script: Optional[pulumi.Input['StandardAppVersionHandlerScriptArgs']] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 static_files: Optional[pulumi.Input['StandardAppVersionHandlerStaticFilesArgs']] = None,
                 url_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_fail_action: Actions to take when the user is not logged in.
               Possible values are `AUTH_FAIL_ACTION_REDIRECT` and `AUTH_FAIL_ACTION_UNAUTHORIZED`.
        :param pulumi.Input[str] login: Methods to restrict access to a URL based on login status.
               Possible values are `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, and `LOGIN_REQUIRED`.
        :param pulumi.Input[str] redirect_http_response_code: 30x code to use when performing redirects for the secure field.
               Possible values are `REDIRECT_HTTP_RESPONSE_CODE_301`, `REDIRECT_HTTP_RESPONSE_CODE_302`, `REDIRECT_HTTP_RESPONSE_CODE_303`, and `REDIRECT_HTTP_RESPONSE_CODE_307`.
        :param pulumi.Input['StandardAppVersionHandlerScriptArgs'] script: Executes a script to handle the requests that match this URL pattern.
               Only the auto value is supported for Node.js in the App Engine standard environment, for example "script:" "auto".
               Structure is documented below.
        :param pulumi.Input[str] security_level: Security (HTTPS) enforcement for this URL.
               Possible values are `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, and `SECURE_ALWAYS`.
        :param pulumi.Input['StandardAppVersionHandlerStaticFilesArgs'] static_files: Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files. Static file handlers describe which files in the application directory are static files, and which URLs serve them.
               Structure is documented below.
        :param pulumi.Input[str] url_regex: URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings.
               All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
        """
        pulumi.set(__self__, "authFailAction", auth_fail_action)
        pulumi.set(__self__, "login", login)
        pulumi.set(__self__, "redirectHttpResponseCode", redirect_http_response_code)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "securityLevel", security_level)
        pulumi.set(__self__, "staticFiles", static_files)
        pulumi.set(__self__, "urlRegex", url_regex)

    @property
    @pulumi.getter(name="authFailAction")
    def auth_fail_action(self) -> Optional[pulumi.Input[str]]:
        """
        Actions to take when the user is not logged in.
        Possible values are `AUTH_FAIL_ACTION_REDIRECT` and `AUTH_FAIL_ACTION_UNAUTHORIZED`.
        """
        ...

    @auth_fail_action.setter
    def auth_fail_action(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input[str]]:
        """
        Methods to restrict access to a URL based on login status.
        Possible values are `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, and `LOGIN_REQUIRED`.
        """
        ...

    @login.setter
    def login(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="redirectHttpResponseCode")
    def redirect_http_response_code(self) -> Optional[pulumi.Input[str]]:
        """
        30x code to use when performing redirects for the secure field.
        Possible values are `REDIRECT_HTTP_RESPONSE_CODE_301`, `REDIRECT_HTTP_RESPONSE_CODE_302`, `REDIRECT_HTTP_RESPONSE_CODE_303`, and `REDIRECT_HTTP_RESPONSE_CODE_307`.
        """
        ...

    @redirect_http_response_code.setter
    def redirect_http_response_code(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input['StandardAppVersionHandlerScriptArgs']]:
        """
        Executes a script to handle the requests that match this URL pattern.
        Only the auto value is supported for Node.js in the App Engine standard environment, for example "script:" "auto".
        Structure is documented below.
        """
        ...

    @script.setter
    def script(self, value: Optional[pulumi.Input['StandardAppVersionHandlerScriptArgs']]):
        ...

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Security (HTTPS) enforcement for this URL.
        Possible values are `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, and `SECURE_ALWAYS`.
        """
        ...

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="staticFiles")
    def static_files(self) -> Optional[pulumi.Input['StandardAppVersionHandlerStaticFilesArgs']]:
        """
        Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files. Static file handlers describe which files in the application directory are static files, and which URLs serve them.
        Structure is documented below.
        """
        ...

    @static_files.setter
    def static_files(self, value: Optional[pulumi.Input['StandardAppVersionHandlerStaticFilesArgs']]):
        ...

    @property
    @pulumi.getter(name="urlRegex")
    def url_regex(self) -> Optional[pulumi.Input[str]]:
        """
        URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings.
        All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
        """
        ...

    @url_regex.setter
    def url_regex(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class StandardAppVersionHandlerScriptArgs:
    def __init__(__self__, *,
                 script_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] script_path: Path to the script from the application root directory.
        """
        pulumi.set(__self__, "scriptPath", script_path)

    @property
    @pulumi.getter(name="scriptPath")
    def script_path(self) -> pulumi.Input[str]:
        """
        Path to the script from the application root directory.
        """
        ...

    @script_path.setter
    def script_path(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class StandardAppVersionHandlerStaticFilesArgs:
    def __init__(__self__, *,
                 application_readable: Optional[pulumi.Input[bool]] = None,
                 expiration: Optional[pulumi.Input[str]] = None,
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 mime_type: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 require_matching_file: Optional[pulumi.Input[bool]] = None,
                 upload_path_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] application_readable: Whether files should also be uploaded as code data. By default, files declared in static file handlers are uploaded as
               static data and are only served to end users; they cannot be read by the application. If enabled, uploads are charged
               against both your code and static data storage resource quotas.
        :param pulumi.Input[str] expiration: Time a static file served by this handler should be cached by web proxies and browsers.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example "3.5s".
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers to use for all responses from these URLs.
               An object containing a list of "key:value" value pairs.".
        :param pulumi.Input[str] mime_type: MIME type used to serve all files served by this handler.
               Defaults to file-specific MIME types, which are derived from each file's filename extension.
        :param pulumi.Input[str] path: Path to the static files matched by the URL pattern, from the application root directory. The path can refer to text matched in groupings in the URL pattern.
        :param pulumi.Input[bool] require_matching_file: Whether this handler should match the request if the file referenced by the handler does not exist.
        :param pulumi.Input[str] upload_path_regex: Regular expression that matches the file paths for all files that should be referenced by this handler.
        """
        pulumi.set(__self__, "applicationReadable", application_readable)
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "httpHeaders", http_headers)
        pulumi.set(__self__, "mimeType", mime_type)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "requireMatchingFile", require_matching_file)
        pulumi.set(__self__, "uploadPathRegex", upload_path_regex)

    @property
    @pulumi.getter(name="applicationReadable")
    def application_readable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether files should also be uploaded as code data. By default, files declared in static file handlers are uploaded as
        static data and are only served to end users; they cannot be read by the application. If enabled, uploads are charged
        against both your code and static data storage resource quotas.
        """
        ...

    @application_readable.setter
    def application_readable(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[str]]:
        """
        Time a static file served by this handler should be cached by web proxies and browsers.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example "3.5s".
        """
        ...

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers to use for all responses from these URLs.
        An object containing a list of "key:value" value pairs.".
        """
        ...

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[str]]:
        """
        MIME type used to serve all files served by this handler.
        Defaults to file-specific MIME types, which are derived from each file's filename extension.
        """
        ...

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the static files matched by the URL pattern, from the application root directory. The path can refer to text matched in groupings in the URL pattern.
        """
        ...

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="requireMatchingFile")
    def require_matching_file(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this handler should match the request if the file referenced by the handler does not exist.
        """
        ...

    @require_matching_file.setter
    def require_matching_file(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="uploadPathRegex")
    def upload_path_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression that matches the file paths for all files that should be referenced by this handler.
        """
        ...

    @upload_path_regex.setter
    def upload_path_regex(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class StandardAppVersionLibraryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the library. Example "django".
        :param pulumi.Input[str] version: Version of the library to select, or "latest".
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the library. Example "django".
        """
        ...

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the library to select, or "latest".
        """
        ...

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class StandardAppVersionManualScalingArgs:
    def __init__(__self__, *,
                 instances: pulumi.Input[float]):
        """
        :param pulumi.Input[float] instances: Number of instances to assign to the service at the start.
               **Note:** When managing the number of instances at runtime through the App Engine Admin API or the (now deprecated) Python 2
               Modules API set_num_instances() you must use `lifecycle.ignore_changes = ["manual_scaling"[0].instances]` to prevent drift detection.
        """
        pulumi.set(__self__, "instances", instances)

    @property
    @pulumi.getter
    def instances(self) -> pulumi.Input[float]:
        """
        Number of instances to assign to the service at the start.
        **Note:** When managing the number of instances at runtime through the App Engine Admin API or the (now deprecated) Python 2
        Modules API set_num_instances() you must use `lifecycle.ignore_changes = ["manual_scaling"[0].instances]` to prevent drift detection.
        """
        ...

    @instances.setter
    def instances(self, value: pulumi.Input[float]):
        ...


